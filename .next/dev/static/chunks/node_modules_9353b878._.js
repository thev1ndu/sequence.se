(globalThis.TURBOPACK || (globalThis.TURBOPACK = [])).push([typeof document === "object" ? document.currentScript : undefined,
"[project]/node_modules/@radix-ui/react-collapsible/node_modules/@radix-ui/react-primitive/dist/index.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// src/primitive.tsx
__turbopack_context__.s([
    "Primitive",
    ()=>Primitive,
    "Root",
    ()=>Root,
    "dispatchDiscreteCustomEvent",
    ()=>dispatchDiscreteCustomEvent
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2d$dom$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react-dom/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$slot$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@radix-ui/react-slot/dist/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)");
;
;
;
;
var NODES = [
    "a",
    "button",
    "div",
    "form",
    "h2",
    "h3",
    "img",
    "input",
    "label",
    "li",
    "nav",
    "ol",
    "p",
    "select",
    "span",
    "svg",
    "ul"
];
var Primitive = NODES.reduce((primitive, node)=>{
    const Slot = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$slot$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createSlot"])(`Primitive.${node}`);
    const Node = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["forwardRef"]((props, forwardedRef)=>{
        const { asChild, ...primitiveProps } = props;
        const Comp = asChild ? Slot : node;
        if (typeof window !== "undefined") {
            window[Symbol.for("radix-ui")] = true;
        }
        return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(Comp, {
            ...primitiveProps,
            ref: forwardedRef
        });
    });
    Node.displayName = `Primitive.${node}`;
    return {
        ...primitive,
        [node]: Node
    };
}, {});
function dispatchDiscreteCustomEvent(target, event) {
    if (target) __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2d$dom$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["flushSync"](()=>target.dispatchEvent(event));
}
var Root = Primitive;
;
 //# sourceMappingURL=index.mjs.map
}),
"[project]/node_modules/@radix-ui/react-collapsible/dist/index.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Collapsible",
    ()=>Collapsible,
    "CollapsibleContent",
    ()=>CollapsibleContent,
    "CollapsibleTrigger",
    ()=>CollapsibleTrigger,
    "Content",
    ()=>Content,
    "Root",
    ()=>Root,
    "Trigger",
    ()=>Trigger,
    "createCollapsibleScope",
    ()=>createCollapsibleScope
]);
// src/collapsible.tsx
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$primitive$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@radix-ui/primitive/dist/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$context$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@radix-ui/react-context/dist/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$use$2d$controllable$2d$state$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@radix-ui/react-use-controllable-state/dist/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$use$2d$layout$2d$effect$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@radix-ui/react-use-layout-effect/dist/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$compose$2d$refs$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@radix-ui/react-compose-refs/dist/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$collapsible$2f$node_modules$2f40$radix$2d$ui$2f$react$2d$primitive$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@radix-ui/react-collapsible/node_modules/@radix-ui/react-primitive/dist/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$presence$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@radix-ui/react-presence/dist/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$id$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@radix-ui/react-id/dist/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)");
"use client";
;
;
;
;
;
;
;
;
;
;
var COLLAPSIBLE_NAME = "Collapsible";
var [createCollapsibleContext, createCollapsibleScope] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$context$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createContextScope"])(COLLAPSIBLE_NAME);
var [CollapsibleProvider, useCollapsibleContext] = createCollapsibleContext(COLLAPSIBLE_NAME);
var Collapsible = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["forwardRef"]((props, forwardedRef)=>{
    const { __scopeCollapsible, open: openProp, defaultOpen, disabled, onOpenChange, ...collapsibleProps } = props;
    const [open, setOpen] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$use$2d$controllable$2d$state$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useControllableState"])({
        prop: openProp,
        defaultProp: defaultOpen ?? false,
        onChange: onOpenChange,
        caller: COLLAPSIBLE_NAME
    });
    return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(CollapsibleProvider, {
        scope: __scopeCollapsible,
        disabled,
        contentId: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$id$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useId"])(),
        open,
        onOpenToggle: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"]({
            "Collapsible.useCallback": ()=>setOpen({
                    "Collapsible.useCallback": (prevOpen)=>!prevOpen
                }["Collapsible.useCallback"])
        }["Collapsible.useCallback"], [
            setOpen
        ]),
        children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$collapsible$2f$node_modules$2f40$radix$2d$ui$2f$react$2d$primitive$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Primitive"].div, {
            "data-state": getState(open),
            "data-disabled": disabled ? "" : void 0,
            ...collapsibleProps,
            ref: forwardedRef
        })
    });
});
Collapsible.displayName = COLLAPSIBLE_NAME;
var TRIGGER_NAME = "CollapsibleTrigger";
var CollapsibleTrigger = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["forwardRef"]((props, forwardedRef)=>{
    const { __scopeCollapsible, ...triggerProps } = props;
    const context = useCollapsibleContext(TRIGGER_NAME, __scopeCollapsible);
    return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$collapsible$2f$node_modules$2f40$radix$2d$ui$2f$react$2d$primitive$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Primitive"].button, {
        type: "button",
        "aria-controls": context.contentId,
        "aria-expanded": context.open || false,
        "data-state": getState(context.open),
        "data-disabled": context.disabled ? "" : void 0,
        disabled: context.disabled,
        ...triggerProps,
        ref: forwardedRef,
        onClick: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$primitive$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["composeEventHandlers"])(props.onClick, context.onOpenToggle)
    });
});
CollapsibleTrigger.displayName = TRIGGER_NAME;
var CONTENT_NAME = "CollapsibleContent";
var CollapsibleContent = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["forwardRef"]((props, forwardedRef)=>{
    const { forceMount, ...contentProps } = props;
    const context = useCollapsibleContext(CONTENT_NAME, props.__scopeCollapsible);
    return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$presence$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Presence"], {
        present: forceMount || context.open,
        children: ({ present })=>/* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(CollapsibleContentImpl, {
                ...contentProps,
                ref: forwardedRef,
                present
            })
    });
});
CollapsibleContent.displayName = CONTENT_NAME;
var CollapsibleContentImpl = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["forwardRef"]((props, forwardedRef)=>{
    const { __scopeCollapsible, present, children, ...contentProps } = props;
    const context = useCollapsibleContext(CONTENT_NAME, __scopeCollapsible);
    const [isPresent, setIsPresent] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"](present);
    const ref = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"](null);
    const composedRefs = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$compose$2d$refs$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useComposedRefs"])(forwardedRef, ref);
    const heightRef = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"](0);
    const height = heightRef.current;
    const widthRef = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"](0);
    const width = widthRef.current;
    const isOpen = context.open || isPresent;
    const isMountAnimationPreventedRef = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"](isOpen);
    const originalStylesRef = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"](void 0);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"]({
        "CollapsibleContentImpl.useEffect": ()=>{
            const rAF = requestAnimationFrame({
                "CollapsibleContentImpl.useEffect.rAF": ()=>isMountAnimationPreventedRef.current = false
            }["CollapsibleContentImpl.useEffect.rAF"]);
            return ({
                "CollapsibleContentImpl.useEffect": ()=>cancelAnimationFrame(rAF)
            })["CollapsibleContentImpl.useEffect"];
        }
    }["CollapsibleContentImpl.useEffect"], []);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$use$2d$layout$2d$effect$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useLayoutEffect"])({
        "CollapsibleContentImpl.useLayoutEffect": ()=>{
            const node = ref.current;
            if (node) {
                originalStylesRef.current = originalStylesRef.current || {
                    transitionDuration: node.style.transitionDuration,
                    animationName: node.style.animationName
                };
                node.style.transitionDuration = "0s";
                node.style.animationName = "none";
                const rect = node.getBoundingClientRect();
                heightRef.current = rect.height;
                widthRef.current = rect.width;
                if (!isMountAnimationPreventedRef.current) {
                    node.style.transitionDuration = originalStylesRef.current.transitionDuration;
                    node.style.animationName = originalStylesRef.current.animationName;
                }
                setIsPresent(present);
            }
        }
    }["CollapsibleContentImpl.useLayoutEffect"], [
        context.open,
        present
    ]);
    return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$collapsible$2f$node_modules$2f40$radix$2d$ui$2f$react$2d$primitive$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Primitive"].div, {
        "data-state": getState(context.open),
        "data-disabled": context.disabled ? "" : void 0,
        id: context.contentId,
        hidden: !isOpen,
        ...contentProps,
        ref: composedRefs,
        style: {
            [`--radix-collapsible-content-height`]: height ? `${height}px` : void 0,
            [`--radix-collapsible-content-width`]: width ? `${width}px` : void 0,
            ...props.style
        },
        children: isOpen && children
    });
});
function getState(open) {
    return open ? "open" : "closed";
}
var Root = Collapsible;
var Trigger = CollapsibleTrigger;
var Content = CollapsibleContent;
;
 //# sourceMappingURL=index.mjs.map
}),
"[project]/node_modules/@radix-ui/react-collapsible/dist/index.mjs [app-client] (ecmascript) <export * as Collapsible>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Collapsible",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$collapsible$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$collapsible$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@radix-ui/react-collapsible/dist/index.mjs [app-client] (ecmascript)");
}),
"[project]/node_modules/lucide-react/dist/esm/icons/mail.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ __turbopack_context__.s([
    "__iconNode",
    ()=>__iconNode,
    "default",
    ()=>Mail
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lucide-react/dist/esm/createLucideIcon.js [app-client] (ecmascript)");
;
const __iconNode = [
    [
        "path",
        {
            d: "m22 7-8.991 5.727a2 2 0 0 1-2.009 0L2 7",
            key: "132q7q"
        }
    ],
    [
        "rect",
        {
            x: "2",
            y: "4",
            width: "20",
            height: "16",
            rx: "2",
            key: "izxlao"
        }
    ]
];
const Mail = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])("mail", __iconNode);
;
 //# sourceMappingURL=mail.js.map
}),
"[project]/node_modules/lucide-react/dist/esm/icons/mail.js [app-client] (ecmascript) <export default as MailIcon>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "MailIcon",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$mail$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$mail$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lucide-react/dist/esm/icons/mail.js [app-client] (ecmascript)");
}),
"[project]/node_modules/libphonenumber-js/es6/tools/semver-compare.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Copy-pasted from:
// https://github.com/substack/semver-compare/blob/master/index.js
//
// Inlining this function because some users reported issues with
// importing from `semver-compare` in a browser with ES6 "native" modules.
//
// Fixes `semver-compare` not being able to compare versions with alpha/beta/etc "tags".
// https://github.com/catamphetamine/libphonenumber-js/issues/381
__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
function __TURBOPACK__default__export__(a, b) {
    a = a.split('-');
    b = b.split('-');
    var pa = a[0].split('.');
    var pb = b[0].split('.');
    for(var i = 0; i < 3; i++){
        var na = Number(pa[i]);
        var nb = Number(pb[i]);
        if (na > nb) return 1;
        if (nb > na) return -1;
        if (!isNaN(na) && isNaN(nb)) return 1;
        if (isNaN(na) && !isNaN(nb)) return -1;
    }
    if (a[1] && b[1]) {
        return a[1] > b[1] ? 1 : a[1] < b[1] ? -1 : 0;
    }
    return !a[1] && b[1] ? 1 : a[1] && !b[1] ? -1 : 0;
} //# sourceMappingURL=semver-compare.js.map
}),
"[project]/node_modules/libphonenumber-js/es6/helpers/isObject.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>isObject
]);
var objectConstructor = {}.constructor;
function isObject(object) {
    return object !== undefined && object !== null && object.constructor === objectConstructor;
} //# sourceMappingURL=isObject.js.map
}),
"[project]/node_modules/libphonenumber-js/es6/metadata.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>Metadata,
    "getCountryCallingCode",
    ()=>getCountryCallingCode,
    "getExtPrefix",
    ()=>getExtPrefix,
    "isSupportedCountry",
    ()=>isSupportedCountry,
    "validateMetadata",
    ()=>validateMetadata
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$tools$2f$semver$2d$compare$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/libphonenumber-js/es6/tools/semver-compare.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$helpers$2f$isObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/libphonenumber-js/es6/helpers/isObject.js [app-client] (ecmascript)");
function _readOnlyError(r) {
    throw new TypeError('"' + r + '" is read-only');
}
function _typeof(o) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o) {
        return typeof o;
    } : function(o) {
        return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    }, _typeof(o);
}
function _classCallCheck(a, n) {
    if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(e, r) {
    for(var t = 0; t < r.length; t++){
        var o = r[t];
        o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);
    }
}
function _createClass(e, r, t) {
    return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
        writable: !1
    }), e;
}
function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return "symbol" == _typeof(i) ? i : i + "";
}
function _toPrimitive(t, r) {
    if ("object" != _typeof(t) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
;
;
// Added "possibleLengths" and renamed
// "country_phone_code_to_countries" to "country_calling_codes".
var V2 = '1.0.18';
// Added "idd_prefix" and "default_idd_prefix".
var V3 = '1.2.0';
// Moved `001` country code to "nonGeographic" section of metadata.
var V4 = '1.7.35';
var DEFAULT_EXT_PREFIX = ' ext. ';
var CALLING_CODE_REG_EXP = /^\d+$/;
/**
 * See: https://gitlab.com/catamphetamine/libphonenumber-js/blob/master/METADATA.md
 */ var Metadata = /*#__PURE__*/ function() {
    function Metadata(metadata) {
        _classCallCheck(this, Metadata);
        validateMetadata(metadata);
        this.metadata = metadata;
        setVersion.call(this, metadata);
    }
    return _createClass(Metadata, [
        {
            key: "getCountries",
            value: function getCountries() {
                return Object.keys(this.metadata.countries).filter(function(_) {
                    return _ !== '001';
                });
            }
        },
        {
            key: "getCountryMetadata",
            value: function getCountryMetadata(countryCode) {
                return this.metadata.countries[countryCode];
            }
        },
        {
            key: "nonGeographic",
            value: function nonGeographic() {
                if (this.v1 || this.v2 || this.v3) return;
                // `nonGeographical` was a typo.
                // It's present in metadata generated from `1.7.35` to `1.7.37`.
                // The test case could be found by searching for "nonGeographical".
                return this.metadata.nonGeographic || this.metadata.nonGeographical;
            }
        },
        {
            key: "hasCountry",
            value: function hasCountry(country) {
                return this.getCountryMetadata(country) !== undefined;
            }
        },
        {
            key: "hasCallingCode",
            value: function hasCallingCode(callingCode) {
                if (this.getCountryCodesForCallingCode(callingCode)) {
                    return true;
                }
                if (this.nonGeographic()) {
                    if (this.nonGeographic()[callingCode]) {
                        return true;
                    }
                } else {
                    // A hacky workaround for old custom metadata (generated before V4).
                    var countryCodes = this.countryCallingCodes()[callingCode];
                    if (countryCodes && countryCodes.length === 1 && countryCodes[0] === '001') {
                        return true;
                    }
                }
            }
        },
        {
            key: "isNonGeographicCallingCode",
            value: function isNonGeographicCallingCode(callingCode) {
                if (this.nonGeographic()) {
                    return this.nonGeographic()[callingCode] ? true : false;
                } else {
                    return this.getCountryCodesForCallingCode(callingCode) ? false : true;
                }
            }
        },
        {
            key: "country",
            value: function country(countryCode) {
                return this.selectNumberingPlan(countryCode);
            }
        },
        {
            key: "selectNumberingPlan",
            value: function selectNumberingPlan(countryCode, callingCode) {
                // Supports just passing `callingCode` as the first argument.
                if (countryCode && CALLING_CODE_REG_EXP.test(countryCode)) {
                    callingCode = countryCode;
                    countryCode = null;
                }
                if (countryCode && countryCode !== '001') {
                    if (!this.hasCountry(countryCode)) {
                        throw new Error("Unknown country: ".concat(countryCode));
                    }
                    this.numberingPlan = new NumberingPlan(this.getCountryMetadata(countryCode), this);
                } else if (callingCode) {
                    if (!this.hasCallingCode(callingCode)) {
                        throw new Error("Unknown calling code: ".concat(callingCode));
                    }
                    this.numberingPlan = new NumberingPlan(this.getNumberingPlanMetadata(callingCode), this);
                } else {
                    this.numberingPlan = undefined;
                }
                return this;
            }
        },
        {
            key: "getCountryCodesForCallingCode",
            value: function getCountryCodesForCallingCode(callingCode) {
                var countryCodes = this.countryCallingCodes()[callingCode];
                if (countryCodes) {
                    // Metadata before V4 included "non-geographic entity" calling codes
                    // inside `country_calling_codes` (for example, `"881":["001"]`).
                    // Now the semantics of `country_calling_codes` has changed:
                    // it's specifically for "countries" now.
                    // Older versions of custom metadata will simply skip parsing
                    // "non-geographic entity" phone numbers with new versions
                    // of this library: it's not considered a bug,
                    // because such numbers are extremely rare,
                    // and developers extremely rarely use custom metadata.
                    if (countryCodes.length === 1 && countryCodes[0].length === 3) {
                        return;
                    }
                    return countryCodes;
                }
            }
        },
        {
            key: "getCountryCodeForCallingCode",
            value: function getCountryCodeForCallingCode(callingCode) {
                var countryCodes = this.getCountryCodesForCallingCode(callingCode);
                if (countryCodes) {
                    return countryCodes[0];
                }
            }
        },
        {
            key: "getNumberingPlanMetadata",
            value: function getNumberingPlanMetadata(callingCode) {
                var countryCode = this.getCountryCodeForCallingCode(callingCode);
                if (countryCode) {
                    return this.getCountryMetadata(countryCode);
                }
                if (this.nonGeographic()) {
                    var metadata = this.nonGeographic()[callingCode];
                    if (metadata) {
                        return metadata;
                    }
                } else {
                    // A hacky workaround for old custom metadata (generated before V4).
                    // In that metadata, there was no concept of "non-geographic" metadata
                    // so metadata for `001` country code was stored along with other countries.
                    // The test case can be found by searching for:
                    // "should work around `nonGeographic` metadata not existing".
                    var countryCodes = this.countryCallingCodes()[callingCode];
                    if (countryCodes && countryCodes.length === 1 && countryCodes[0] === '001') {
                        return this.metadata.countries['001'];
                    }
                }
            }
        },
        {
            key: "countryCallingCode",
            value: function countryCallingCode() {
                return this.numberingPlan.callingCode();
            }
        },
        {
            key: "IDDPrefix",
            value: function IDDPrefix() {
                return this.numberingPlan.IDDPrefix();
            }
        },
        {
            key: "defaultIDDPrefix",
            value: function defaultIDDPrefix() {
                return this.numberingPlan.defaultIDDPrefix();
            }
        },
        {
            key: "nationalNumberPattern",
            value: function nationalNumberPattern() {
                return this.numberingPlan.nationalNumberPattern();
            }
        },
        {
            key: "possibleLengths",
            value: function possibleLengths() {
                return this.numberingPlan.possibleLengths();
            }
        },
        {
            key: "formats",
            value: function formats() {
                return this.numberingPlan.formats();
            }
        },
        {
            key: "nationalPrefixForParsing",
            value: function nationalPrefixForParsing() {
                return this.numberingPlan.nationalPrefixForParsing();
            }
        },
        {
            key: "nationalPrefixTransformRule",
            value: function nationalPrefixTransformRule() {
                return this.numberingPlan.nationalPrefixTransformRule();
            }
        },
        {
            key: "leadingDigits",
            value: function leadingDigits() {
                return this.numberingPlan.leadingDigits();
            }
        },
        {
            key: "hasTypes",
            value: function hasTypes() {
                return this.numberingPlan.hasTypes();
            }
        },
        {
            key: "type",
            value: function type(_type) {
                return this.numberingPlan.type(_type);
            }
        },
        {
            key: "ext",
            value: function ext() {
                return this.numberingPlan.ext();
            }
        },
        {
            key: "countryCallingCodes",
            value: function countryCallingCodes() {
                if (this.v1) return this.metadata.country_phone_code_to_countries;
                return this.metadata.country_calling_codes;
            }
        },
        {
            key: "chooseCountryByCountryCallingCode",
            value: function chooseCountryByCountryCallingCode(callingCode) {
                return this.selectNumberingPlan(callingCode);
            }
        },
        {
            key: "hasSelectedNumberingPlan",
            value: function hasSelectedNumberingPlan() {
                return this.numberingPlan !== undefined;
            }
        }
    ]);
}();
;
var NumberingPlan = /*#__PURE__*/ function() {
    function NumberingPlan(metadata, globalMetadataObject) {
        _classCallCheck(this, NumberingPlan);
        this.globalMetadataObject = globalMetadataObject;
        this.metadata = metadata;
        setVersion.call(this, globalMetadataObject.metadata);
    }
    return _createClass(NumberingPlan, [
        {
            key: "callingCode",
            value: function callingCode() {
                return this.metadata[0];
            }
        },
        {
            key: "getDefaultCountryMetadataForRegion",
            value: function getDefaultCountryMetadataForRegion() {
                return this.globalMetadataObject.getNumberingPlanMetadata(this.callingCode());
            }
        },
        {
            key: "IDDPrefix",
            value: function IDDPrefix() {
                if (this.v1 || this.v2) return;
                return this.metadata[1];
            }
        },
        {
            key: "defaultIDDPrefix",
            value: function defaultIDDPrefix() {
                if (this.v1 || this.v2) return;
                return this.metadata[12];
            }
        },
        {
            key: "nationalNumberPattern",
            value: function nationalNumberPattern() {
                if (this.v1 || this.v2) return this.metadata[1];
                return this.metadata[2];
            }
        },
        {
            key: "possibleLengths",
            value: function possibleLengths() {
                if (this.v1) return;
                return this.metadata[this.v2 ? 2 : 3];
            }
        },
        {
            key: "_getFormats",
            value: function _getFormats(metadata) {
                return metadata[this.v1 ? 2 : this.v2 ? 3 : 4];
            }
        },
        {
            key: "formats",
            value: function formats() {
                var _this = this;
                var formats = this._getFormats(this.metadata) || this._getFormats(this.getDefaultCountryMetadataForRegion()) || [];
                return formats.map(function(_) {
                    return new Format(_, _this);
                });
            }
        },
        {
            key: "nationalPrefix",
            value: function nationalPrefix() {
                return this.metadata[this.v1 ? 3 : this.v2 ? 4 : 5];
            }
        },
        {
            key: "_getNationalPrefixFormattingRule",
            value: function _getNationalPrefixFormattingRule(metadata) {
                return metadata[this.v1 ? 4 : this.v2 ? 5 : 6];
            }
        },
        {
            key: "nationalPrefixFormattingRule",
            value: function nationalPrefixFormattingRule() {
                return this._getNationalPrefixFormattingRule(this.metadata) || this._getNationalPrefixFormattingRule(this.getDefaultCountryMetadataForRegion());
            }
        },
        {
            key: "_nationalPrefixForParsing",
            value: function _nationalPrefixForParsing() {
                return this.metadata[this.v1 ? 5 : this.v2 ? 6 : 7];
            }
        },
        {
            key: "nationalPrefixForParsing",
            value: function nationalPrefixForParsing() {
                // If `national_prefix_for_parsing` is not set explicitly,
                // then infer it from `national_prefix` (if any)
                return this._nationalPrefixForParsing() || this.nationalPrefix();
            }
        },
        {
            key: "nationalPrefixTransformRule",
            value: function nationalPrefixTransformRule() {
                return this.metadata[this.v1 ? 6 : this.v2 ? 7 : 8];
            }
        },
        {
            key: "_getNationalPrefixIsOptionalWhenFormatting",
            value: function _getNationalPrefixIsOptionalWhenFormatting() {
                return !!this.metadata[this.v1 ? 7 : this.v2 ? 8 : 9];
            }
        },
        {
            key: "nationalPrefixIsOptionalWhenFormattingInNationalFormat",
            value: function nationalPrefixIsOptionalWhenFormattingInNationalFormat() {
                return this._getNationalPrefixIsOptionalWhenFormatting(this.metadata) || this._getNationalPrefixIsOptionalWhenFormatting(this.getDefaultCountryMetadataForRegion());
            }
        },
        {
            key: "leadingDigits",
            value: function leadingDigits() {
                return this.metadata[this.v1 ? 8 : this.v2 ? 9 : 10];
            }
        },
        {
            key: "types",
            value: function types() {
                return this.metadata[this.v1 ? 9 : this.v2 ? 10 : 11];
            }
        },
        {
            key: "hasTypes",
            value: function hasTypes() {
                // Versions 1.2.0 - 1.2.4: can be `[]`.
                /* istanbul ignore next */ if (this.types() && this.types().length === 0) {
                    return false;
                }
                // Versions <= 1.2.4: can be `undefined`.
                // Version >= 1.2.5: can be `0`.
                return !!this.types();
            }
        },
        {
            key: "type",
            value: function type(_type2) {
                if (this.hasTypes() && getType(this.types(), _type2)) {
                    return new Type(getType(this.types(), _type2), this);
                }
            }
        },
        {
            key: "ext",
            value: function ext() {
                if (this.v1 || this.v2) return DEFAULT_EXT_PREFIX;
                return this.metadata[13] || DEFAULT_EXT_PREFIX;
            }
        }
    ]);
}();
var Format = /*#__PURE__*/ function() {
    function Format(format, metadata) {
        _classCallCheck(this, Format);
        this._format = format;
        this.metadata = metadata;
    }
    return _createClass(Format, [
        {
            key: "pattern",
            value: function pattern() {
                return this._format[0];
            }
        },
        {
            key: "format",
            value: function format() {
                return this._format[1];
            }
        },
        {
            key: "leadingDigitsPatterns",
            value: function leadingDigitsPatterns() {
                return this._format[2] || [];
            }
        },
        {
            key: "nationalPrefixFormattingRule",
            value: function nationalPrefixFormattingRule() {
                return this._format[3] || this.metadata.nationalPrefixFormattingRule();
            }
        },
        {
            key: "nationalPrefixIsOptionalWhenFormattingInNationalFormat",
            value: function nationalPrefixIsOptionalWhenFormattingInNationalFormat() {
                return !!this._format[4] || this.metadata.nationalPrefixIsOptionalWhenFormattingInNationalFormat();
            }
        },
        {
            key: "nationalPrefixIsMandatoryWhenFormattingInNationalFormat",
            value: function nationalPrefixIsMandatoryWhenFormattingInNationalFormat() {
                // National prefix is omitted if there's no national prefix formatting rule
                // set for this country, or when the national prefix formatting rule
                // contains no national prefix itself, or when this rule is set but
                // national prefix is optional for this phone number format
                // (and it is not enforced explicitly)
                return this.usesNationalPrefix() && !this.nationalPrefixIsOptionalWhenFormattingInNationalFormat();
            }
        },
        {
            key: "usesNationalPrefix",
            value: function usesNationalPrefix() {
                return this.nationalPrefixFormattingRule() && // Check that national prefix formatting rule is not a "dummy" one.
                !FIRST_GROUP_ONLY_PREFIX_PATTERN.test(this.nationalPrefixFormattingRule()) ? true : false;
            }
        },
        {
            key: "internationalFormat",
            value: function internationalFormat() {
                return this._format[5] || this.format();
            }
        }
    ]);
}();
/**
 * A pattern that is used to determine if the national prefix formatting rule
 * has the first group only, i.e., does not start with the national prefix.
 * Note that the pattern explicitly allows for unbalanced parentheses.
 */ var FIRST_GROUP_ONLY_PREFIX_PATTERN = /^\(?\$1\)?$/;
var Type = /*#__PURE__*/ function() {
    function Type(type, metadata) {
        _classCallCheck(this, Type);
        this.type = type;
        this.metadata = metadata;
    }
    return _createClass(Type, [
        {
            key: "pattern",
            value: function pattern() {
                if (this.metadata.v1) return this.type;
                return this.type[0];
            }
        },
        {
            key: "possibleLengths",
            value: function possibleLengths() {
                if (this.metadata.v1) return;
                return this.type[1] || this.metadata.possibleLengths();
            }
        }
    ]);
}();
function getType(types, type) {
    switch(type){
        case 'FIXED_LINE':
            return types[0];
        case 'MOBILE':
            return types[1];
        case 'TOLL_FREE':
            return types[2];
        case 'PREMIUM_RATE':
            return types[3];
        case 'PERSONAL_NUMBER':
            return types[4];
        case 'VOICEMAIL':
            return types[5];
        case 'UAN':
            return types[6];
        case 'PAGER':
            return types[7];
        case 'VOIP':
            return types[8];
        case 'SHARED_COST':
            return types[9];
    }
}
function validateMetadata(metadata) {
    if (!metadata) {
        throw new Error('[libphonenumber-js] `metadata` argument not passed. Check your arguments.');
    }
    // `country_phone_code_to_countries` was renamed to `country_calling_codes` in `1.0.18`.
    // For that reason, it's not used in this detection algorithm.
    // Instead, it detects by `countries: {}` property existence.
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$helpers$2f$isObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(metadata) || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$helpers$2f$isObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(metadata.countries)) {
        throw new Error("[libphonenumber-js] `metadata` argument was passed but it's not a valid metadata. Must be an object having `.countries` child object property. Got ".concat((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$helpers$2f$isObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(metadata) ? 'an object of shape: { ' + Object.keys(metadata).join(', ') + ' }' : 'a ' + typeOf(metadata) + ': ' + metadata, "."));
    }
}
// Babel transforms `typeof` into some "branches"
// so istanbul will show this as "branch not covered".
/* istanbul ignore next */ var typeOf = function typeOf(_) {
    return _typeof(_);
};
function getExtPrefix(country, metadata) {
    metadata = new Metadata(metadata);
    if (metadata.hasCountry(country)) {
        return metadata.selectNumberingPlan(country).ext();
    }
    return DEFAULT_EXT_PREFIX;
}
function getCountryCallingCode(country, metadata) {
    metadata = new Metadata(metadata);
    if (metadata.hasCountry(country)) {
        return metadata.selectNumberingPlan(country).countryCallingCode();
    }
    throw new Error("Unknown country: ".concat(country));
}
function isSupportedCountry(country, metadata) {
    // metadata = new Metadata(metadata)
    // return metadata.hasCountry(country)
    return metadata.countries.hasOwnProperty(country);
}
function setVersion(metadata) {
    var version = metadata.version;
    if (typeof version === 'number') {
        this.v1 = version === 1;
        this.v2 = version === 2;
        this.v3 = version === 3;
        this.v4 = version === 4;
    } else {
        if (!version) {
            this.v1 = true;
        } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$tools$2f$semver$2d$compare$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(version, V3) === -1) {
            this.v2 = true;
        } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$tools$2f$semver$2d$compare$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(version, V4) === -1) {
            this.v3 = true;
        } else {
            this.v4 = true;
        }
    }
} // const ISO_COUNTRY_CODE = /^[A-Z]{2}$/
 // function isCountryCode(countryCode) {
 // 	return ISO_COUNTRY_CODE.test(countryCodeOrCountryCallingCode)
 // }
 //# sourceMappingURL=metadata.js.map
}),
"[project]/node_modules/libphonenumber-js/es6/helpers/mergeArrays.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>mergeArrays
]);
function _createForOfIteratorHelperLoose(r, e) {
    var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
    if (t) return (t = t.call(r)).next.bind(t);
    if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) {
        t && (r = t);
        var o = 0;
        return function() {
            return o >= r.length ? {
                done: !0
            } : {
                done: !1,
                value: r[o++]
            };
        };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(r, a) {
    if (r) {
        if ("string" == typeof r) return _arrayLikeToArray(r, a);
        var t = ({}).toString.call(r).slice(8, -1);
        return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
    }
}
function _arrayLikeToArray(r, a) {
    (null == a || a > r.length) && (a = r.length);
    for(var e = 0, n = Array(a); e < a; e++)n[e] = r[e];
    return n;
}
function mergeArrays(a, b) {
    var merged = a.slice();
    for(var _iterator = _createForOfIteratorHelperLoose(b), _step; !(_step = _iterator()).done;){
        var element = _step.value;
        if (a.indexOf(element) < 0) {
            merged.push(element);
        }
    }
    return merged.sort(function(a, b) {
        return a - b;
    });
// ES6 version, requires Set polyfill.
// let merged = new Set(a)
// for (const element of b) {
// 	merged.add(i)
// }
// return Array.from(merged).sort((a, b) => a - b)
} //# sourceMappingURL=mergeArrays.js.map
}),
"[project]/node_modules/libphonenumber-js/es6/helpers/checkNumberLength.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "checkNumberLengthForType",
    ()=>checkNumberLengthForType,
    "default",
    ()=>checkNumberLength
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$metadata$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/libphonenumber-js/es6/metadata.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$helpers$2f$mergeArrays$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/libphonenumber-js/es6/helpers/mergeArrays.js [app-client] (ecmascript)");
;
;
function checkNumberLength(nationalNumber, country, metadata) {
    return checkNumberLengthForType(nationalNumber, country, undefined, metadata);
}
function checkNumberLengthForType(nationalNumber, country, type, metadata) {
    // If the exact `country` is specified, it's no necessarily already selected in `metadata`.
    // Most likely, in cases when there're multiple countries corresponding to the same
    // "country calling code", the "main" country for that "country calling code" will be selected.
    if (country) {
        metadata = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$metadata$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](metadata.metadata);
        metadata.selectNumberingPlan(country);
    }
    var type_info = metadata.type(type);
    // There should always be "<possiblePengths/>" set for every type element.
    // This is declared in the XML schema.
    // For size efficiency, where a sub-description (e.g. fixed-line)
    // has the same "<possiblePengths/>" as the "general description", this is missing,
    // so we fall back to the "general description". Where no numbers of the type
    // exist at all, there is one possible length (-1) which is guaranteed
    // not to match the length of any real phone number.
    var possible_lengths = type_info && type_info.possibleLengths() || metadata.possibleLengths();
    // let local_lengths = type_info && type.possibleLengthsLocal() || metadata.possibleLengthsLocal()
    // Metadata before version `1.0.18` didn't contain `possible_lengths`.
    if (!possible_lengths) {
        return 'IS_POSSIBLE';
    }
    if (type === 'FIXED_LINE_OR_MOBILE') {
        // No such country in metadata.
        /* istanbul ignore next */ if (!metadata.type('FIXED_LINE')) {
            // The rare case has been encountered where no fixedLine data is available
            // (true for some non-geographic entities), so we just check mobile.
            return checkNumberLengthForType(nationalNumber, country, 'MOBILE', metadata);
        }
        var mobile_type = metadata.type('MOBILE');
        if (mobile_type) {
            // Merge the mobile data in if there was any. "Concat" creates a new
            // array, it doesn't edit possible_lengths in place, so we don't need a copy.
            // Note that when adding the possible lengths from mobile, we have
            // to again check they aren't empty since if they are this indicates
            // they are the same as the general desc and should be obtained from there.
            possible_lengths = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$helpers$2f$mergeArrays$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(possible_lengths, mobile_type.possibleLengths());
        // The current list is sorted; we need to merge in the new list and
        // re-sort (duplicates are okay). Sorting isn't so expensive because
        // the lists are very small.
        // if (local_lengths) {
        // 	local_lengths = mergeArrays(local_lengths, mobile_type.possibleLengthsLocal())
        // } else {
        // 	local_lengths = mobile_type.possibleLengthsLocal()
        // }
        }
    } else if (type && !type_info) {
        return 'INVALID_LENGTH';
    }
    var actual_length = nationalNumber.length;
    // In `libphonenumber-js` all "local-only" formats are dropped for simplicity.
    // // This is safe because there is never an overlap beween the possible lengths
    // // and the local-only lengths; this is checked at build time.
    // if (local_lengths && local_lengths.indexOf(nationalNumber.length) >= 0)
    // {
    // 	return 'IS_POSSIBLE_LOCAL_ONLY'
    // }
    var minimum_length = possible_lengths[0];
    if (minimum_length === actual_length) {
        return 'IS_POSSIBLE';
    }
    if (minimum_length > actual_length) {
        return 'TOO_SHORT';
    }
    if (possible_lengths[possible_lengths.length - 1] < actual_length) {
        return 'TOO_LONG';
    }
    // We skip the first element since we've already checked it.
    return possible_lengths.indexOf(actual_length, 1) >= 0 ? 'IS_POSSIBLE' : 'INVALID_LENGTH';
} //# sourceMappingURL=checkNumberLength.js.map
}),
"[project]/node_modules/libphonenumber-js/es6/isPossible.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>isPossiblePhoneNumber,
    "isPossibleNumber",
    ()=>isPossibleNumber
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$metadata$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/libphonenumber-js/es6/metadata.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$helpers$2f$checkNumberLength$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/libphonenumber-js/es6/helpers/checkNumberLength.js [app-client] (ecmascript)");
;
;
function isPossiblePhoneNumber(input, options, metadata) {
    /* istanbul ignore if */ if (options === undefined) {
        options = {};
    }
    metadata = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$metadata$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](metadata);
    if (options.v2) {
        if (!input.countryCallingCode) {
            throw new Error('Invalid phone number object passed');
        }
        metadata.selectNumberingPlan(input.countryCallingCode);
    } else {
        if (!input.phone) {
            return false;
        }
        if (input.country) {
            if (!metadata.hasCountry(input.country)) {
                throw new Error("Unknown country: ".concat(input.country));
            }
            metadata.selectNumberingPlan(input.country);
        } else {
            if (!input.countryCallingCode) {
                throw new Error('Invalid phone number object passed');
            }
            metadata.selectNumberingPlan(input.countryCallingCode);
        }
    }
    // Old metadata (< 1.0.18) had no "possible length" data.
    if (metadata.possibleLengths()) {
        return isPossibleNumber(input.phone || input.nationalNumber, input.country, metadata);
    } else {
        // There was a bug between `1.7.35` and `1.7.37` where "possible_lengths"
        // were missing for "non-geographical" numbering plans.
        // Just assume the number is possible in such cases:
        // it's unlikely that anyone generated their custom metadata
        // in that short period of time (one day).
        // This code can be removed in some future major version update.
        if (input.countryCallingCode && metadata.isNonGeographicCallingCode(input.countryCallingCode)) {
            // "Non-geographic entities" did't have `possibleLengths`
            // due to a bug in metadata generation process.
            return true;
        } else {
            throw new Error('Missing "possibleLengths" in metadata. Perhaps the metadata has been generated before v1.0.18.');
        }
    }
}
function isPossibleNumber(nationalNumber, country, metadata) {
    //, isInternational) {
    switch((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$helpers$2f$checkNumberLength$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(nationalNumber, country, metadata)){
        case 'IS_POSSIBLE':
            return true;
        // This library ignores "local-only" phone numbers (for simplicity).
        // See the readme for more info on what are "local-only" phone numbers.
        // case 'IS_POSSIBLE_LOCAL_ONLY':
        // 	return !isInternational
        default:
            return false;
    }
} //# sourceMappingURL=isPossible.js.map
}),
"[project]/node_modules/libphonenumber-js/es6/helpers/matchesEntirely.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Checks whether the entire input sequence can be matched
 * against the regular expression.
 * @return {boolean}
 */ __turbopack_context__.s([
    "default",
    ()=>matchesEntirely
]);
function matchesEntirely(text, regularExpressionText) {
    // If the assigning of the `''` default value is moved to the arguments above,
    // the code coverage would decrease for some weird reason.
    text = text || '';
    return new RegExp('^(?:' + regularExpressionText + ')$').test(text);
} //# sourceMappingURL=matchesEntirely.js.map
}),
"[project]/node_modules/libphonenumber-js/es6/helpers/getNumberType.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>getNumberType,
    "isNumberTypeEqualTo",
    ()=>isNumberTypeEqualTo
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$metadata$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/libphonenumber-js/es6/metadata.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$helpers$2f$matchesEntirely$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/libphonenumber-js/es6/helpers/matchesEntirely.js [app-client] (ecmascript)");
function _createForOfIteratorHelperLoose(r, e) {
    var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
    if (t) return (t = t.call(r)).next.bind(t);
    if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) {
        t && (r = t);
        var o = 0;
        return function() {
            return o >= r.length ? {
                done: !0
            } : {
                done: !1,
                value: r[o++]
            };
        };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(r, a) {
    if (r) {
        if ("string" == typeof r) return _arrayLikeToArray(r, a);
        var t = ({}).toString.call(r).slice(8, -1);
        return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
    }
}
function _arrayLikeToArray(r, a) {
    (null == a || a > r.length) && (a = r.length);
    for(var e = 0, n = Array(a); e < a; e++)n[e] = r[e];
    return n;
}
;
;
var NON_FIXED_LINE_PHONE_TYPES = [
    'MOBILE',
    'PREMIUM_RATE',
    'TOLL_FREE',
    'SHARED_COST',
    'VOIP',
    'PERSONAL_NUMBER',
    'PAGER',
    'UAN',
    'VOICEMAIL'
];
function getNumberType(input, options, metadata) {
    // If assigning the `{}` default value is moved to the arguments above,
    // code coverage would decrease for some weird reason.
    options = options || {};
    // When `parse()` returns an empty object  `{}` 
    // that means that the phone number is malformed,
    // so it can't possibly be valid.
    if (!input.country && !input.countryCallingCode) {
        return;
    }
    metadata = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$metadata$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](metadata);
    metadata.selectNumberingPlan(input.country, input.countryCallingCode);
    var nationalNumber = options.v2 ? input.nationalNumber : input.phone;
    // The following is copy-pasted from the original function:
    // https://github.com/googlei18n/libphonenumber/blob/3ea547d4fbaa2d0b67588904dfa5d3f2557c27ff/javascript/i18n/phonenumbers/phonenumberutil.js#L2835
    // Is this national number even valid for this country
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$helpers$2f$matchesEntirely$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(nationalNumber, metadata.nationalNumberPattern())) {
        return;
    }
    // Is it fixed line number
    if (isNumberTypeEqualTo(nationalNumber, 'FIXED_LINE', metadata)) {
        // Because duplicate regular expressions are removed
        // to reduce metadata size, if "mobile" pattern is ""
        // then it means it was removed due to being a duplicate of the fixed-line pattern.
        //
        if (metadata.type('MOBILE') && metadata.type('MOBILE').pattern() === '') {
            return 'FIXED_LINE_OR_MOBILE';
        }
        // `MOBILE` type pattern isn't included if it matched `FIXED_LINE` one.
        // For example, for "US" country.
        // Old metadata (< `1.0.18`) had a specific "types" data structure
        // that happened to be `undefined` for `MOBILE` in that case.
        // Newer metadata (>= `1.0.18`) has another data structure that is
        // not `undefined` for `MOBILE` in that case (it's just an empty array).
        // So this `if` is just for backwards compatibility with old metadata.
        if (!metadata.type('MOBILE')) {
            return 'FIXED_LINE_OR_MOBILE';
        }
        // Check if the number happens to qualify as both fixed line and mobile.
        // (no such country in the minimal metadata set)
        /* istanbul ignore if */ if (isNumberTypeEqualTo(nationalNumber, 'MOBILE', metadata)) {
            return 'FIXED_LINE_OR_MOBILE';
        }
        return 'FIXED_LINE';
    }
    for(var _iterator = _createForOfIteratorHelperLoose(NON_FIXED_LINE_PHONE_TYPES), _step; !(_step = _iterator()).done;){
        var type = _step.value;
        if (isNumberTypeEqualTo(nationalNumber, type, metadata)) {
            return type;
        }
    }
}
function isNumberTypeEqualTo(nationalNumber, type, metadata) {
    type = metadata.type(type);
    if (!type || !type.pattern()) {
        return false;
    }
    // Check if any possible number lengths are present;
    // if so, we use them to avoid checking
    // the validation pattern if they don't match.
    // If they are absent, this means they match
    // the general description, which we have
    // already checked before a specific number type.
    if (type.possibleLengths() && type.possibleLengths().indexOf(nationalNumber.length) < 0) {
        return false;
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$helpers$2f$matchesEntirely$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(nationalNumber, type.pattern());
} //# sourceMappingURL=getNumberType.js.map
}),
"[project]/node_modules/libphonenumber-js/es6/isValid.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>isValidNumber
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$metadata$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/libphonenumber-js/es6/metadata.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$helpers$2f$matchesEntirely$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/libphonenumber-js/es6/helpers/matchesEntirely.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$helpers$2f$getNumberType$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/libphonenumber-js/es6/helpers/getNumberType.js [app-client] (ecmascript)");
;
;
;
function isValidNumber(input, options, metadata) {
    // If assigning the `{}` default value is moved to the arguments above,
    // code coverage would decrease for some weird reason.
    options = options || {};
    metadata = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$metadata$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](metadata);
    metadata.selectNumberingPlan(input.country, input.countryCallingCode);
    // By default, countries only have type regexps when it's required for
    // distinguishing different countries having the same `countryCallingCode`.
    if (metadata.hasTypes()) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$helpers$2f$getNumberType$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(input, options, metadata.metadata) !== undefined;
    }
    // If there are no type regexps for this country in metadata then use
    // `nationalNumberPattern` as a "better than nothing" replacement.
    var nationalNumber = options.v2 ? input.nationalNumber : input.phone;
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$helpers$2f$matchesEntirely$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(nationalNumber, metadata.nationalNumberPattern());
} //# sourceMappingURL=isValid.js.map
}),
"[project]/node_modules/libphonenumber-js/es6/helpers/getPossibleCountriesForNumber.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>getPossibleCountriesForNumber
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$metadata$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/libphonenumber-js/es6/metadata.js [app-client] (ecmascript)");
;
function getPossibleCountriesForNumber(callingCode, nationalNumber, metadata) {
    var _metadata = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$metadata$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](metadata);
    var possibleCountries = _metadata.getCountryCodesForCallingCode(callingCode);
    if (!possibleCountries) {
        return [];
    }
    return possibleCountries.filter(function(country) {
        return couldNationalNumberBelongToCountry(nationalNumber, country, metadata);
    });
}
function couldNationalNumberBelongToCountry(nationalNumber, country, metadata) {
    var _metadata = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$metadata$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](metadata);
    _metadata.selectNumberingPlan(country);
    if (_metadata.numberingPlan.possibleLengths().indexOf(nationalNumber.length) >= 0) {
        return true;
    }
    return false;
} //# sourceMappingURL=getPossibleCountriesForNumber.js.map
}),
"[project]/node_modules/libphonenumber-js/es6/constants.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// The minimum length of the national significant number.
__turbopack_context__.s([
    "MAX_LENGTH_COUNTRY_CODE",
    ()=>MAX_LENGTH_COUNTRY_CODE,
    "MAX_LENGTH_FOR_NSN",
    ()=>MAX_LENGTH_FOR_NSN,
    "MIN_LENGTH_FOR_NSN",
    ()=>MIN_LENGTH_FOR_NSN,
    "PLUS_CHARS",
    ()=>PLUS_CHARS,
    "VALID_DIGITS",
    ()=>VALID_DIGITS,
    "VALID_PUNCTUATION",
    ()=>VALID_PUNCTUATION,
    "WHITESPACE",
    ()=>WHITESPACE
]);
var MIN_LENGTH_FOR_NSN = 2;
var MAX_LENGTH_FOR_NSN = 17;
var MAX_LENGTH_COUNTRY_CODE = 3;
var VALID_DIGITS = "0-9\uFF10-\uFF19\u0660-\u0669\u06F0-\u06F9";
// `DASHES` will be right after the opening square bracket of the "character class"
var DASHES = "-\u2010-\u2015\u2212\u30FC\uFF0D";
var SLASHES = "\uFF0F/";
var DOTS = "\uFF0E.";
var WHITESPACE = " \xA0\xAD\u200B\u2060\u3000";
var BRACKETS = "()\uFF08\uFF09\uFF3B\uFF3D\\[\\]";
// export const OPENING_BRACKETS = '(\uFF08\uFF3B\\\['
var TILDES = "~\u2053\u223C\uFF5E";
var VALID_PUNCTUATION = "".concat(DASHES).concat(SLASHES).concat(DOTS).concat(WHITESPACE).concat(BRACKETS).concat(TILDES);
var PLUS_CHARS = "+\uFF0B"; // const LEADING_PLUS_CHARS_PATTERN = new RegExp('^[' + PLUS_CHARS + ']+')
 //# sourceMappingURL=constants.js.map
}),
"[project]/node_modules/libphonenumber-js/es6/helpers/stripIddPrefix.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>stripIddPrefix
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$metadata$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/libphonenumber-js/es6/metadata.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/libphonenumber-js/es6/constants.js [app-client] (ecmascript)");
;
;
var CAPTURING_DIGIT_PATTERN = new RegExp('([' + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VALID_DIGITS"] + '])');
function stripIddPrefix(number, country, callingCode, metadata) {
    if (!country) {
        return;
    }
    // Check if the number is IDD-prefixed.
    var countryMetadata = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$metadata$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](metadata);
    countryMetadata.selectNumberingPlan(country, callingCode);
    var IDDPrefixPattern = new RegExp(countryMetadata.IDDPrefix());
    if (number.search(IDDPrefixPattern) !== 0) {
        return;
    }
    // Strip IDD prefix.
    number = number.slice(number.match(IDDPrefixPattern)[0].length);
    // If there're any digits after an IDD prefix,
    // then those digits are a country calling code.
    // Since no country code starts with a `0`,
    // the code below validates that the next digit (if present) is not `0`.
    var matchedGroups = number.match(CAPTURING_DIGIT_PATTERN);
    if (matchedGroups && matchedGroups[1] != null && matchedGroups[1].length > 0) {
        if (matchedGroups[1] === '0') {
            return;
        }
    }
    return number;
} //# sourceMappingURL=stripIddPrefix.js.map
}),
"[project]/node_modules/libphonenumber-js/es6/helpers/extractNationalNumberFromPossiblyIncompleteNumber.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Strips any national prefix (such as 0, 1) present in a
 * (possibly incomplete) number provided.
 * "Carrier codes" are only used  in Colombia and Brazil,
 * and only when dialing within those countries from a mobile phone to a fixed line number.
 * Sometimes it won't actually strip national prefix
 * and will instead prepend some digits to the `number`:
 * for example, when number `2345678` is passed with `VI` country selected,
 * it will return `{ number: "3402345678" }`, because `340` area code is prepended.
 * @param {string} number  National number digits.
 * @param {object} metadata  Metadata with country selected.
 * @return {object} `{ nationalNumber: string, nationalPrefix: string? carrierCode: string? }`. Even if a national prefix was extracted, it's not necessarily present in the returned object, so don't rely on its presence in the returned object in order to find out whether a national prefix has been extracted or not.
 */ __turbopack_context__.s([
    "default",
    ()=>extractNationalNumberFromPossiblyIncompleteNumber
]);
function extractNationalNumberFromPossiblyIncompleteNumber(number, metadata) {
    if (number && metadata.numberingPlan.nationalPrefixForParsing()) {
        // See METADATA.md for the description of
        // `national_prefix_for_parsing` and `national_prefix_transform_rule`.
        // Attempt to parse the first digits as a national prefix.
        var prefixPattern = new RegExp('^(?:' + metadata.numberingPlan.nationalPrefixForParsing() + ')');
        var prefixMatch = prefixPattern.exec(number);
        if (prefixMatch) {
            var nationalNumber;
            var carrierCode;
            // https://gitlab.com/catamphetamine/libphonenumber-js/-/blob/master/METADATA.md#national_prefix_for_parsing--national_prefix_transform_rule
            // If a `national_prefix_for_parsing` has any "capturing groups"
            // then it means that the national (significant) number is equal to
            // those "capturing groups" transformed via `national_prefix_transform_rule`,
            // and nothing could be said about the actual national prefix:
            // what is it and was it even there.
            // If a `national_prefix_for_parsing` doesn't have any "capturing groups",
            // then everything it matches is a national prefix.
            // To determine whether `national_prefix_for_parsing` matched any
            // "capturing groups", the value of the result of calling `.exec()`
            // is looked at, and if it has non-undefined values where there're
            // "capturing groups" in the regular expression, then it means
            // that "capturing groups" have been matched.
            // It's not possible to tell whether there'll be any "capturing gropus"
            // before the matching process, because a `national_prefix_for_parsing`
            // could exhibit both behaviors.
            var capturedGroupsCount = prefixMatch.length - 1;
            var hasCapturedGroups = capturedGroupsCount > 0 && prefixMatch[capturedGroupsCount];
            if (metadata.nationalPrefixTransformRule() && hasCapturedGroups) {
                nationalNumber = number.replace(prefixPattern, metadata.nationalPrefixTransformRule());
                // If there's more than one captured group,
                // then carrier code is the second one.
                if (capturedGroupsCount > 1) {
                    carrierCode = prefixMatch[1];
                }
            } else {
                // `prefixBeforeNationalNumber` is the whole substring matched by
                // the `national_prefix_for_parsing` regular expression.
                // There seem to be no guarantees that it's just a national prefix.
                // For example, if there's a carrier code, it's gonna be a
                // part of `prefixBeforeNationalNumber` too.
                var prefixBeforeNationalNumber = prefixMatch[0];
                nationalNumber = number.slice(prefixBeforeNationalNumber.length);
                // If there's at least one captured group,
                // then carrier code is the first one.
                if (hasCapturedGroups) {
                    carrierCode = prefixMatch[1];
                }
            }
            // Tries to guess whether a national prefix was present in the input.
            // This is not something copy-pasted from Google's library:
            // they don't seem to have an equivalent for that.
            // So this isn't an "officially approved" way of doing something like that.
            // But since there seems no other existing method, this library uses it.
            var nationalPrefix;
            if (hasCapturedGroups) {
                var possiblePositionOfTheFirstCapturedGroup = number.indexOf(prefixMatch[1]);
                var possibleNationalPrefix = number.slice(0, possiblePositionOfTheFirstCapturedGroup);
                // Example: an Argentinian (AR) phone number `0111523456789`.
                // `prefixMatch[0]` is `01115`, and `$1` is `11`,
                // and the rest of the phone number is `23456789`.
                // The national number is transformed via `9$1` to `91123456789`.
                // National prefix `0` is detected being present at the start.
                // if (possibleNationalPrefix.indexOf(metadata.numberingPlan.nationalPrefix()) === 0) {
                if (possibleNationalPrefix === metadata.numberingPlan.nationalPrefix()) {
                    nationalPrefix = metadata.numberingPlan.nationalPrefix();
                }
            } else {
                nationalPrefix = prefixMatch[0];
            }
            return {
                nationalNumber: nationalNumber,
                nationalPrefix: nationalPrefix,
                carrierCode: carrierCode
            };
        }
    }
    return {
        nationalNumber: number
    };
} //# sourceMappingURL=extractNationalNumberFromPossiblyIncompleteNumber.js.map
}),
"[project]/node_modules/libphonenumber-js/es6/helpers/getCountryByNationalNumber.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>getCountryByNationalNumber
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$metadata$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/libphonenumber-js/es6/metadata.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$helpers$2f$getNumberType$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/libphonenumber-js/es6/helpers/getNumberType.js [app-client] (ecmascript)");
function _createForOfIteratorHelperLoose(r, e) {
    var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
    if (t) return (t = t.call(r)).next.bind(t);
    if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) {
        t && (r = t);
        var o = 0;
        return function() {
            return o >= r.length ? {
                done: !0
            } : {
                done: !1,
                value: r[o++]
            };
        };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(r, a) {
    if (r) {
        if ("string" == typeof r) return _arrayLikeToArray(r, a);
        var t = ({}).toString.call(r).slice(8, -1);
        return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
    }
}
function _arrayLikeToArray(r, a) {
    (null == a || a > r.length) && (a = r.length);
    for(var e = 0, n = Array(a); e < a; e++)n[e] = r[e];
    return n;
}
;
;
function getCountryByNationalNumber(nationalPhoneNumber, _ref) {
    var countries = _ref.countries, metadata = _ref.metadata;
    // Re-create `metadata` because it will be selecting a `country`.
    metadata = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$metadata$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](metadata);
    // const matchingCountries = []
    for(var _iterator = _createForOfIteratorHelperLoose(countries), _step; !(_step = _iterator()).done;){
        var country = _step.value;
        metadata.selectNumberingPlan(country);
        // "Leading digits" patterns are only defined for about 20% of all countries.
        // By definition, matching "leading digits" is a sufficient but not a necessary
        // condition for a phone number to belong to a country.
        // The point of "leading digits" check is that it's the fastest one to get a match.
        // https://gitlab.com/catamphetamine/libphonenumber-js/blob/master/METADATA.md#leading_digits
        // I'd suppose that "leading digits" patterns are mutually exclusive for different countries
        // because of the intended use of that feature.
        if (metadata.leadingDigits()) {
            if (nationalPhoneNumber && nationalPhoneNumber.search(metadata.leadingDigits()) === 0) {
                return country;
            }
        } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$helpers$2f$getNumberType$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])({
            phone: nationalPhoneNumber,
            country: country
        }, undefined, metadata.metadata)) {
            // When multiple countries share the same "country calling code",
            // type patterns aren't guaranteed to be unique among them.
            // For example, both `US` and `CA` have the same pattern for `toll_free` numbers.
            // https://gitlab.com/catamphetamine/libphonenumber-js/-/issues/103#note_1417147572
            //
            // That means that this `if` condition could be `true` for multiple countries from the list.
            // Currently, it just returns the first one, which is also the "main" country for the "country calling code".
            // In an example with `toll_free` numbers above, `"US"` would be returned even though
            // it could as well be `"CA"`.
            //
            // There was also a time when this attempted to be overly smart
            // and kept track of all such multiple matching countries
            // and then picked the one that matched the `defaultCountry`, if provided.
            // For example, with `toll_free` numbers above, and with `defaultCountry: "CA"`,
            // it would've returned `"CA"` instead of `"US"`.
            // Later it turned out that such "overly smart" behavior turned out to be just confusing,
            // so this "overly smart" country detection was reverted to returning the "main" country
            // for the "country calling code".
            // https://gitlab.com/catamphetamine/libphonenumber-js/-/issues/154
            //
            return country;
        //
        // The "overly smart" behavior code:
        //
        // if (defaultCountry) {
        // 	if (country === defaultCountry) {
        // 		return country
        // 	} else {
        // 		matchingCountries.push(country)
        // 	}
        // } else {
        // 	return country
        // }
        }
    }
// // Return the first ("main") one of the `matchingCountries`.
// if (matchingCountries.length > 0) {
// 	return matchingCountries[0]
// }
} //# sourceMappingURL=getCountryByNationalNumber.js.map
}),
"[project]/node_modules/libphonenumber-js/es6/helpers/getCountryByCallingCode.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>getCountryByCallingCode
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$helpers$2f$getCountryByNationalNumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/libphonenumber-js/es6/helpers/getCountryByNationalNumber.js [app-client] (ecmascript)");
;
var USE_NON_GEOGRAPHIC_COUNTRY_CODE = false;
function getCountryByCallingCode(callingCode, _ref) {
    var nationalPhoneNumber = _ref.nationalNumber, metadata = _ref.metadata;
    /* istanbul ignore if */ if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    var possibleCountries = metadata.getCountryCodesForCallingCode(callingCode);
    if (!possibleCountries) {
        return;
    }
    // If there's just one country corresponding to the country code,
    // then just return it, without further phone number digits validation.
    if (possibleCountries.length === 1) {
        return possibleCountries[0];
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$helpers$2f$getCountryByNationalNumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(nationalPhoneNumber, {
        countries: possibleCountries,
        metadata: metadata.metadata
    });
} //# sourceMappingURL=getCountryByCallingCode.js.map
}),
"[project]/node_modules/libphonenumber-js/es6/helpers/extractNationalNumber.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>extractNationalNumber
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$helpers$2f$extractNationalNumberFromPossiblyIncompleteNumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/libphonenumber-js/es6/helpers/extractNationalNumberFromPossiblyIncompleteNumber.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$helpers$2f$matchesEntirely$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/libphonenumber-js/es6/helpers/matchesEntirely.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$helpers$2f$checkNumberLength$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/libphonenumber-js/es6/helpers/checkNumberLength.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$helpers$2f$getCountryByCallingCode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/libphonenumber-js/es6/helpers/getCountryByCallingCode.js [app-client] (ecmascript)");
;
;
;
;
function extractNationalNumber(number, country, metadata) {
    // Parsing national prefixes and carrier codes
    // is only required for local phone numbers
    // but some people don't understand that
    // and sometimes write international phone numbers
    // with national prefixes (or maybe even carrier codes).
    // http://ucken.blogspot.ru/2016/03/trunk-prefixes-in-skype4b.html
    // Google's original library forgives such mistakes
    // and so does this library, because it has been requested:
    // https://github.com/catamphetamine/libphonenumber-js/issues/127
    var _extractNationalNumbe = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$helpers$2f$extractNationalNumberFromPossiblyIncompleteNumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(number, metadata), carrierCode = _extractNationalNumbe.carrierCode, nationalNumber = _extractNationalNumbe.nationalNumber;
    if (nationalNumber !== number) {
        if (!shouldHaveExtractedNationalPrefix(number, nationalNumber, metadata)) {
            // Don't strip the national prefix.
            return {
                nationalNumber: number
            };
        }
        // Check the national (significant) number length after extracting national prefix and carrier code.
        // Legacy generated metadata (before `1.0.18`) didn't support the "possible lengths" feature.
        if (metadata.numberingPlan.possibleLengths()) {
            // If an exact `country` is not specified, attempt to detect it from the assumed national number.
            if (!country) {
                country = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$helpers$2f$getCountryByCallingCode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(metadata.numberingPlan.callingCode(), {
                    nationalNumber: nationalNumber,
                    metadata: metadata
                });
            }
            // The number remaining after stripping the national prefix and carrier code
            // should be long enough to have a possible length for the country.
            // Otherwise, don't strip the national prefix and carrier code,
            // since the original number could be a valid number.
            // This check has been copy-pasted "as is" from Google's original library:
            // https://github.com/google/libphonenumber/blob/876268eb1ad6cdc1b7b5bef17fc5e43052702d57/java/libphonenumber/src/com/google/i18n/phonenumbers/PhoneNumberUtil.java#L3236-L3250
            // It doesn't check for the "possibility" of the original `number`.
            // I guess it's fine not checking that one. It works as is anyway.
            if (!isPossibleIncompleteNationalNumber(nationalNumber, country, metadata)) {
                // Don't strip the national prefix.
                return {
                    nationalNumber: number
                };
            }
        }
    }
    return {
        nationalNumber: nationalNumber,
        carrierCode: carrierCode
    };
}
// In some countries, the same digit could be a national prefix
// or a leading digit of a valid phone number.
// For example, in Russia, national prefix is `8`,
// and also `800 555 35 35` is a valid number
// in which `8` is not a national prefix, but the first digit
// of a national (significant) number.
// Same's with Belarus:
// `82004910060` is a valid national (significant) number,
// but `2004910060` is not.
// To support such cases (to prevent the code from always stripping
// national prefix), a condition is imposed: a national prefix
// is not extracted when the original number is "viable" and the
// resultant number is not, a "viable" national number being the one
// that matches `national_number_pattern`.
function shouldHaveExtractedNationalPrefix(nationalNumberBefore, nationalNumberAfter, metadata) {
    // The equivalent in Google's code is:
    // https://github.com/google/libphonenumber/blob/e326fa1fc4283bb05eb35cb3c15c18f98a31af33/java/libphonenumber/src/com/google/i18n/phonenumbers/PhoneNumberUtil.java#L2969-L3004
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$helpers$2f$matchesEntirely$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(nationalNumberBefore, metadata.nationalNumberPattern()) && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$helpers$2f$matchesEntirely$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(nationalNumberAfter, metadata.nationalNumberPattern())) {
        return false;
    }
    // This "is possible" national number (length) check has been commented out
    // because it's superceded by the (effectively) same check done in the
    // `extractNationalNumber()` function after it calls `shouldHaveExtractedNationalPrefix()`.
    // In other words, why run the same check twice if it could only be run once.
    // // Check the national (significant) number length after extracting national prefix and carrier code.
    // // Fixes a minor "weird behavior" bug: https://gitlab.com/catamphetamine/libphonenumber-js/-/issues/57
    // // (Legacy generated metadata (before `1.0.18`) didn't support the "possible lengths" feature).
    // if (metadata.possibleLengths()) {
    // 	if (isPossibleIncompleteNationalNumber(nationalNumberBefore, metadata) &&
    // 		!isPossibleIncompleteNationalNumber(nationalNumberAfter, metadata)) {
    // 		return false
    // 	}
    // }
    return true;
}
function isPossibleIncompleteNationalNumber(nationalNumber, country, metadata) {
    switch((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$helpers$2f$checkNumberLength$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(nationalNumber, country, metadata)){
        case 'TOO_SHORT':
        case 'INVALID_LENGTH':
            // This library ignores "local-only" phone numbers (for simplicity).
            // See the readme for more info on what are "local-only" phone numbers.
            // case 'IS_POSSIBLE_LOCAL_ONLY':
            return false;
        default:
            return true;
    }
} //# sourceMappingURL=extractNationalNumber.js.map
}),
"[project]/node_modules/libphonenumber-js/es6/metadata.js [app-client] (ecmascript) <export getCountryCallingCode as default>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$metadata$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCountryCallingCode"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$metadata$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/libphonenumber-js/es6/metadata.js [app-client] (ecmascript)");
}),
"[project]/node_modules/libphonenumber-js/es6/helpers/extractCountryCallingCodeFromInternationalNumberWithoutPlusSign.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>extractCountryCallingCodeFromInternationalNumberWithoutPlusSign
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$metadata$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/libphonenumber-js/es6/metadata.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$helpers$2f$matchesEntirely$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/libphonenumber-js/es6/helpers/matchesEntirely.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$helpers$2f$extractNationalNumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/libphonenumber-js/es6/helpers/extractNationalNumber.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$helpers$2f$checkNumberLength$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/libphonenumber-js/es6/helpers/checkNumberLength.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$metadata$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__getCountryCallingCode__as__default$3e$__ = __turbopack_context__.i("[project]/node_modules/libphonenumber-js/es6/metadata.js [app-client] (ecmascript) <export getCountryCallingCode as default>");
;
;
;
;
;
function extractCountryCallingCodeFromInternationalNumberWithoutPlusSign(number, country, defaultCountry, defaultCallingCode, metadata) {
    var countryCallingCode = country || defaultCountry ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$metadata$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__getCountryCallingCode__as__default$3e$__["default"])(country || defaultCountry, metadata) : defaultCallingCode;
    if (number.indexOf(countryCallingCode) === 0) {
        metadata = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$metadata$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](metadata);
        metadata.selectNumberingPlan(country || defaultCountry, countryCallingCode);
        var possibleShorterNumber = number.slice(countryCallingCode.length);
        var _extractNationalNumbe = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$helpers$2f$extractNationalNumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(possibleShorterNumber, country, metadata), possibleShorterNationalNumber = _extractNationalNumbe.nationalNumber;
        var _extractNationalNumbe2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$helpers$2f$extractNationalNumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(number, country, metadata), nationalNumber = _extractNationalNumbe2.nationalNumber;
        // If the number was not valid before but is valid now,
        // or if it was too long before, we consider the number
        // with the country calling code stripped to be a better result
        // and keep that instead.
        // For example, in Germany (+49), `49` is a valid area code,
        // so if a number starts with `49`, it could be both a valid
        // national German number or an international number without
        // a leading `+`.
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$helpers$2f$matchesEntirely$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(nationalNumber, metadata.nationalNumberPattern()) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$helpers$2f$matchesEntirely$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(possibleShorterNationalNumber, metadata.nationalNumberPattern()) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$helpers$2f$checkNumberLength$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(nationalNumber, country, metadata) === 'TOO_LONG') {
            return {
                countryCallingCode: countryCallingCode,
                number: possibleShorterNumber
            };
        }
    }
    return {
        number: number
    };
} //# sourceMappingURL=extractCountryCallingCodeFromInternationalNumberWithoutPlusSign.js.map
}),
"[project]/node_modules/libphonenumber-js/es6/helpers/extractCountryCallingCode.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>extractCountryCallingCode
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$helpers$2f$stripIddPrefix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/libphonenumber-js/es6/helpers/stripIddPrefix.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$helpers$2f$extractCountryCallingCodeFromInternationalNumberWithoutPlusSign$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/libphonenumber-js/es6/helpers/extractCountryCallingCodeFromInternationalNumberWithoutPlusSign.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$metadata$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/libphonenumber-js/es6/metadata.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/libphonenumber-js/es6/constants.js [app-client] (ecmascript)");
;
;
;
;
function extractCountryCallingCode(number, country, defaultCountry, defaultCallingCode, metadata) {
    if (!number) {
        return {};
    }
    var isNumberWithIddPrefix;
    // If this is not an international phone number,
    // then either extract an "IDD" prefix, or extract a
    // country calling code from a number by autocorrecting it
    // by prepending a leading `+` in cases when it starts
    // with the country calling code.
    // https://wikitravel.org/en/International_dialling_prefix
    // https://github.com/catamphetamine/libphonenumber-js/issues/376
    if (number[0] !== '+') {
        // Convert an "out-of-country" dialing phone number
        // to a proper international phone number.
        var numberWithoutIDD = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$helpers$2f$stripIddPrefix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(number, country || defaultCountry, defaultCallingCode, metadata);
        // If an IDD prefix was stripped then
        // convert the number to international one
        // for subsequent parsing.
        if (numberWithoutIDD && numberWithoutIDD !== number) {
            isNumberWithIddPrefix = true;
            number = '+' + numberWithoutIDD;
        } else {
            // Check to see if the number starts with the country calling code
            // for the default country. If so, we remove the country calling code,
            // and do some checks on the validity of the number before and after.
            // https://github.com/catamphetamine/libphonenumber-js/issues/376
            if (country || defaultCountry || defaultCallingCode) {
                var _extractCountryCallin = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$helpers$2f$extractCountryCallingCodeFromInternationalNumberWithoutPlusSign$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(number, country, defaultCountry, defaultCallingCode, metadata), countryCallingCode = _extractCountryCallin.countryCallingCode, shorterNumber = _extractCountryCallin.number;
                if (countryCallingCode) {
                    return {
                        countryCallingCodeSource: 'FROM_NUMBER_WITHOUT_PLUS_SIGN',
                        countryCallingCode: countryCallingCode,
                        number: shorterNumber
                    };
                }
            }
            return {
                // No need to set it to `UNSPECIFIED`. It can be just `undefined`.
                // countryCallingCodeSource: 'UNSPECIFIED',
                number: number
            };
        }
    }
    // `number` can only be international at this point.
    // Fast abortion: country codes do not begin with a '0'
    if (number[1] === '0') {
        return {};
    }
    metadata = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$metadata$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](metadata);
    // The thing with country phone codes
    // is that they are orthogonal to each other
    // i.e. there's no such country phone code A
    // for which country phone code B exists
    // where B starts with A.
    // Therefore, while scanning digits,
    // if a valid country code is found,
    // that means that it is the country code.
    //
    var i = 2;
    while(i - 1 <= __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MAX_LENGTH_COUNTRY_CODE"] && i <= number.length){
        var _countryCallingCode = number.slice(1, i);
        if (metadata.hasCallingCode(_countryCallingCode)) {
            metadata.selectNumberingPlan(_countryCallingCode);
            return {
                countryCallingCodeSource: isNumberWithIddPrefix ? 'FROM_NUMBER_WITH_IDD' : 'FROM_NUMBER_WITH_PLUS_SIGN',
                countryCallingCode: _countryCallingCode,
                number: number.slice(i)
            };
        }
        i++;
    }
    return {};
} // The possible values for the returned `countryCallingCodeSource` are:
 //
 // Copy-pasted from:
 // https://github.com/google/libphonenumber/blob/master/resources/phonenumber.proto
 //
 // // The source from which the country_code is derived. This is not set in the
 // // general parsing method, but in the method that parses and keeps raw_input.
 // // New fields could be added upon request.
 // enum CountryCodeSource {
 //  // Default value returned if this is not set, because the phone number was
 //  // created using parse, not parseAndKeepRawInput. hasCountryCodeSource will
 //  // return false if this is the case.
 //  UNSPECIFIED = 0;
 //
 //  // The country_code is derived based on a phone number with a leading "+",
 //  // e.g. the French number "+33 1 42 68 53 00".
 //  FROM_NUMBER_WITH_PLUS_SIGN = 1;
 //
 //  // The country_code is derived based on a phone number with a leading IDD,
 //  // e.g. the French number "011 33 1 42 68 53 00", as it is dialled from US.
 //  FROM_NUMBER_WITH_IDD = 5;
 //
 //  // The country_code is derived based on a phone number without a leading
 //  // "+", e.g. the French number "33 1 42 68 53 00" when defaultCountry is
 //  // supplied as France.
 //  FROM_NUMBER_WITHOUT_PLUS_SIGN = 10;
 //
 //  // The country_code is derived NOT based on the phone number itself, but
 //  // from the defaultCountry parameter provided in the parsing function by the
 //  // clients. This happens mostly for numbers written in the national format
 //  // (without country code). For example, this would be set when parsing the
 //  // French number "01 42 68 53 00", when defaultCountry is supplied as
 //  // France.
 //  FROM_DEFAULT_COUNTRY = 20;
 // }
 //# sourceMappingURL=extractCountryCallingCode.js.map
}),
"[project]/node_modules/libphonenumber-js/es6/helpers/applyInternationalSeparatorStyle.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>applyInternationalSeparatorStyle
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/libphonenumber-js/es6/constants.js [app-client] (ecmascript)");
;
function applyInternationalSeparatorStyle(formattedNumber) {
    return formattedNumber.replace(new RegExp("[".concat(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VALID_PUNCTUATION"], "]+"), 'g'), ' ').trim();
} //# sourceMappingURL=applyInternationalSeparatorStyle.js.map
}),
"[project]/node_modules/libphonenumber-js/es6/helpers/formatNationalNumberUsingFormat.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "FIRST_GROUP_PATTERN",
    ()=>FIRST_GROUP_PATTERN,
    "default",
    ()=>formatNationalNumberUsingFormat
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$helpers$2f$applyInternationalSeparatorStyle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/libphonenumber-js/es6/helpers/applyInternationalSeparatorStyle.js [app-client] (ecmascript)");
;
var FIRST_GROUP_PATTERN = /(\$\d)/;
function formatNationalNumberUsingFormat(number, format, _ref) {
    var useInternationalFormat = _ref.useInternationalFormat, withNationalPrefix = _ref.withNationalPrefix, carrierCode = _ref.carrierCode, metadata = _ref.metadata;
    var formattedNumber = number.replace(new RegExp(format.pattern()), useInternationalFormat ? format.internationalFormat() : // This library doesn't use `domestic_carrier_code_formatting_rule`,
    // because that one is only used when formatting phone numbers
    // for dialing from a mobile phone, and this is not a dialing library.
    // carrierCode && format.domesticCarrierCodeFormattingRule()
    // 	// First, replace the $CC in the formatting rule with the desired carrier code.
    // 	// Then, replace the $FG in the formatting rule with the first group
    // 	// and the carrier code combined in the appropriate way.
    // 	? format.format().replace(FIRST_GROUP_PATTERN, format.domesticCarrierCodeFormattingRule().replace('$CC', carrierCode))
    // 	: (
    // 		withNationalPrefix && format.nationalPrefixFormattingRule()
    // 			? format.format().replace(FIRST_GROUP_PATTERN, format.nationalPrefixFormattingRule())
    // 			: format.format()
    // 	)
    withNationalPrefix && format.nationalPrefixFormattingRule() ? format.format().replace(FIRST_GROUP_PATTERN, format.nationalPrefixFormattingRule()) : format.format());
    if (useInternationalFormat) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$helpers$2f$applyInternationalSeparatorStyle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(formattedNumber);
    }
    return formattedNumber;
} //# sourceMappingURL=formatNationalNumberUsingFormat.js.map
}),
"[project]/node_modules/libphonenumber-js/es6/helpers/getIddPrefix.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>getIddPrefix
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$metadata$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/libphonenumber-js/es6/metadata.js [app-client] (ecmascript)");
;
/**
 * Pattern that makes it easy to distinguish whether a region has a single
 * international dialing prefix or not. If a region has a single international
 * prefix (e.g. 011 in USA), it will be represented as a string that contains
 * a sequence of ASCII digits, and possibly a tilde, which signals waiting for
 * the tone. If there are multiple available international prefixes in a
 * region, they will be represented as a regex string that always contains one
 * or more characters that are not ASCII digits or a tilde.
 */ var SINGLE_IDD_PREFIX_REG_EXP = /^[\d]+(?:[~\u2053\u223C\uFF5E][\d]+)?$/;
function getIddPrefix(country, callingCode, metadata) {
    var countryMetadata = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$metadata$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](metadata);
    countryMetadata.selectNumberingPlan(country, callingCode);
    if (countryMetadata.defaultIDDPrefix()) {
        return countryMetadata.defaultIDDPrefix();
    }
    if (SINGLE_IDD_PREFIX_REG_EXP.test(countryMetadata.IDDPrefix())) {
        return countryMetadata.IDDPrefix();
    }
} //# sourceMappingURL=getIddPrefix.js.map
}),
"[project]/node_modules/libphonenumber-js/es6/helpers/extension/createExtensionPattern.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>createExtensionPattern
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/libphonenumber-js/es6/constants.js [app-client] (ecmascript)");
;
// The RFC 3966 format for extensions.
var RFC3966_EXTN_PREFIX = ';ext=';
/**
 * Helper method for constructing regular expressions for parsing. Creates
 * an expression that captures up to max_length digits.
 * @return {string} RegEx pattern to capture extension digits.
 */ var getExtensionDigitsPattern = function getExtensionDigitsPattern(maxLength) {
    return "([".concat(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VALID_DIGITS"], "]{1,").concat(maxLength, "})");
};
function createExtensionPattern(purpose) {
    // We cap the maximum length of an extension based on the ambiguity of the way
    // the extension is prefixed. As per ITU, the officially allowed length for
    // extensions is actually 40, but we don't support this since we haven't seen real
    // examples and this introduces many false interpretations as the extension labels
    // are not standardized.
    /** @type {string} */ var extLimitAfterExplicitLabel = '20';
    /** @type {string} */ var extLimitAfterLikelyLabel = '15';
    /** @type {string} */ var extLimitAfterAmbiguousChar = '9';
    /** @type {string} */ var extLimitWhenNotSure = '6';
    /** @type {string} */ var possibleSeparatorsBetweenNumberAndExtLabel = "[ \xA0\\t,]*";
    // Optional full stop (.) or colon, followed by zero or more spaces/tabs/commas.
    /** @type {string} */ var possibleCharsAfterExtLabel = "[:\\.\uFF0E]?[ \xA0\\t,-]*";
    /** @type {string} */ var optionalExtnSuffix = "#?";
    // Here the extension is called out in more explicit way, i.e mentioning it obvious
    // patterns like "ext.".
    /** @type {string} */ var explicitExtLabels = "(?:e?xt(?:ensi(?:o\u0301?|\xF3))?n?|\uFF45?\uFF58\uFF54\uFF4E?|\u0434\u043E\u0431|anexo)";
    // One-character symbols that can be used to indicate an extension, and less
    // commonly used or more ambiguous extension labels.
    /** @type {string} */ var ambiguousExtLabels = "(?:[x\uFF58#\uFF03~\uFF5E]|int|\uFF49\uFF4E\uFF54)";
    // When extension is not separated clearly.
    /** @type {string} */ var ambiguousSeparator = "[- ]+";
    // This is the same as possibleSeparatorsBetweenNumberAndExtLabel, but not matching
    // comma as extension label may have it.
    /** @type {string} */ var possibleSeparatorsNumberExtLabelNoComma = "[ \xA0\\t]*";
    // ",," is commonly used for auto dialling the extension when connected. First
    // comma is matched through possibleSeparatorsBetweenNumberAndExtLabel, so we do
    // not repeat it here. Semi-colon works in Iphone and Android also to pop up a
    // button with the extension number following.
    /** @type {string} */ var autoDiallingAndExtLabelsFound = "(?:,{2}|;)";
    /** @type {string} */ var rfcExtn = RFC3966_EXTN_PREFIX + getExtensionDigitsPattern(extLimitAfterExplicitLabel);
    /** @type {string} */ var explicitExtn = possibleSeparatorsBetweenNumberAndExtLabel + explicitExtLabels + possibleCharsAfterExtLabel + getExtensionDigitsPattern(extLimitAfterExplicitLabel) + optionalExtnSuffix;
    /** @type {string} */ var ambiguousExtn = possibleSeparatorsBetweenNumberAndExtLabel + ambiguousExtLabels + possibleCharsAfterExtLabel + getExtensionDigitsPattern(extLimitAfterAmbiguousChar) + optionalExtnSuffix;
    /** @type {string} */ var americanStyleExtnWithSuffix = ambiguousSeparator + getExtensionDigitsPattern(extLimitWhenNotSure) + "#";
    /** @type {string} */ var autoDiallingExtn = possibleSeparatorsNumberExtLabelNoComma + autoDiallingAndExtLabelsFound + possibleCharsAfterExtLabel + getExtensionDigitsPattern(extLimitAfterLikelyLabel) + optionalExtnSuffix;
    /** @type {string} */ var onlyCommasExtn = possibleSeparatorsNumberExtLabelNoComma + "(?:,)+" + possibleCharsAfterExtLabel + getExtensionDigitsPattern(extLimitAfterAmbiguousChar) + optionalExtnSuffix;
    // The first regular expression covers RFC 3966 format, where the extension is added
    // using ";ext=". The second more generic where extension is mentioned with explicit
    // labels like "ext:". In both the above cases we allow more numbers in extension than
    // any other extension labels. The third one captures when single character extension
    // labels or less commonly used labels are used. In such cases we capture fewer
    // extension digits in order to reduce the chance of falsely interpreting two
    // numbers beside each other as a number + extension. The fourth one covers the
    // special case of American numbers where the extension is written with a hash
    // at the end, such as "- 503#". The fifth one is exclusively for extension
    // autodialling formats which are used when dialling and in this case we accept longer
    // extensions. The last one is more liberal on the number of commas that acts as
    // extension labels, so we have a strict cap on the number of digits in such extensions.
    return rfcExtn + "|" + explicitExtn + "|" + ambiguousExtn + "|" + americanStyleExtnWithSuffix + "|" + autoDiallingExtn + "|" + onlyCommasExtn;
} //# sourceMappingURL=createExtensionPattern.js.map
}),
"[project]/node_modules/libphonenumber-js/es6/helpers/isViablePhoneNumber.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "VALID_PHONE_NUMBER",
    ()=>VALID_PHONE_NUMBER,
    "VALID_PHONE_NUMBER_WITH_EXTENSION",
    ()=>VALID_PHONE_NUMBER_WITH_EXTENSION,
    "default",
    ()=>isViablePhoneNumber,
    "isViablePhoneNumberStart",
    ()=>isViablePhoneNumberStart
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/libphonenumber-js/es6/constants.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$helpers$2f$extension$2f$createExtensionPattern$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/libphonenumber-js/es6/helpers/extension/createExtensionPattern.js [app-client] (ecmascript)");
;
;
//  Regular expression of viable phone numbers. This is location independent.
//  Checks we have at least three leading digits, and only valid punctuation,
//  alpha characters and digits in the phone number. Does not include extension
//  data. The symbol 'x' is allowed here as valid punctuation since it is often
//  used as a placeholder for carrier codes, for example in Brazilian phone
//  numbers. We also allow multiple '+' characters at the start.
//
//  Corresponds to the following:
//  [digits]{minLengthNsn}|
//  plus_sign*
//  (([punctuation]|[star])*[digits]){3,}([punctuation]|[star]|[digits]|[alpha])*
//
//  The first reg-ex is to allow short numbers (two digits long) to be parsed if
//  they are entered as "15" etc, but only if there is no punctuation in them.
//  The second expression restricts the number of digits to three or more, but
//  then allows them to be in international form, and to have alpha-characters
//  and punctuation. We split up the two reg-exes here and combine them when
//  creating the reg-ex VALID_PHONE_NUMBER_PATTERN itself so we can prefix it
//  with ^ and append $ to each branch.
//
//  "Note VALID_PUNCTUATION starts with a -,
//   so must be the first in the range" (c) Google devs.
//  (wtf did they mean by saying that; probably nothing)
//
var MIN_LENGTH_PHONE_NUMBER_PATTERN = '[' + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VALID_DIGITS"] + ']{' + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MIN_LENGTH_FOR_NSN"] + '}';
var VALID_PHONE_NUMBER = '[' + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PLUS_CHARS"] + ']{0,1}' + '(?:' + '[' + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VALID_PUNCTUATION"] + ']*' + '[' + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VALID_DIGITS"] + ']' + '){3,}' + '[' + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VALID_PUNCTUATION"] + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VALID_DIGITS"] + ']*';
// This regular expression isn't present in Google's `libphonenumber`
// and is only used to determine whether the phone number being input
// is too short for it to even consider it a "valid" number.
// This is just a way to differentiate between a really invalid phone
// number like "abcde" and a valid phone number that a user has just
// started inputting, like "+1" or "1": both these cases would be
// considered `NOT_A_NUMBER` by Google's `libphonenumber`, but this
// library can provide a more detailed error message  whether it's
// really "not a number", or is it just a start of a valid phone number.
var VALID_PHONE_NUMBER_START_REG_EXP = new RegExp('^' + '[' + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PLUS_CHARS"] + ']{0,1}' + '(?:' + '[' + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VALID_PUNCTUATION"] + ']*' + '[' + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VALID_DIGITS"] + ']' + '){1,2}' + '$', 'i');
var VALID_PHONE_NUMBER_WITH_EXTENSION = VALID_PHONE_NUMBER + // Phone number extensions
'(?:' + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$helpers$2f$extension$2f$createExtensionPattern$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])() + ')?';
// The combined regular expression for valid phone numbers:
//
var VALID_PHONE_NUMBER_PATTERN = new RegExp(// Either a short two-digit-only phone number
'^' + MIN_LENGTH_PHONE_NUMBER_PATTERN + '$' + '|' + // Or a longer fully parsed phone number (min 3 characters)
'^' + VALID_PHONE_NUMBER_WITH_EXTENSION + '$', 'i');
function isViablePhoneNumber(number) {
    return number.length >= __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MIN_LENGTH_FOR_NSN"] && VALID_PHONE_NUMBER_PATTERN.test(number);
}
function isViablePhoneNumberStart(number) {
    return VALID_PHONE_NUMBER_START_REG_EXP.test(number);
} //# sourceMappingURL=isViablePhoneNumber.js.map
}),
"[project]/node_modules/libphonenumber-js/es6/helpers/RFC3966.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "formatRFC3966",
    ()=>formatRFC3966,
    "parseRFC3966",
    ()=>parseRFC3966
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$helpers$2f$isViablePhoneNumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/libphonenumber-js/es6/helpers/isViablePhoneNumber.js [app-client] (ecmascript)");
function _slicedToArray(r, e) {
    return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();
}
function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArrayLimit(r, l) {
    var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
    if (null != t) {
        var e, n, i, u, a = [], f = !0, o = !1;
        try {
            if (i = (t = t.call(r)).next, 0 === l) {
                if (Object(t) !== t) return;
                f = !1;
            } else for(; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);
        } catch (r) {
            o = !0, n = r;
        } finally{
            try {
                if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
            } finally{
                if (o) throw n;
            }
        }
        return a;
    }
}
function _arrayWithHoles(r) {
    if (Array.isArray(r)) return r;
}
function _createForOfIteratorHelperLoose(r, e) {
    var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
    if (t) return (t = t.call(r)).next.bind(t);
    if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) {
        t && (r = t);
        var o = 0;
        return function() {
            return o >= r.length ? {
                done: !0
            } : {
                done: !1,
                value: r[o++]
            };
        };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(r, a) {
    if (r) {
        if ("string" == typeof r) return _arrayLikeToArray(r, a);
        var t = ({}).toString.call(r).slice(8, -1);
        return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
    }
}
function _arrayLikeToArray(r, a) {
    (null == a || a > r.length) && (a = r.length);
    for(var e = 0, n = Array(a); e < a; e++)n[e] = r[e];
    return n;
}
;
function parseRFC3966(text) {
    var number;
    var ext;
    // Replace "tel:" with "tel=" for parsing convenience.
    text = text.replace(/^tel:/, 'tel=');
    for(var _iterator = _createForOfIteratorHelperLoose(text.split(';')), _step; !(_step = _iterator()).done;){
        var part = _step.value;
        var _part$split = part.split('='), _part$split2 = _slicedToArray(_part$split, 2), name = _part$split2[0], value = _part$split2[1];
        switch(name){
            case 'tel':
                number = value;
                break;
            case 'ext':
                ext = value;
                break;
            case 'phone-context':
                // Only "country contexts" are supported.
                // "Domain contexts" are ignored.
                if (value[0] === '+') {
                    number = value + number;
                }
                break;
        }
    }
    // If the phone number is not viable, then abort.
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$helpers$2f$isViablePhoneNumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(number)) {
        return {};
    }
    var result = {
        number: number
    };
    if (ext) {
        result.ext = ext;
    }
    return result;
}
function formatRFC3966(_ref) {
    var number = _ref.number, ext = _ref.ext;
    if (!number) {
        return '';
    }
    if (number[0] !== '+') {
        throw new Error("\"formatRFC3966()\" expects \"number\" to be in E.164 format.");
    }
    return "tel:".concat(number).concat(ext ? ';ext=' + ext : '');
} //# sourceMappingURL=RFC3966.js.map
}),
"[project]/node_modules/libphonenumber-js/es6/format.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// This is a port of Google Android `libphonenumber`'s
// `phonenumberutil.js` of December 31th, 2018.
//
// https://github.com/googlei18n/libphonenumber/commits/master/javascript/i18n/phonenumbers/phonenumberutil.js
__turbopack_context__.s([
    "chooseFormatForNumber",
    ()=>chooseFormatForNumber,
    "default",
    ()=>formatNumber
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$helpers$2f$matchesEntirely$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/libphonenumber-js/es6/helpers/matchesEntirely.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$helpers$2f$formatNationalNumberUsingFormat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/libphonenumber-js/es6/helpers/formatNationalNumberUsingFormat.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$metadata$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/libphonenumber-js/es6/metadata.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$helpers$2f$getIddPrefix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/libphonenumber-js/es6/helpers/getIddPrefix.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$helpers$2f$RFC3966$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/libphonenumber-js/es6/helpers/RFC3966.js [app-client] (ecmascript)");
;
;
;
;
;
var DEFAULT_OPTIONS = {
    formatExtension: function formatExtension(formattedNumber, extension, metadata) {
        return "".concat(formattedNumber).concat(metadata.ext()).concat(extension);
    }
};
function formatNumber(input, format, options, metadata) {
    // Apply default options.
    if (options) {
        // Using ES6 "rest spread" syntax here didn't work with `babel`/`istanbul`
        // for some weird reason: this line of code would cause the code coverage
        // to show as not 100%. That's because `babel`/`istanbul`, for some weird reason,
        // apparently doesn't know how to properly exclude Babel polyfills from code coverage.
        //
        // options = { ...DEFAULT_OPTIONS, ...options }
        //
        options = merge({}, DEFAULT_OPTIONS, options);
    } else {
        options = DEFAULT_OPTIONS;
    }
    metadata = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$metadata$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](metadata);
    if (input.country && input.country !== '001') {
        // Validate `input.country`.
        if (!metadata.hasCountry(input.country)) {
            throw new Error("Unknown country: ".concat(input.country));
        }
        metadata.selectNumberingPlan(input.country);
    } else if (input.countryCallingCode) {
        metadata.selectNumberingPlan(input.countryCallingCode);
    } else return input.phone || '';
    var countryCallingCode = metadata.countryCallingCode();
    var nationalNumber = options.v2 ? input.nationalNumber : input.phone;
    // This variable should have been declared inside `case`s
    // but Babel has a bug and it says "duplicate variable declaration".
    var number;
    switch(format){
        case 'NATIONAL':
            // Legacy argument support.
            // (`{ country: ..., phone: '' }`)
            if (!nationalNumber) {
                return '';
            }
            number = formatNationalNumber(nationalNumber, input.carrierCode, 'NATIONAL', metadata, options);
            return addExtension(number, input.ext, metadata, options.formatExtension);
        case 'INTERNATIONAL':
            // Legacy argument support.
            // (`{ country: ..., phone: '' }`)
            if (!nationalNumber) {
                return "+".concat(countryCallingCode);
            }
            number = formatNationalNumber(nationalNumber, null, 'INTERNATIONAL', metadata, options);
            number = "+".concat(countryCallingCode, " ").concat(number);
            return addExtension(number, input.ext, metadata, options.formatExtension);
        case 'E.164':
            // `E.164` doesn't define "phone number extensions".
            return "+".concat(countryCallingCode).concat(nationalNumber);
        case 'RFC3966':
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$helpers$2f$RFC3966$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["formatRFC3966"])({
                number: "+".concat(countryCallingCode).concat(nationalNumber),
                ext: input.ext
            });
        // For reference, here's Google's IDD formatter:
        // https://github.com/google/libphonenumber/blob/32719cf74e68796788d1ca45abc85dcdc63ba5b9/java/libphonenumber/src/com/google/i18n/phonenumbers/PhoneNumberUtil.java#L1546
        // Not saying that this IDD formatter replicates it 1:1, but it seems to work.
        // Who would even need to format phone numbers in IDD format anyway?
        case 'IDD':
            if (!options.fromCountry) {
                return;
            // throw new Error('`fromCountry` option not passed for IDD-prefixed formatting.')
            }
            var formattedNumber = formatIDD(nationalNumber, input.carrierCode, countryCallingCode, options.fromCountry, metadata);
            return addExtension(formattedNumber, input.ext, metadata, options.formatExtension);
        default:
            throw new Error("Unknown \"format\" argument passed to \"formatNumber()\": \"".concat(format, "\""));
    }
}
function formatNationalNumber(number, carrierCode, formatAs, metadata, options) {
    var format = chooseFormatForNumber(metadata.formats(), number);
    if (!format) {
        return number;
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$helpers$2f$formatNationalNumberUsingFormat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(number, format, {
        useInternationalFormat: formatAs === 'INTERNATIONAL',
        withNationalPrefix: format.nationalPrefixIsOptionalWhenFormattingInNationalFormat() && options && options.nationalPrefix === false ? false : true,
        carrierCode: carrierCode,
        metadata: metadata
    });
}
function chooseFormatForNumber(availableFormats, nationalNumber) {
    // Using a `for ... of` loop here didn't work with `babel`/`istanbul`:
    // for some weird reason, it showed code coverage less than 100%.
    // That's because `babel`/`istanbul`, for some weird reason,
    // apparently doesn't know how to properly exclude Babel polyfills from code coverage.
    //
    // for (const format of availableFormats) { ... }
    //
    return pickFirstMatchingElement(availableFormats, function(format) {
        // Validate leading digits.
        // The test case for "else path" could be found by searching for
        // "format.leadingDigitsPatterns().length === 0".
        if (format.leadingDigitsPatterns().length > 0) {
            // The last leading_digits_pattern is used here, as it is the most detailed
            var lastLeadingDigitsPattern = format.leadingDigitsPatterns()[format.leadingDigitsPatterns().length - 1];
            // If leading digits don't match then move on to the next phone number format
            if (nationalNumber.search(lastLeadingDigitsPattern) !== 0) {
                return false;
            }
        }
        // Check that the national number matches the phone number format regular expression
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$helpers$2f$matchesEntirely$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(nationalNumber, format.pattern());
    });
}
function addExtension(formattedNumber, ext, metadata, formatExtension) {
    return ext ? formatExtension(formattedNumber, ext, metadata) : formattedNumber;
}
function formatIDD(nationalNumber, carrierCode, countryCallingCode, fromCountry, metadata) {
    var fromCountryCallingCode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$metadata$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCountryCallingCode"])(fromCountry, metadata.metadata);
    // When calling within the same country calling code.
    if (fromCountryCallingCode === countryCallingCode) {
        var formattedNumber = formatNationalNumber(nationalNumber, carrierCode, 'NATIONAL', metadata);
        // For NANPA regions, return the national format for these regions
        // but prefix it with the country calling code.
        if (countryCallingCode === '1') {
            return countryCallingCode + ' ' + formattedNumber;
        }
        // If regions share a country calling code, the country calling code need
        // not be dialled. This also applies when dialling within a region, so this
        // if clause covers both these cases. Technically this is the case for
        // dialling from La Reunion to other overseas departments of France (French
        // Guiana, Martinique, Guadeloupe), but not vice versa - so we don't cover
        // this edge case for now and for those cases return the version including
        // country calling code. Details here:
        // http://www.petitfute.com/voyage/225-info-pratiques-reunion
        //
        return formattedNumber;
    }
    var iddPrefix = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$helpers$2f$getIddPrefix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(fromCountry, undefined, metadata.metadata);
    if (iddPrefix) {
        return "".concat(iddPrefix, " ").concat(countryCallingCode, " ").concat(formatNationalNumber(nationalNumber, null, 'INTERNATIONAL', metadata));
    }
}
function merge() {
    var i = 1;
    for(var _len = arguments.length, objects = new Array(_len), _key = 0; _key < _len; _key++){
        objects[_key] = arguments[_key];
    }
    while(i < objects.length){
        if (objects[i]) {
            for(var key in objects[i]){
                objects[0][key] = objects[i][key];
            }
        }
        i++;
    }
    return objects[0];
}
function pickFirstMatchingElement(elements, testFunction) {
    var i = 0;
    while(i < elements.length){
        if (testFunction(elements[i])) {
            return elements[i];
        }
        i++;
    }
} //# sourceMappingURL=format.js.map
}),
"[project]/node_modules/libphonenumber-js/es6/PhoneNumber.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>PhoneNumber
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$metadata$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/libphonenumber-js/es6/metadata.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$isPossible$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/libphonenumber-js/es6/isPossible.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$isValid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/libphonenumber-js/es6/isValid.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$helpers$2f$getNumberType$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/libphonenumber-js/es6/helpers/getNumberType.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$helpers$2f$getPossibleCountriesForNumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/libphonenumber-js/es6/helpers/getPossibleCountriesForNumber.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$helpers$2f$extractCountryCallingCode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/libphonenumber-js/es6/helpers/extractCountryCallingCode.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$helpers$2f$isObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/libphonenumber-js/es6/helpers/isObject.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$format$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/libphonenumber-js/es6/format.js [app-client] (ecmascript)");
function _typeof(o) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o) {
        return typeof o;
    } : function(o) {
        return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    }, _typeof(o);
}
function ownKeys(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r) {
            return Object.getOwnPropertyDescriptor(e, r).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {
            _defineProperty(e, r, t[r]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
        });
    }
    return e;
}
function _defineProperty(e, r, t) {
    return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[r] = t, e;
}
function _classCallCheck(a, n) {
    if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(e, r) {
    for(var t = 0; t < r.length; t++){
        var o = r[t];
        o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);
    }
}
function _createClass(e, r, t) {
    return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
        writable: !1
    }), e;
}
function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return "symbol" == _typeof(i) ? i : i + "";
}
function _toPrimitive(t, r) {
    if ("object" != _typeof(t) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
;
;
;
;
;
;
;
;
var USE_NON_GEOGRAPHIC_COUNTRY_CODE = false;
var PhoneNumber = /*#__PURE__*/ function() {
    /**
   * @param  {string} countryOrCountryCallingCode
   * @param  {string} nationalNumber
   * @param  {object} metadata  Metadata JSON
   * @return {PhoneNumber}
   */ function PhoneNumber(countryOrCountryCallingCode, nationalNumber, metadata) {
        _classCallCheck(this, PhoneNumber);
        // Validate `countryOrCountryCallingCode` argument.
        if (!countryOrCountryCallingCode) {
            throw new TypeError('First argument is required');
        }
        if (typeof countryOrCountryCallingCode !== 'string') {
            throw new TypeError('First argument must be a string');
        }
        // In case of public API use: `constructor(number, metadata)`.
        // Transform the arguments from `constructor(number, metadata)` to
        // `constructor(countryOrCountryCallingCode, nationalNumber, metadata)`.
        if (countryOrCountryCallingCode[0] === '+' && !nationalNumber) {
            throw new TypeError('`metadata` argument not passed');
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$helpers$2f$isObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(nationalNumber) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$helpers$2f$isObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(nationalNumber.countries)) {
            metadata = nationalNumber;
            var e164Number = countryOrCountryCallingCode;
            if (!E164_NUMBER_REGEXP.test(e164Number)) {
                throw new Error('Invalid `number` argument passed: must consist of a "+" followed by digits');
            }
            var _extractCountryCallin = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$helpers$2f$extractCountryCallingCode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(e164Number, undefined, undefined, undefined, metadata), _countryCallingCode = _extractCountryCallin.countryCallingCode, number = _extractCountryCallin.number;
            nationalNumber = number;
            countryOrCountryCallingCode = _countryCallingCode;
            if (!nationalNumber) {
                throw new Error('Invalid `number` argument passed: too short');
            }
        }
        // Validate `nationalNumber` argument.
        if (!nationalNumber) {
            throw new TypeError('`nationalNumber` argument is required');
        }
        if (typeof nationalNumber !== 'string') {
            throw new TypeError('`nationalNumber` argument must be a string');
        }
        // Validate `metadata` argument.
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$metadata$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["validateMetadata"])(metadata);
        // Initialize properties.
        var _getCountryAndCountry = getCountryAndCountryCallingCode(countryOrCountryCallingCode, metadata), country = _getCountryAndCountry.country, countryCallingCode = _getCountryAndCountry.countryCallingCode;
        this.country = country;
        this.countryCallingCode = countryCallingCode;
        this.nationalNumber = nationalNumber;
        this.number = '+' + this.countryCallingCode + this.nationalNumber;
        // Exclude `metadata` property output from `PhoneNumber.toString()`
        // so that it doesn't clutter the console output of Node.js.
        // Previously, when Node.js did `console.log(new PhoneNumber(...))`,
        // it would output the whole internal structure of the `metadata` object.
        this.getMetadata = function() {
            return metadata;
        };
    }
    return _createClass(PhoneNumber, [
        {
            key: "setExt",
            value: function setExt(ext) {
                this.ext = ext;
            }
        },
        {
            key: "getPossibleCountries",
            value: function getPossibleCountries() {
                if (this.country) {
                    return [
                        this.country
                    ];
                }
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$helpers$2f$getPossibleCountriesForNumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(this.countryCallingCode, this.nationalNumber, this.getMetadata());
            }
        },
        {
            key: "isPossible",
            value: function isPossible() {
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$isPossible$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(this, {
                    v2: true
                }, this.getMetadata());
            }
        },
        {
            key: "isValid",
            value: function isValid() {
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$isValid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(this, {
                    v2: true
                }, this.getMetadata());
            }
        },
        {
            key: "isNonGeographic",
            value: function isNonGeographic() {
                var metadata = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$metadata$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](this.getMetadata());
                return metadata.isNonGeographicCallingCode(this.countryCallingCode);
            }
        },
        {
            key: "isEqual",
            value: function isEqual(phoneNumber) {
                return this.number === phoneNumber.number && this.ext === phoneNumber.ext;
            }
        },
        {
            key: "getType",
            value: function getType() {
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$helpers$2f$getNumberType$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(this, {
                    v2: true
                }, this.getMetadata());
            }
        },
        {
            key: "format",
            value: function format(_format, options) {
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$format$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(this, _format, options ? _objectSpread(_objectSpread({}, options), {}, {
                    v2: true
                }) : {
                    v2: true
                }, this.getMetadata());
            }
        },
        {
            key: "formatNational",
            value: function formatNational(options) {
                return this.format('NATIONAL', options);
            }
        },
        {
            key: "formatInternational",
            value: function formatInternational(options) {
                return this.format('INTERNATIONAL', options);
            }
        },
        {
            key: "getURI",
            value: function getURI(options) {
                return this.format('RFC3966', options);
            }
        }
    ]);
}();
;
var isCountryCode = function isCountryCode(value) {
    return /^[A-Z]{2}$/.test(value);
};
function getCountryAndCountryCallingCode(countryOrCountryCallingCode, metadataJson) {
    var country;
    var countryCallingCode;
    var metadata = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$metadata$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](metadataJson);
    // If country code is passed then derive `countryCallingCode` from it.
    // Also store the country code as `.country`.
    if (isCountryCode(countryOrCountryCallingCode)) {
        country = countryOrCountryCallingCode;
        metadata.selectNumberingPlan(country);
        countryCallingCode = metadata.countryCallingCode();
    } else {
        countryCallingCode = countryOrCountryCallingCode;
        /* istanbul ignore if */ if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
        ;
    }
    return {
        country: country,
        countryCallingCode: countryCallingCode
    };
}
var E164_NUMBER_REGEXP = /^\+\d+$/; //# sourceMappingURL=PhoneNumber.js.map
}),
"[project]/node_modules/libphonenumber-js/es6/AsYouTypeState.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>AsYouTypeState
]);
function _typeof(o) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o) {
        return typeof o;
    } : function(o) {
        return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    }, _typeof(o);
}
function _classCallCheck(a, n) {
    if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(e, r) {
    for(var t = 0; t < r.length; t++){
        var o = r[t];
        o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);
    }
}
function _createClass(e, r, t) {
    return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
        writable: !1
    }), e;
}
function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return "symbol" == _typeof(i) ? i : i + "";
}
function _toPrimitive(t, r) {
    if ("object" != _typeof(t) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
// This "state" object simply holds the state of the "AsYouType" parser:
//
// * `country?: string`  The exact country of the phone number, if it could be determined.
//                        When inputting a phone number in "international" format, it will derive the `country` from "country calling code" and the phone number digits.
//                        When inputting a phone number in "national" format, it will derive the `country` from `defaultCountry` that was specified when creating the `AsYouType` formatter.
//                        Sidenote: If `USE_NON_GEOGRAPHIC_COUNTRY_CODE` flag was `true`, then for "non-geographic phone numbers" `state.country` would've been "001".
// * `callingCode?: string`  "Country calling code" that has been extracted from the input phone number.
//                        When inputting a phone number in "international" format, it will extract the "country calling code" from the digits that follow the "+" character.
//                        When inputting a phone number in "national" format, `callingCode` will be `undefined`.
//                        Sidenote: `state.callingCode` is therefore independent from `state.country` and there could be situations when `state.country` is defined by `state.callingCode` is not  that would be when inputting a phone number not in "international" format.
// * `digits: string`  Phone number digits that have been input so far, including the "+" character, if present. In case of inputting non-arabic digits, those will be converted to arabic ones.
// * `international: boolean`  Whether the phone number is being input in "international" format, i.e. with a "+" character.
// * `missingPlus: boolean`  Whether it's a phone number in "international" format that is missing the leading "+" character for some reason apparently, Google thinks that it's a common mistake when inputting a phone number.
// * `IDDPrefix?: string`  An "IDD prefix", when the phone number is being input in an "out-of-country dialing" format. https://wikitravel.org/en/International_dialling_prefix
// * `carrierCode?: string`  A "carrier code", if the phone number contains it. Normally, those can only be present in Colombia or Brazil, and only when calling from mobile phones to fixed-line numbers.
// * `nationalPrefix?: string`  "National prefix", if present in the phone number input.
// * `nationalSignificantNumber?: string`  National (significant) number digits that have been input so far.
// * `nationalSignificantNumberIsModified: boolean`  Tells if the parsed national (significant) number is present as-is in the input string. For example, when inputting "0343515551212999" Argentinian mobile number, the parsed national (significant) number is "93435551212999". There, one can see how it stripped "0" national prefix and prepended a "9", because that's how it is instructed to do in Argentina's metadata. So in the described example, the parsed national (significant) number is not present as-is in the input string. Instead, it's "modified" in the input string. https://gitlab.com/caamphetamine/libphonenumber-js/-/blob/master/METADATA.md#national_prefix_for_parsing--national_prefix_transform_rule
// * `prefixBeforeNationalSignificantNumberThatIsNotNationalPrefix?: string`  In some countries, a phone number could have a prefix that is not a "national prefix" but rather some other type of "utility" prefix.
//                                                                             For example, when calling within Australia, one could prepend `1831` prefix to hide caller's phone number.
//                                                                             https://gitlab.com/catamphetamine/libphonenumber-js/-/blob/master/METADATA.md#national_prefix_for_parsing--national_prefix_transform_rule
//
var AsYouTypeState = /*#__PURE__*/ function() {
    function AsYouTypeState(_ref) {
        var onCountryChange = _ref.onCountryChange, onCallingCodeChange = _ref.onCallingCodeChange;
        _classCallCheck(this, AsYouTypeState);
        this.onCountryChange = onCountryChange;
        this.onCallingCodeChange = onCallingCodeChange;
    }
    return _createClass(AsYouTypeState, [
        {
            key: "reset",
            value: function reset(_ref2) {
                var country = _ref2.country, callingCode = _ref2.callingCode;
                this.international = false;
                this.missingPlus = false;
                this.IDDPrefix = undefined;
                this.callingCode = undefined;
                this.digits = '';
                this.resetNationalSignificantNumber();
                this.initCountryAndCallingCode(country, callingCode);
            }
        },
        {
            key: "resetNationalSignificantNumber",
            value: function resetNationalSignificantNumber() {
                this.nationalSignificantNumber = this.getNationalDigits();
                this.nationalSignificantNumberIsModified = false;
                this.nationalPrefix = undefined;
                this.carrierCode = undefined;
                this.prefixBeforeNationalSignificantNumberThatIsNotNationalPrefix = undefined;
            }
        },
        {
            key: "update",
            value: function update(properties) {
                for(var _i = 0, _Object$keys = Object.keys(properties); _i < _Object$keys.length; _i++){
                    var key = _Object$keys[_i];
                    this[key] = properties[key];
                }
            }
        },
        {
            key: "initCountryAndCallingCode",
            value: function initCountryAndCallingCode(country, callingCode) {
                this.setCountry(country);
                this.setCallingCode(callingCode);
            }
        },
        {
            key: "setCountry",
            value: function setCountry(country) {
                this.country = country;
                this.onCountryChange(country);
            }
        },
        {
            key: "setCallingCode",
            value: function setCallingCode(callingCode) {
                this.callingCode = callingCode;
                this.onCallingCodeChange(callingCode, this.country);
            }
        },
        {
            key: "startInternationalNumber",
            value: function startInternationalNumber(country, callingCode) {
                // Prepend the `+` to parsed input.
                this.international = true;
                // If a default country was set then reset it
                // because an explicitly international phone
                // number is being entered.
                this.initCountryAndCallingCode(country, callingCode);
            }
        },
        {
            key: "appendDigits",
            value: function appendDigits(nextDigits) {
                this.digits += nextDigits;
            }
        },
        {
            key: "appendNationalSignificantNumberDigits",
            value: function appendNationalSignificantNumberDigits(nextDigits) {
                this.nationalSignificantNumber += nextDigits;
            }
        },
        {
            key: "getNationalDigits",
            value: function getNationalDigits() {
                if (this.international) {
                    return this.digits.slice((this.IDDPrefix ? this.IDDPrefix.length : 0) + (this.callingCode ? this.callingCode.length : 0));
                }
                return this.digits;
            }
        },
        {
            key: "getDigitsWithoutInternationalPrefix",
            value: function getDigitsWithoutInternationalPrefix() {
                if (this.international) {
                    if (this.IDDPrefix) {
                        return this.digits.slice(this.IDDPrefix.length);
                    }
                }
                return this.digits;
            }
        }
    ]);
}();
;
 //# sourceMappingURL=AsYouTypeState.js.map
}),
"[project]/node_modules/libphonenumber-js/es6/AsYouTypeFormatter.util.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "DIGIT_PLACEHOLDER",
    ()=>DIGIT_PLACEHOLDER,
    "closeNonPairedParens",
    ()=>closeNonPairedParens,
    "countOccurences",
    ()=>countOccurences,
    "cutAndStripNonPairedParens",
    ()=>cutAndStripNonPairedParens,
    "populateTemplateWithDigits",
    ()=>populateTemplateWithDigits,
    "repeat",
    ()=>repeat,
    "stripNonPairedParens",
    ()=>stripNonPairedParens
]);
function _createForOfIteratorHelperLoose(r, e) {
    var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
    if (t) return (t = t.call(r)).next.bind(t);
    if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) {
        t && (r = t);
        var o = 0;
        return function() {
            return o >= r.length ? {
                done: !0
            } : {
                done: !1,
                value: r[o++]
            };
        };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(r, a) {
    if (r) {
        if ("string" == typeof r) return _arrayLikeToArray(r, a);
        var t = ({}).toString.call(r).slice(8, -1);
        return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
    }
}
function _arrayLikeToArray(r, a) {
    (null == a || a > r.length) && (a = r.length);
    for(var e = 0, n = Array(a); e < a; e++)n[e] = r[e];
    return n;
}
var DIGIT_PLACEHOLDER = 'x'; // '\u2008' (punctuation space)
var DIGIT_PLACEHOLDER_MATCHER = new RegExp(DIGIT_PLACEHOLDER);
function countOccurences(symbol, string) {
    var count = 0;
    // Using `.split('')` to iterate through a string here
    // to avoid requiring `Symbol.iterator` polyfill.
    // `.split('')` is generally not safe for Unicode,
    // but in this particular case for counting brackets it is safe.
    // for (const character of string)
    for(var _iterator = _createForOfIteratorHelperLoose(string.split('')), _step; !(_step = _iterator()).done;){
        var character = _step.value;
        if (character === symbol) {
            count++;
        }
    }
    return count;
}
function repeat(string, times) {
    if (times < 1) {
        return '';
    }
    var result = '';
    while(times > 1){
        if (times & 1) {
            result += string;
        }
        times >>= 1;
        string += string;
    }
    return result + string;
}
function cutAndStripNonPairedParens(string, cutBeforeIndex) {
    if (string[cutBeforeIndex] === ')') {
        cutBeforeIndex++;
    }
    return stripNonPairedParens(string.slice(0, cutBeforeIndex));
}
function closeNonPairedParens(template, cut_before) {
    var retained_template = template.slice(0, cut_before);
    var opening_braces = countOccurences('(', retained_template);
    var closing_braces = countOccurences(')', retained_template);
    var dangling_braces = opening_braces - closing_braces;
    while(dangling_braces > 0 && cut_before < template.length){
        if (template[cut_before] === ')') {
            dangling_braces--;
        }
        cut_before++;
    }
    return template.slice(0, cut_before);
}
function stripNonPairedParens(string) {
    var dangling_braces = [];
    var i = 0;
    while(i < string.length){
        if (string[i] === '(') {
            dangling_braces.push(i);
        } else if (string[i] === ')') {
            dangling_braces.pop();
        }
        i++;
    }
    var start = 0;
    var cleared_string = '';
    dangling_braces.push(string.length);
    for(var _i = 0, _dangling_braces = dangling_braces; _i < _dangling_braces.length; _i++){
        var index = _dangling_braces[_i];
        cleared_string += string.slice(start, index);
        start = index + 1;
    }
    return cleared_string;
}
function populateTemplateWithDigits(template, position, digits) {
    // Using `.split('')` to iterate through a string here
    // to avoid requiring `Symbol.iterator` polyfill.
    // `.split('')` is generally not safe for Unicode,
    // but in this particular case for `digits` it is safe.
    // for (const digit of digits)
    for(var _iterator2 = _createForOfIteratorHelperLoose(digits.split('')), _step2; !(_step2 = _iterator2()).done;){
        var digit = _step2.value;
        // If there is room for more digits in current `template`,
        // then set the next digit in the `template`,
        // and return the formatted digits so far.
        // If more digits are entered than the current format could handle.
        if (template.slice(position + 1).search(DIGIT_PLACEHOLDER_MATCHER) < 0) {
            return;
        }
        position = template.search(DIGIT_PLACEHOLDER_MATCHER);
        template = template.replace(DIGIT_PLACEHOLDER_MATCHER, digit);
    }
    return [
        template,
        position
    ];
} //# sourceMappingURL=AsYouTypeFormatter.util.js.map
}),
"[project]/node_modules/libphonenumber-js/es6/helpers/parseDigits.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "DIGITS",
    ()=>DIGITS,
    "default",
    ()=>parseDigits,
    "parseDigit",
    ()=>parseDigit
]);
function _createForOfIteratorHelperLoose(r, e) {
    var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
    if (t) return (t = t.call(r)).next.bind(t);
    if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) {
        t && (r = t);
        var o = 0;
        return function() {
            return o >= r.length ? {
                done: !0
            } : {
                done: !1,
                value: r[o++]
            };
        };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(r, a) {
    if (r) {
        if ("string" == typeof r) return _arrayLikeToArray(r, a);
        var t = ({}).toString.call(r).slice(8, -1);
        return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
    }
}
function _arrayLikeToArray(r, a) {
    (null == a || a > r.length) && (a = r.length);
    for(var e = 0, n = Array(a); e < a; e++)n[e] = r[e];
    return n;
}
var DIGITS = {
    '0': '0',
    '1': '1',
    '2': '2',
    '3': '3',
    '4': '4',
    '5': '5',
    '6': '6',
    '7': '7',
    '8': '8',
    '9': '9',
    "\uFF10": '0',
    // Fullwidth digit 0
    "\uFF11": '1',
    // Fullwidth digit 1
    "\uFF12": '2',
    // Fullwidth digit 2
    "\uFF13": '3',
    // Fullwidth digit 3
    "\uFF14": '4',
    // Fullwidth digit 4
    "\uFF15": '5',
    // Fullwidth digit 5
    "\uFF16": '6',
    // Fullwidth digit 6
    "\uFF17": '7',
    // Fullwidth digit 7
    "\uFF18": '8',
    // Fullwidth digit 8
    "\uFF19": '9',
    // Fullwidth digit 9
    "\u0660": '0',
    // Arabic-indic digit 0
    "\u0661": '1',
    // Arabic-indic digit 1
    "\u0662": '2',
    // Arabic-indic digit 2
    "\u0663": '3',
    // Arabic-indic digit 3
    "\u0664": '4',
    // Arabic-indic digit 4
    "\u0665": '5',
    // Arabic-indic digit 5
    "\u0666": '6',
    // Arabic-indic digit 6
    "\u0667": '7',
    // Arabic-indic digit 7
    "\u0668": '8',
    // Arabic-indic digit 8
    "\u0669": '9',
    // Arabic-indic digit 9
    "\u06F0": '0',
    // Eastern-Arabic digit 0
    "\u06F1": '1',
    // Eastern-Arabic digit 1
    "\u06F2": '2',
    // Eastern-Arabic digit 2
    "\u06F3": '3',
    // Eastern-Arabic digit 3
    "\u06F4": '4',
    // Eastern-Arabic digit 4
    "\u06F5": '5',
    // Eastern-Arabic digit 5
    "\u06F6": '6',
    // Eastern-Arabic digit 6
    "\u06F7": '7',
    // Eastern-Arabic digit 7
    "\u06F8": '8',
    // Eastern-Arabic digit 8
    "\u06F9": '9' // Eastern-Arabic digit 9
};
function parseDigit(character) {
    return DIGITS[character];
}
function parseDigits(string) {
    var result = '';
    // Using `.split('')` here instead of normal `for ... of`
    // because the importing application doesn't neccessarily include an ES6 polyfill.
    // The `.split('')` approach discards "exotic" UTF-8 characters
    // (the ones consisting of four bytes) but digits
    // (including non-European ones) don't fall into that range
    // so such "exotic" characters would be discarded anyway.
    for(var _iterator = _createForOfIteratorHelperLoose(string.split('')), _step; !(_step = _iterator()).done;){
        var character = _step.value;
        var digit = parseDigit(character);
        if (digit) {
            result += digit;
        }
    }
    return result;
} //# sourceMappingURL=parseDigits.js.map
}),
"[project]/node_modules/libphonenumber-js/es6/AsYouTypeFormatter.complete.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "canFormatCompleteNumber",
    ()=>canFormatCompleteNumber,
    "default",
    ()=>formatCompleteNumber
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$helpers$2f$checkNumberLength$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/libphonenumber-js/es6/helpers/checkNumberLength.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$helpers$2f$parseDigits$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/libphonenumber-js/es6/helpers/parseDigits.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$helpers$2f$formatNationalNumberUsingFormat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/libphonenumber-js/es6/helpers/formatNationalNumberUsingFormat.js [app-client] (ecmascript)");
;
;
;
function formatCompleteNumber(state, format, _ref) {
    var metadata = _ref.metadata, shouldTryNationalPrefixFormattingRule = _ref.shouldTryNationalPrefixFormattingRule, getSeparatorAfterNationalPrefix = _ref.getSeparatorAfterNationalPrefix;
    var matcher = new RegExp("^(?:".concat(format.pattern(), ")$"));
    if (matcher.test(state.nationalSignificantNumber)) {
        return formatNationalNumberWithAndWithoutNationalPrefixFormattingRule(state, format, {
            metadata: metadata,
            shouldTryNationalPrefixFormattingRule: shouldTryNationalPrefixFormattingRule,
            getSeparatorAfterNationalPrefix: getSeparatorAfterNationalPrefix
        });
    }
}
function canFormatCompleteNumber(nationalSignificantNumber, country, metadata) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$helpers$2f$checkNumberLength$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(nationalSignificantNumber, country, metadata) === 'IS_POSSIBLE';
}
function formatNationalNumberWithAndWithoutNationalPrefixFormattingRule(state, format, _ref2) {
    var metadata = _ref2.metadata, shouldTryNationalPrefixFormattingRule = _ref2.shouldTryNationalPrefixFormattingRule, getSeparatorAfterNationalPrefix = _ref2.getSeparatorAfterNationalPrefix;
    // `format` has already been checked for `nationalPrefix` requirement.
    var nationalSignificantNumber = state.nationalSignificantNumber, international = state.international, nationalPrefix = state.nationalPrefix, carrierCode = state.carrierCode;
    // Format the number with using `national_prefix_formatting_rule`.
    // If the resulting formatted number is a valid formatted number, then return it.
    //
    // Google's AsYouType formatter is different in a way that it doesn't try
    // to format using the "national prefix formatting rule", and instead it
    // simply prepends a national prefix followed by a " " character.
    // This code does that too, but as a fallback.
    // The reason is that "national prefix formatting rule" may use parentheses,
    // which wouldn't be included has it used the simpler Google's way.
    //
    if (shouldTryNationalPrefixFormattingRule(format)) {
        var formattedNumber = formatNationalNumber(state, format, {
            useNationalPrefixFormattingRule: true,
            getSeparatorAfterNationalPrefix: getSeparatorAfterNationalPrefix,
            metadata: metadata
        });
        if (formattedNumber) {
            return formattedNumber;
        }
    }
    // Format the number without using `national_prefix_formatting_rule`.
    return formatNationalNumber(state, format, {
        useNationalPrefixFormattingRule: false,
        getSeparatorAfterNationalPrefix: getSeparatorAfterNationalPrefix,
        metadata: metadata
    });
}
function formatNationalNumber(state, format, _ref3) {
    var metadata = _ref3.metadata, useNationalPrefixFormattingRule = _ref3.useNationalPrefixFormattingRule, getSeparatorAfterNationalPrefix = _ref3.getSeparatorAfterNationalPrefix;
    var formattedNationalNumber = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$helpers$2f$formatNationalNumberUsingFormat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(state.nationalSignificantNumber, format, {
        carrierCode: state.carrierCode,
        useInternationalFormat: state.international,
        withNationalPrefix: useNationalPrefixFormattingRule,
        metadata: metadata
    });
    if (!useNationalPrefixFormattingRule) {
        if (state.nationalPrefix) {
            // If a national prefix was extracted, then just prepend it,
            // followed by a " " character.
            formattedNationalNumber = state.nationalPrefix + getSeparatorAfterNationalPrefix(format) + formattedNationalNumber;
        } else if (state.prefixBeforeNationalSignificantNumberThatIsNotNationalPrefix) {
            formattedNationalNumber = state.prefixBeforeNationalSignificantNumberThatIsNotNationalPrefix + ' ' + formattedNationalNumber;
        }
    }
    if (isValidFormattedNationalNumber(formattedNationalNumber, state)) {
        return formattedNationalNumber;
    }
}
// Check that the formatted phone number contains exactly
// the same digits that have been input by the user.
// For example, when "0111523456789" is input for `AR` country,
// the extracted `this.nationalSignificantNumber` is "91123456789",
// which means that the national part of `this.digits` isn't simply equal to
// `this.nationalPrefix` + `this.nationalSignificantNumber`.
//
// Also, a `format` can add extra digits to the `this.nationalSignificantNumber`
// being formatted via `metadata[country].national_prefix_transform_rule`.
// For example, for `VI` country, it prepends `340` to the national number,
// and if this check hasn't been implemented, then there would be a bug
// when `340` "area coude" is "duplicated" during input for `VI` country:
// https://github.com/catamphetamine/libphonenumber-js/issues/318
//
// So, all these "gotchas" are filtered out.
//
// In the original Google's code, the comments say:
// "Check that we didn't remove nor add any extra digits when we matched
// this formatting pattern. This usually happens after we entered the last
// digit during AYTF. Eg: In case of MX, we swallow mobile token (1) when
// formatted but AYTF should retain all the number entered and not change
// in order to match a format (of same leading digits and length) display
// in that way."
// "If it's the same (i.e entered number and format is same), then it's
// safe to return this in formatted number as nothing is lost / added."
// Otherwise, don't use this format.
// https://github.com/google/libphonenumber/commit/3e7c1f04f5e7200f87fb131e6f85c6e99d60f510#diff-9149457fa9f5d608a11bb975c6ef4bc5
// https://github.com/google/libphonenumber/commit/3ac88c7106e7dcb553bcc794b15f19185928a1c6#diff-2dcb77e833422ee304da348b905cde0b
//
function isValidFormattedNationalNumber(formattedNationalNumber, state) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$helpers$2f$parseDigits$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(formattedNationalNumber) === state.getNationalDigits();
} //# sourceMappingURL=AsYouTypeFormatter.complete.js.map
}),
"[project]/node_modules/libphonenumber-js/es6/AsYouTypeFormatter.PatternParser.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>PatternParser
]);
function _typeof(o) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o) {
        return typeof o;
    } : function(o) {
        return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    }, _typeof(o);
}
function _classCallCheck(a, n) {
    if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(e, r) {
    for(var t = 0; t < r.length; t++){
        var o = r[t];
        o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);
    }
}
function _createClass(e, r, t) {
    return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
        writable: !1
    }), e;
}
function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return "symbol" == _typeof(i) ? i : i + "";
}
function _toPrimitive(t, r) {
    if ("object" != _typeof(t) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
var PatternParser = /*#__PURE__*/ function() {
    function PatternParser() {
        _classCallCheck(this, PatternParser);
    }
    return _createClass(PatternParser, [
        {
            key: "parse",
            value: function parse(pattern) {
                this.context = [
                    {
                        or: true,
                        instructions: []
                    }
                ];
                this.parsePattern(pattern);
                if (this.context.length !== 1) {
                    throw new Error('Non-finalized contexts left when pattern parse ended');
                }
                var _this$context$ = this.context[0], branches = _this$context$.branches, instructions = _this$context$.instructions;
                if (branches) {
                    return {
                        op: '|',
                        args: branches.concat([
                            expandSingleElementArray(instructions)
                        ])
                    };
                }
                /* istanbul ignore if */ if (instructions.length === 0) {
                    throw new Error('Pattern is required');
                }
                if (instructions.length === 1) {
                    return instructions[0];
                }
                return instructions;
            }
        },
        {
            key: "startContext",
            value: function startContext(context) {
                this.context.push(context);
            }
        },
        {
            key: "endContext",
            value: function endContext() {
                this.context.pop();
            }
        },
        {
            key: "getContext",
            value: function getContext() {
                return this.context[this.context.length - 1];
            }
        },
        {
            key: "parsePattern",
            value: function parsePattern(pattern) {
                if (!pattern) {
                    throw new Error('Pattern is required');
                }
                var match = pattern.match(OPERATOR);
                if (!match) {
                    if (ILLEGAL_CHARACTER_REGEXP.test(pattern)) {
                        throw new Error("Illegal characters found in a pattern: ".concat(pattern));
                    }
                    this.getContext().instructions = this.getContext().instructions.concat(pattern.split(''));
                    return;
                }
                var operator = match[1];
                var before = pattern.slice(0, match.index);
                var rightPart = pattern.slice(match.index + operator.length);
                switch(operator){
                    case '(?:':
                        if (before) {
                            this.parsePattern(before);
                        }
                        this.startContext({
                            or: true,
                            instructions: [],
                            branches: []
                        });
                        break;
                    case ')':
                        if (!this.getContext().or) {
                            throw new Error('")" operator must be preceded by "(?:" operator');
                        }
                        if (before) {
                            this.parsePattern(before);
                        }
                        if (this.getContext().instructions.length === 0) {
                            throw new Error('No instructions found after "|" operator in an "or" group');
                        }
                        var _this$getContext = this.getContext(), branches = _this$getContext.branches;
                        branches.push(expandSingleElementArray(this.getContext().instructions));
                        this.endContext();
                        this.getContext().instructions.push({
                            op: '|',
                            args: branches
                        });
                        break;
                    case '|':
                        if (!this.getContext().or) {
                            throw new Error('"|" operator can only be used inside "or" groups');
                        }
                        if (before) {
                            this.parsePattern(before);
                        }
                        // The top-level is an implicit "or" group, if required.
                        if (!this.getContext().branches) {
                            // `branches` are not defined only for the root implicit "or" operator.
                            /* istanbul ignore else */ if (this.context.length === 1) {
                                this.getContext().branches = [];
                            } else {
                                throw new Error('"branches" not found in an "or" group context');
                            }
                        }
                        this.getContext().branches.push(expandSingleElementArray(this.getContext().instructions));
                        this.getContext().instructions = [];
                        break;
                    case '[':
                        if (before) {
                            this.parsePattern(before);
                        }
                        this.startContext({
                            oneOfSet: true
                        });
                        break;
                    case ']':
                        if (!this.getContext().oneOfSet) {
                            throw new Error('"]" operator must be preceded by "[" operator');
                        }
                        this.endContext();
                        this.getContext().instructions.push({
                            op: '[]',
                            args: parseOneOfSet(before)
                        });
                        break;
                    /* istanbul ignore next */ default:
                        throw new Error("Unknown operator: ".concat(operator));
                }
                if (rightPart) {
                    this.parsePattern(rightPart);
                }
            }
        }
    ]);
}();
;
function parseOneOfSet(pattern) {
    var values = [];
    var i = 0;
    while(i < pattern.length){
        if (pattern[i] === '-') {
            if (i === 0 || i === pattern.length - 1) {
                throw new Error("Couldn't parse a one-of set pattern: ".concat(pattern));
            }
            var prevValue = pattern[i - 1].charCodeAt(0) + 1;
            var nextValue = pattern[i + 1].charCodeAt(0) - 1;
            var value = prevValue;
            while(value <= nextValue){
                values.push(String.fromCharCode(value));
                value++;
            }
        } else {
            values.push(pattern[i]);
        }
        i++;
    }
    return values;
}
var ILLEGAL_CHARACTER_REGEXP = /[\(\)\[\]\?\:\|]/;
var OPERATOR = new RegExp(// any of:
'(' + // or operator
'\\|' + // or
'|' + // or group start
'\\(\\?\\:' + // or
'|' + // or group end
'\\)' + // or
'|' + // one-of set start
'\\[' + // or
'|' + // one-of set end
'\\]' + ')');
function expandSingleElementArray(array) {
    if (array.length === 1) {
        return array[0];
    }
    return array;
} //# sourceMappingURL=AsYouTypeFormatter.PatternParser.js.map
}),
"[project]/node_modules/libphonenumber-js/es6/AsYouTypeFormatter.PatternMatcher.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>PatternMatcher
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$AsYouTypeFormatter$2e$PatternParser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/libphonenumber-js/es6/AsYouTypeFormatter.PatternParser.js [app-client] (ecmascript)");
function _createForOfIteratorHelperLoose(r, e) {
    var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
    if (t) return (t = t.call(r)).next.bind(t);
    if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) {
        t && (r = t);
        var o = 0;
        return function() {
            return o >= r.length ? {
                done: !0
            } : {
                done: !1,
                value: r[o++]
            };
        };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(r, a) {
    if (r) {
        if ("string" == typeof r) return _arrayLikeToArray(r, a);
        var t = ({}).toString.call(r).slice(8, -1);
        return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
    }
}
function _arrayLikeToArray(r, a) {
    (null == a || a > r.length) && (a = r.length);
    for(var e = 0, n = Array(a); e < a; e++)n[e] = r[e];
    return n;
}
function _typeof(o) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o) {
        return typeof o;
    } : function(o) {
        return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    }, _typeof(o);
}
function _classCallCheck(a, n) {
    if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(e, r) {
    for(var t = 0; t < r.length; t++){
        var o = r[t];
        o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);
    }
}
function _createClass(e, r, t) {
    return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
        writable: !1
    }), e;
}
function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return "symbol" == _typeof(i) ? i : i + "";
}
function _toPrimitive(t, r) {
    if ("object" != _typeof(t) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
;
var PatternMatcher = /*#__PURE__*/ function() {
    function PatternMatcher(pattern) {
        _classCallCheck(this, PatternMatcher);
        this.matchTree = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$AsYouTypeFormatter$2e$PatternParser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]().parse(pattern);
    }
    return _createClass(PatternMatcher, [
        {
            key: "match",
            value: function match(string) {
                var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}, allowOverflow = _ref.allowOverflow;
                if (!string) {
                    throw new Error('String is required');
                }
                var result = _match(string.split(''), this.matchTree, true);
                if (result && result.match) {
                    delete result.matchedChars;
                }
                if (result && result.overflow) {
                    if (!allowOverflow) {
                        return;
                    }
                }
                return result;
            }
        }
    ]);
}();
;
function _match(characters, tree, last) {
    // If `tree` is a string, then `tree` is a single character.
    // That's because when a pattern is parsed, multi-character-string parts
    // of a pattern are compiled into arrays of single characters.
    // I still wrote this piece of code for a "general" hypothetical case
    // when `tree` could be a string of several characters, even though
    // such case is not possible with the current implementation.
    if (typeof tree === 'string') {
        var characterString = characters.join('');
        if (tree.indexOf(characterString) === 0) {
            // `tree` is always a single character.
            // If `tree.indexOf(characterString) === 0`
            // then `characters.length === tree.length`.
            /* istanbul ignore else */ if (characters.length === tree.length) {
                return {
                    match: true,
                    matchedChars: characters
                };
            }
            // `tree` is always a single character.
            // If `tree.indexOf(characterString) === 0`
            // then `characters.length === tree.length`.
            /* istanbul ignore next */ return {
                partialMatch: true
            };
        }
        if (characterString.indexOf(tree) === 0) {
            if (last) {
                // The `else` path is not possible because `tree` is always a single character.
                // The `else` case for `characters.length > tree.length` would be
                // `characters.length <= tree.length` which means `characters.length <= 1`.
                // `characters` array can't be empty, so that means `characters === [tree]`,
                // which would also mean `tree.indexOf(characterString) === 0` and that'd mean
                // that the `if (tree.indexOf(characterString) === 0)` condition before this
                // `if` condition would be entered, and returned from there, not reaching this code.
                /* istanbul ignore else */ if (characters.length > tree.length) {
                    return {
                        overflow: true
                    };
                }
            }
            return {
                match: true,
                matchedChars: characters.slice(0, tree.length)
            };
        }
        return;
    }
    if (Array.isArray(tree)) {
        var restCharacters = characters.slice();
        var i = 0;
        while(i < tree.length){
            var subtree = tree[i];
            var result = _match(restCharacters, subtree, last && i === tree.length - 1);
            if (!result) {
                return;
            } else if (result.overflow) {
                return result;
            } else if (result.match) {
                // Continue with the next subtree with the rest of the characters.
                restCharacters = restCharacters.slice(result.matchedChars.length);
                if (restCharacters.length === 0) {
                    if (i === tree.length - 1) {
                        return {
                            match: true,
                            matchedChars: characters
                        };
                    } else {
                        return {
                            partialMatch: true
                        };
                    }
                }
            } else {
                /* istanbul ignore else */ if (result.partialMatch) {
                    return {
                        partialMatch: true
                    };
                } else {
                    throw new Error("Unsupported match result:\n".concat(JSON.stringify(result, null, 2)));
                }
            }
            i++;
        }
        // If `last` then overflow has already been checked
        // by the last element of the `tree` array.
        /* istanbul ignore if */ if (last) {
            return {
                overflow: true
            };
        }
        return {
            match: true,
            matchedChars: characters.slice(0, characters.length - restCharacters.length)
        };
    }
    switch(tree.op){
        case '|':
            var partialMatch;
            for(var _iterator = _createForOfIteratorHelperLoose(tree.args), _step; !(_step = _iterator()).done;){
                var branch = _step.value;
                var _result = _match(characters, branch, last);
                if (_result) {
                    if (_result.overflow) {
                        return _result;
                    } else if (_result.match) {
                        return {
                            match: true,
                            matchedChars: _result.matchedChars
                        };
                    } else {
                        /* istanbul ignore else */ if (_result.partialMatch) {
                            partialMatch = true;
                        } else {
                            throw new Error("Unsupported match result:\n".concat(JSON.stringify(_result, null, 2)));
                        }
                    }
                }
            }
            if (partialMatch) {
                return {
                    partialMatch: true
                };
            }
            // Not even a partial match.
            return;
        case '[]':
            for(var _iterator2 = _createForOfIteratorHelperLoose(tree.args), _step2; !(_step2 = _iterator2()).done;){
                var _char = _step2.value;
                if (characters[0] === _char) {
                    if (characters.length === 1) {
                        return {
                            match: true,
                            matchedChars: characters
                        };
                    }
                    if (last) {
                        return {
                            overflow: true
                        };
                    }
                    return {
                        match: true,
                        matchedChars: [
                            _char
                        ]
                    };
                }
            }
            // No character matches.
            return;
        /* istanbul ignore next */ default:
            throw new Error("Unsupported instruction tree: ".concat(tree));
    }
} //# sourceMappingURL=AsYouTypeFormatter.PatternMatcher.js.map
}),
"[project]/node_modules/libphonenumber-js/es6/AsYouTypeFormatter.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>AsYouTypeFormatter
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$AsYouTypeFormatter$2e$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/libphonenumber-js/es6/AsYouTypeFormatter.util.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$AsYouTypeFormatter$2e$complete$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/libphonenumber-js/es6/AsYouTypeFormatter.complete.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$AsYouTypeFormatter$2e$PatternMatcher$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/libphonenumber-js/es6/AsYouTypeFormatter.PatternMatcher.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$helpers$2f$parseDigits$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/libphonenumber-js/es6/helpers/parseDigits.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$helpers$2f$formatNationalNumberUsingFormat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/libphonenumber-js/es6/helpers/formatNationalNumberUsingFormat.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/libphonenumber-js/es6/constants.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$helpers$2f$applyInternationalSeparatorStyle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/libphonenumber-js/es6/helpers/applyInternationalSeparatorStyle.js [app-client] (ecmascript)");
function _typeof(o) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o) {
        return typeof o;
    } : function(o) {
        return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    }, _typeof(o);
}
function _createForOfIteratorHelperLoose(r, e) {
    var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
    if (t) return (t = t.call(r)).next.bind(t);
    if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) {
        t && (r = t);
        var o = 0;
        return function() {
            return o >= r.length ? {
                done: !0
            } : {
                done: !1,
                value: r[o++]
            };
        };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(r, a) {
    if (r) {
        if ("string" == typeof r) return _arrayLikeToArray(r, a);
        var t = ({}).toString.call(r).slice(8, -1);
        return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
    }
}
function _arrayLikeToArray(r, a) {
    (null == a || a > r.length) && (a = r.length);
    for(var e = 0, n = Array(a); e < a; e++)n[e] = r[e];
    return n;
}
function _classCallCheck(a, n) {
    if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(e, r) {
    for(var t = 0; t < r.length; t++){
        var o = r[t];
        o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);
    }
}
function _createClass(e, r, t) {
    return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
        writable: !1
    }), e;
}
function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return "symbol" == _typeof(i) ? i : i + "";
}
function _toPrimitive(t, r) {
    if ("object" != _typeof(t) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
;
;
;
;
;
;
;
;
// Used in phone number format template creation.
// Could be any digit, I guess.
var DUMMY_DIGIT = '9';
// I don't know why is it exactly `15`
var LONGEST_NATIONAL_PHONE_NUMBER_LENGTH = 15;
// Create a phone number consisting only of the digit 9 that matches the
// `number_pattern` by applying the pattern to the "longest phone number" string.
var LONGEST_DUMMY_PHONE_NUMBER = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$AsYouTypeFormatter$2e$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["repeat"])(DUMMY_DIGIT, LONGEST_NATIONAL_PHONE_NUMBER_LENGTH);
// A set of characters that, if found in a national prefix formatting rules, are an indicator to
// us that we should separate the national prefix from the number when formatting.
var NATIONAL_PREFIX_SEPARATORS_PATTERN = /[- ]/;
// Deprecated: Google has removed some formatting pattern related code from their repo.
// https://github.com/googlei18n/libphonenumber/commit/a395b4fef3caf57c4bc5f082e1152a4d2bd0ba4c
// "We no longer have numbers in formatting matching patterns, only \d."
// Because this library supports generating custom metadata
// some users may still be using old metadata so the relevant
// code seems to stay until some next major version update.
var SUPPORT_LEGACY_FORMATTING_PATTERNS = true;
// A pattern that is used to match character classes in regular expressions.
// An example of a character class is "[1-4]".
var CREATE_CHARACTER_CLASS_PATTERN = SUPPORT_LEGACY_FORMATTING_PATTERNS && function() {
    return /\[([^\[\]])*\]/g;
};
// Any digit in a regular expression that actually denotes a digit. For
// example, in the regular expression "80[0-2]\d{6,10}", the first 2 digits
// (8 and 0) are standalone digits, but the rest are not.
// Two look-aheads are needed because the number following \\d could be a
// two-digit number, since the phone number can be as long as 15 digits.
var CREATE_STANDALONE_DIGIT_PATTERN = SUPPORT_LEGACY_FORMATTING_PATTERNS && function() {
    return /\d(?=[^,}][^,}])/g;
};
// A regular expression that is used to determine if a `format` is
// suitable to be used in the "as you type formatter".
// A `format` is suitable when the resulting formatted number has
// the same digits as the user has entered.
//
// In the simplest case, that would mean that the format
// doesn't add any additional digits when formatting a number.
// Google says that it also shouldn't add "star" (`*`) characters,
// like it does in some Israeli formats.
// Such basic format would only contain "valid punctuation"
// and "captured group" identifiers ($1, $2, etc).
//
// An example of a format that adds additional digits:
//
// Country: `AR` (Argentina).
// Format:
// {
//    "pattern": "(\\d)(\\d{2})(\\d{4})(\\d{4})",
//    "leading_digits_patterns": ["91"],
//    "national_prefix_formatting_rule": "0$1",
//    "format": "$2 15-$3-$4",
//    "international_format": "$1 $2 $3-$4"
// }
//
// In the format above, the `format` adds `15` to the digits when formatting a number.
// A sidenote: this format actually is suitable because `national_prefix_for_parsing`
// has previously removed `15` from a national number, so re-adding `15` in `format`
// doesn't actually result in any extra digits added to user's input.
// But verifying that would be a complex procedure, so the code chooses a simpler path:
// it simply filters out all `format`s that contain anything but "captured group" ids.
//
// This regular expression is called `ELIGIBLE_FORMAT_PATTERN` in Google's
// `libphonenumber` code.
//
var NON_ALTERING_FORMAT_REG_EXP = new RegExp('[' + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VALID_PUNCTUATION"] + ']*' + // Google developers say:
// "We require that the first matching group is present in the
//  output pattern to ensure no data is lost while formatting."
'\\$1' + '[' + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VALID_PUNCTUATION"] + ']*' + '(\\$\\d[' + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VALID_PUNCTUATION"] + ']*)*' + '$');
// This is the minimum length of the leading digits of a phone number
// to guarantee the first "leading digits pattern" for a phone number format
// to be preemptive.
var MIN_LEADING_DIGITS_LENGTH = 3;
var AsYouTypeFormatter = /*#__PURE__*/ function() {
    function AsYouTypeFormatter(_ref) {
        var state = _ref.state, metadata = _ref.metadata;
        _classCallCheck(this, AsYouTypeFormatter);
        this.metadata = metadata;
        this.resetFormat();
    }
    return _createClass(AsYouTypeFormatter, [
        {
            key: "resetFormat",
            value: function resetFormat() {
                this.chosenFormat = undefined;
                this.template = undefined;
                this.nationalNumberTemplate = undefined;
                this.populatedNationalNumberTemplate = undefined;
                this.populatedNationalNumberTemplatePosition = -1;
            }
        },
        {
            key: "reset",
            value: function reset(numberingPlan, state) {
                this.resetFormat();
                if (numberingPlan) {
                    this.isNANP = numberingPlan.callingCode() === '1';
                    this.matchingFormats = numberingPlan.formats();
                    if (state.nationalSignificantNumber) {
                        this.narrowDownMatchingFormats(state);
                    }
                } else {
                    this.isNANP = undefined;
                    this.matchingFormats = [];
                }
            }
        },
        {
            key: "format",
            value: function format(nextDigits, state) {
                var _this = this;
                // See if the phone number digits can be formatted as a complete phone number.
                // If not, use the results from `formatNationalNumberWithNextDigits()`,
                // which formats based on the chosen formatting pattern.
                //
                // Attempting to format complete phone number first is how it's done
                // in Google's `libphonenumber`, so this library just follows it.
                // Google's `libphonenumber` code doesn't explain in detail why does it
                // attempt to format digits as a complete phone number
                // instead of just going with a previoulsy (or newly) chosen `format`:
                //
                // "Checks to see if there is an exact pattern match for these digits.
                //  If so, we should use this instead of any other formatting template
                //  whose leadingDigitsPattern also matches the input."
                //
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$AsYouTypeFormatter$2e$complete$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["canFormatCompleteNumber"])(state.nationalSignificantNumber, state.country, this.metadata)) {
                    for(var _iterator = _createForOfIteratorHelperLoose(this.matchingFormats), _step; !(_step = _iterator()).done;){
                        var _format = _step.value;
                        var formattedCompleteNumber = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$AsYouTypeFormatter$2e$complete$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(state, _format, {
                            metadata: this.metadata,
                            shouldTryNationalPrefixFormattingRule: function shouldTryNationalPrefixFormattingRule(format) {
                                return _this.shouldTryNationalPrefixFormattingRule(format, {
                                    international: state.international,
                                    nationalPrefix: state.nationalPrefix
                                });
                            },
                            getSeparatorAfterNationalPrefix: function getSeparatorAfterNationalPrefix(format) {
                                return _this.getSeparatorAfterNationalPrefix(format);
                            }
                        });
                        if (formattedCompleteNumber) {
                            this.resetFormat();
                            this.chosenFormat = _format;
                            this.setNationalNumberTemplate(formattedCompleteNumber.replace(/\d/g, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$AsYouTypeFormatter$2e$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIGIT_PLACEHOLDER"]), state);
                            this.populatedNationalNumberTemplate = formattedCompleteNumber;
                            // With a new formatting template, the matched position
                            // using the old template needs to be reset.
                            this.populatedNationalNumberTemplatePosition = this.template.lastIndexOf(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$AsYouTypeFormatter$2e$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIGIT_PLACEHOLDER"]);
                            return formattedCompleteNumber;
                        }
                    }
                }
                // Format the digits as a partial (incomplete) phone number
                // using the previously chosen formatting pattern (or a newly chosen one).
                return this.formatNationalNumberWithNextDigits(nextDigits, state);
            }
        },
        {
            key: "formatNationalNumberWithNextDigits",
            value: function formatNationalNumberWithNextDigits(nextDigits, state) {
                var previouslyChosenFormat = this.chosenFormat;
                // Choose a format from the list of matching ones.
                var newlyChosenFormat = this.chooseFormat(state);
                if (newlyChosenFormat) {
                    if (newlyChosenFormat === previouslyChosenFormat) {
                        // If it can format the next (current) digits
                        // using the previously chosen phone number format
                        // then return the updated formatted number.
                        return this.formatNextNationalNumberDigits(nextDigits);
                    } else {
                        // If a more appropriate phone number format
                        // has been chosen for these "leading digits",
                        // then re-format the national phone number part
                        // using the newly selected format.
                        return this.formatNextNationalNumberDigits(state.getNationalDigits());
                    }
                }
            }
        },
        {
            key: "narrowDownMatchingFormats",
            value: function narrowDownMatchingFormats(_ref2) {
                var _this2 = this;
                var nationalSignificantNumber = _ref2.nationalSignificantNumber, nationalPrefix = _ref2.nationalPrefix, international = _ref2.international;
                var leadingDigits = nationalSignificantNumber;
                // "leading digits" pattern list starts with a
                // "leading digits" pattern fitting a maximum of 3 leading digits.
                // So, after a user inputs 3 digits of a national (significant) phone number
                // this national (significant) number can already be formatted.
                // The next "leading digits" pattern is for 4 leading digits max,
                // and the "leading digits" pattern after it is for 5 leading digits max, etc.
                // This implementation is different from Google's
                // in that it searches for a fitting format
                // even if the user has entered less than
                // `MIN_LEADING_DIGITS_LENGTH` digits of a national number.
                // Because some leading digit patterns already match for a single first digit.
                var leadingDigitsPatternIndex = leadingDigits.length - MIN_LEADING_DIGITS_LENGTH;
                if (leadingDigitsPatternIndex < 0) {
                    leadingDigitsPatternIndex = 0;
                }
                this.matchingFormats = this.matchingFormats.filter(function(format) {
                    return _this2.formatSuits(format, international, nationalPrefix) && _this2.formatMatches(format, leadingDigits, leadingDigitsPatternIndex);
                });
                // If there was a phone number format chosen
                // and it no longer holds given the new leading digits then reset it.
                // The test for this `if` condition is marked as:
                // "Reset a chosen format when it no longer holds given the new leading digits".
                // To construct a valid test case for this one can find a country
                // in `PhoneNumberMetadata.xml` yielding one format for 3 `<leadingDigits>`
                // and yielding another format for 4 `<leadingDigits>` (Australia in this case).
                if (this.chosenFormat && this.matchingFormats.indexOf(this.chosenFormat) === -1) {
                    this.resetFormat();
                }
            }
        },
        {
            key: "formatSuits",
            value: function formatSuits(format, international, nationalPrefix) {
                // When a prefix before a national (significant) number is
                // simply a national prefix, then it's parsed as `this.nationalPrefix`.
                // In more complex cases, a prefix before national (significant) number
                // could include a national prefix as well as some "capturing groups",
                // and in that case there's no info whether a national prefix has been parsed.
                // If national prefix is not used when formatting a phone number
                // using this format, but a national prefix has been entered by the user,
                // and was extracted, then discard such phone number format.
                // In Google's "AsYouType" formatter code, the equivalent would be this part:
                // https://github.com/google/libphonenumber/blob/0a45cfd96e71cad8edb0e162a70fcc8bd9728933/java/libphonenumber/src/com/google/i18n/phonenumbers/AsYouTypeFormatter.java#L175-L184
                if (nationalPrefix && !format.usesNationalPrefix() && // !format.domesticCarrierCodeFormattingRule() &&
                !format.nationalPrefixIsOptionalWhenFormattingInNationalFormat()) {
                    return false;
                }
                // If national prefix is mandatory for this phone number format
                // and there're no guarantees that a national prefix is present in user input
                // then discard this phone number format as not suitable.
                // In Google's "AsYouType" formatter code, the equivalent would be this part:
                // https://github.com/google/libphonenumber/blob/0a45cfd96e71cad8edb0e162a70fcc8bd9728933/java/libphonenumber/src/com/google/i18n/phonenumbers/AsYouTypeFormatter.java#L185-L193
                if (!international && !nationalPrefix && format.nationalPrefixIsMandatoryWhenFormattingInNationalFormat()) {
                    return false;
                }
                return true;
            }
        },
        {
            key: "formatMatches",
            value: function formatMatches(format, leadingDigits, leadingDigitsPatternIndex) {
                var leadingDigitsPatternsCount = format.leadingDigitsPatterns().length;
                // If this format is not restricted to a certain
                // leading digits pattern then it fits.
                // The test case could be found by searching for "leadingDigitsPatternsCount === 0".
                if (leadingDigitsPatternsCount === 0) {
                    return true;
                }
                // Start narrowing down the list of possible formats based on the leading digits.
                // (only previously matched formats take part in the narrowing down process)
                // `leading_digits_patterns` start with 3 digits min
                // and then go up from there one digit at a time.
                leadingDigitsPatternIndex = Math.min(leadingDigitsPatternIndex, leadingDigitsPatternsCount - 1);
                var leadingDigitsPattern = format.leadingDigitsPatterns()[leadingDigitsPatternIndex];
                // Google imposes a requirement on the leading digits
                // to be minimum 3 digits long in order to be eligible
                // for checking those with a leading digits pattern.
                //
                // Since `leading_digits_patterns` start with 3 digits min,
                // Google's original `libphonenumber` library only starts
                // excluding any non-matching formats only when the
                // national number entered so far is at least 3 digits long,
                // otherwise format matching would give false negatives.
                //
                // For example, when the digits entered so far are `2`
                // and the leading digits pattern is `21` 
                // it's quite obvious in this case that the format could be the one
                // but due to the absence of further digits it would give false negative.
                //
                // Also, `leading_digits_patterns` doesn't always correspond to a single
                // digits count. For example, `60|8` pattern would already match `8`
                // but the `60` part would require having at least two leading digits,
                // so the whole pattern would require inputting two digits first in order to
                // decide on whether it matches the input, even when the input is "80".
                //
                // This library  `libphonenumber-js`  allows filtering by `leading_digits_patterns`
                // even when there's only 1 or 2 digits of the national (significant) number.
                // To do that, it uses a non-strict pattern matcher written specifically for that.
                //
                if (leadingDigits.length < MIN_LEADING_DIGITS_LENGTH) {
                    // Before leading digits < 3 matching was implemented:
                    // return true
                    //
                    // After leading digits < 3 matching was implemented:
                    try {
                        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$AsYouTypeFormatter$2e$PatternMatcher$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](leadingDigitsPattern).match(leadingDigits, {
                            allowOverflow: true
                        }) !== undefined;
                    } catch (error) /* istanbul ignore next */ {
                        // There's a slight possibility that there could be some undiscovered bug
                        // in the pattern matcher code. Since the "leading digits < 3 matching"
                        // feature is not "essential" for operation, it can fall back to the old way
                        // in case of any issues rather than halting the application's execution.
                        console.error(error);
                        return true;
                    }
                }
                // If at least `MIN_LEADING_DIGITS_LENGTH` digits of a national number are
                // available then use the usual regular expression matching.
                //
                // The whole pattern is wrapped in round brackets (`()`) because
                // the pattern can use "or" operator (`|`) at the top level of the pattern.
                //
                return new RegExp("^(".concat(leadingDigitsPattern, ")")).test(leadingDigits);
            }
        },
        {
            key: "getFormatFormat",
            value: function getFormatFormat(format, international) {
                return international ? format.internationalFormat() : format.format();
            }
        },
        {
            key: "chooseFormat",
            value: function chooseFormat(state) {
                var _this3 = this;
                var _loop = function _loop() {
                    var format = _step2.value;
                    // If this format is currently being used
                    // and is still suitable, then stick to it.
                    if (_this3.chosenFormat === format) {
                        return 0; // break
                    }
                    // Sometimes, a formatting rule inserts additional digits in a phone number,
                    // and "as you type" formatter can't do that: it should only use the digits
                    // that the user has input.
                    //
                    // For example, in Argentina, there's a format for mobile phone numbers:
                    //
                    // {
                    //    "pattern": "(\\d)(\\d{2})(\\d{4})(\\d{4})",
                    //    "leading_digits_patterns": ["91"],
                    //    "national_prefix_formatting_rule": "0$1",
                    //    "format": "$2 15-$3-$4",
                    //    "international_format": "$1 $2 $3-$4"
                    // }
                    //
                    // In that format, `international_format` is used instead of `format`
                    // because `format` inserts `15` in the formatted number,
                    // and `AsYouType` formatter should only use the digits
                    // the user has actually input, without adding any extra digits.
                    // In this case, it wouldn't make a difference, because the `15`
                    // is first stripped when applying `national_prefix_for_parsing`
                    // and then re-added when using `format`, so in reality it doesn't
                    // add any new digits to the number, but to detect that, the code
                    // would have to be more complex: it would have to try formatting
                    // the digits using the format and then see if any digits have
                    // actually been added or removed, and then, every time a new digit
                    // is input, it should re-check whether the chosen format doesn't
                    // alter the digits.
                    //
                    // Google's code doesn't go that far, and so does this library:
                    // it simply requires that a `format` doesn't add any additonal
                    // digits to user's input.
                    //
                    // Also, people in general should move from inputting phone numbers
                    // in national format (possibly with national prefixes)
                    // and use international phone number format instead:
                    // it's a logical thing in the modern age of mobile phones,
                    // globalization and the internet.
                    //
                    /* istanbul ignore if */ if (!NON_ALTERING_FORMAT_REG_EXP.test(_this3.getFormatFormat(format, state.international))) {
                        return 1; // continue
                    }
                    if (!_this3.createTemplateForFormat(format, state)) {
                        // Remove the format if it can't generate a template.
                        _this3.matchingFormats = _this3.matchingFormats.filter(function(_) {
                            return _ !== format;
                        });
                        return 1; // continue
                    }
                    _this3.chosenFormat = format;
                    return 0; // break
                }, _ret;
                // When there are multiple available formats, the formatter uses the first
                // format where a formatting template could be created.
                //
                // For some weird reason, `istanbul` says "else path not taken"
                // for the `for of` line below. Supposedly that means that
                // the loop doesn't ever go over the last element in the list.
                // That's true because there always is `this.chosenFormat`
                // when `this.matchingFormats` is non-empty.
                // And, for some weird reason, it doesn't think that the case
                // with empty `this.matchingFormats` qualifies for a valid "else" path.
                // So simply muting this `istanbul` warning.
                // It doesn't skip the contents of the `for of` loop,
                // it just skips the `for of` line.
                //
                /* istanbul ignore next */ for(var _iterator2 = _createForOfIteratorHelperLoose(this.matchingFormats.slice()), _step2; !(_step2 = _iterator2()).done;){
                    _ret = _loop();
                    if (_ret === 0) break;
                    if (_ret === 1) continue;
                }
                if (!this.chosenFormat) {
                    // No format matches the national (significant) phone number.
                    this.resetFormat();
                }
                return this.chosenFormat;
            }
        },
        {
            key: "createTemplateForFormat",
            value: function createTemplateForFormat(format, state) {
                // The formatter doesn't format numbers when numberPattern contains '|', e.g.
                // (20|3)\d{4}. In those cases we quickly return.
                // (Though there's no such format in current metadata)
                /* istanbul ignore if */ if (SUPPORT_LEGACY_FORMATTING_PATTERNS && format.pattern().indexOf('|') >= 0) {
                    return;
                }
                // Get formatting template for this phone number format
                var template = this.getTemplateForFormat(format, state);
                // If the national number entered is too long
                // for any phone number format, then abort.
                if (template) {
                    this.setNationalNumberTemplate(template, state);
                    return true;
                }
            }
        },
        {
            key: "getSeparatorAfterNationalPrefix",
            value: function getSeparatorAfterNationalPrefix(format) {
                // `US` metadata doesn't have a `national_prefix_formatting_rule`,
                // so the `if` condition below doesn't apply to `US`,
                // but in reality there shoudl be a separator
                // between a national prefix and a national (significant) number.
                // So `US` national prefix separator is a "special" "hardcoded" case.
                if (this.isNANP) {
                    return ' ';
                }
                // If a `format` has a `national_prefix_formatting_rule`
                // and that rule has a separator after a national prefix,
                // then it means that there should be a separator
                // between a national prefix and a national (significant) number.
                if (format && format.nationalPrefixFormattingRule() && NATIONAL_PREFIX_SEPARATORS_PATTERN.test(format.nationalPrefixFormattingRule())) {
                    return ' ';
                }
                // At this point, there seems to be no clear evidence that
                // there should be a separator between a national prefix
                // and a national (significant) number. So don't insert one.
                return '';
            }
        },
        {
            key: "getInternationalPrefixBeforeCountryCallingCode",
            value: function getInternationalPrefixBeforeCountryCallingCode(_ref3, options) {
                var IDDPrefix = _ref3.IDDPrefix, missingPlus = _ref3.missingPlus;
                if (IDDPrefix) {
                    return options && options.spacing === false ? IDDPrefix : IDDPrefix + ' ';
                }
                if (missingPlus) {
                    return '';
                }
                return '+';
            }
        },
        {
            key: "getTemplate",
            value: function getTemplate(state) {
                if (!this.template) {
                    return;
                }
                // `this.template` holds the template for a "complete" phone number.
                // The currently entered phone number is most likely not "complete",
                // so trim all non-populated digits.
                var index = -1;
                var i = 0;
                var internationalPrefix = state.international ? this.getInternationalPrefixBeforeCountryCallingCode(state, {
                    spacing: false
                }) : '';
                while(i < internationalPrefix.length + state.getDigitsWithoutInternationalPrefix().length){
                    index = this.template.indexOf(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$AsYouTypeFormatter$2e$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIGIT_PLACEHOLDER"], index + 1);
                    i++;
                }
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$AsYouTypeFormatter$2e$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cutAndStripNonPairedParens"])(this.template, index + 1);
            }
        },
        {
            key: "setNationalNumberTemplate",
            value: function setNationalNumberTemplate(template, state) {
                this.nationalNumberTemplate = template;
                this.populatedNationalNumberTemplate = template;
                // With a new formatting template, the matched position
                // using the old template needs to be reset.
                this.populatedNationalNumberTemplatePosition = -1;
                // For convenience, the public `.template` property
                // contains the whole international number
                // if the phone number being input is international:
                // 'x' for the '+' sign, 'x'es for the country phone code,
                // a spacebar and then the template for the formatted national number.
                if (state.international) {
                    this.template = this.getInternationalPrefixBeforeCountryCallingCode(state).replace(/[\d\+]/g, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$AsYouTypeFormatter$2e$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIGIT_PLACEHOLDER"]) + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$AsYouTypeFormatter$2e$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["repeat"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$AsYouTypeFormatter$2e$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIGIT_PLACEHOLDER"], state.callingCode.length) + ' ' + template;
                } else {
                    this.template = template;
                }
            }
        },
        {
            key: "getTemplateForFormat",
            value: function getTemplateForFormat(format, _ref4) {
                var nationalSignificantNumber = _ref4.nationalSignificantNumber, international = _ref4.international, nationalPrefix = _ref4.nationalPrefix, prefixBeforeNationalSignificantNumberThatIsNotNationalPrefix = _ref4.prefixBeforeNationalSignificantNumberThatIsNotNationalPrefix;
                var pattern = format.pattern();
                /* istanbul ignore else */ if ("TURBOPACK compile-time truthy", 1) {
                    pattern = pattern// Replace anything in the form of [..] with \d
                    .replace(CREATE_CHARACTER_CLASS_PATTERN(), '\\d')// Replace any standalone digit (not the one in `{}`) with \d
                    .replace(CREATE_STANDALONE_DIGIT_PATTERN(), '\\d');
                }
                // Generate a dummy national number (consisting of `9`s)
                // that fits this format's `pattern`.
                //
                // This match will always succeed,
                // because the "longest dummy phone number"
                // has enough length to accomodate any possible
                // national phone number format pattern.
                //
                var digits = LONGEST_DUMMY_PHONE_NUMBER.match(pattern)[0];
                // If the national number entered is too long
                // for any phone number format, then abort.
                if (nationalSignificantNumber.length > digits.length) {
                    return;
                }
                // Get a formatting template which can be used to efficiently format
                // a partial number where digits are added one by one.
                // Below `strictPattern` is used for the
                // regular expression (with `^` and `$`).
                // This wasn't originally in Google's `libphonenumber`
                // and I guess they don't really need it
                // because they're not using "templates" to format phone numbers
                // but I added `strictPattern` after encountering
                // South Korean phone number formatting bug.
                //
                // Non-strict regular expression bug demonstration:
                //
                // this.nationalSignificantNumber : `111111111` (9 digits)
                //
                // pattern : (\d{2})(\d{3,4})(\d{4})
                // format : `$1 $2 $3`
                // digits : `9999999999` (10 digits)
                //
                // '9999999999'.replace(new RegExp(/(\d{2})(\d{3,4})(\d{4})/g), '$1 $2 $3') = "99 9999 9999"
                //
                // template : xx xxxx xxxx
                //
                // But the correct template in this case is `xx xxx xxxx`.
                // The template was generated incorrectly because of the
                // `{3,4}` variability in the `pattern`.
                //
                // The fix is, if `this.nationalSignificantNumber` has already sufficient length
                // to satisfy the `pattern` completely then `this.nationalSignificantNumber`
                // is used instead of `digits`.
                var strictPattern = new RegExp('^' + pattern + '$');
                var nationalNumberDummyDigits = nationalSignificantNumber.replace(/\d/g, DUMMY_DIGIT);
                // If `this.nationalSignificantNumber` has already sufficient length
                // to satisfy the `pattern` completely then use it
                // instead of `digits`.
                if (strictPattern.test(nationalNumberDummyDigits)) {
                    digits = nationalNumberDummyDigits;
                }
                var numberFormat = this.getFormatFormat(format, international);
                var nationalPrefixIncludedInTemplate;
                // If a user did input a national prefix (and that's guaranteed),
                // and if a `format` does have a national prefix formatting rule,
                // then see if that national prefix formatting rule
                // prepends exactly the same national prefix the user has input.
                // If that's the case, then use the `format` with the national prefix formatting rule.
                // Otherwise, use  the `format` without the national prefix formatting rule,
                // and prepend a national prefix manually to it.
                if (this.shouldTryNationalPrefixFormattingRule(format, {
                    international: international,
                    nationalPrefix: nationalPrefix
                })) {
                    var numberFormatWithNationalPrefix = numberFormat.replace(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$helpers$2f$formatNationalNumberUsingFormat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FIRST_GROUP_PATTERN"], format.nationalPrefixFormattingRule());
                    // If `national_prefix_formatting_rule` of a `format` simply prepends
                    // national prefix at the start of a national (significant) number,
                    // then such formatting can be used with `AsYouType` formatter.
                    // There seems to be no `else` case: everywhere in metadata,
                    // national prefix formatting rule is national prefix + $1,
                    // or `($1)`, in which case such format isn't even considered
                    // when the user has input a national prefix.
                    /* istanbul ignore else */ if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$helpers$2f$parseDigits$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(format.nationalPrefixFormattingRule()) === (nationalPrefix || '') + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$helpers$2f$parseDigits$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])('$1')) {
                        numberFormat = numberFormatWithNationalPrefix;
                        nationalPrefixIncludedInTemplate = true;
                        // Replace all digits of the national prefix in the formatting template
                        // with `DIGIT_PLACEHOLDER`s.
                        if (nationalPrefix) {
                            var i = nationalPrefix.length;
                            while(i > 0){
                                numberFormat = numberFormat.replace(/\d/, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$AsYouTypeFormatter$2e$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIGIT_PLACEHOLDER"]);
                                i--;
                            }
                        }
                    }
                }
                // Generate formatting template for this phone number format.
                var template = digits// Format the dummy phone number according to the format.
                .replace(new RegExp(pattern), numberFormat)// Replace each dummy digit with a DIGIT_PLACEHOLDER.
                .replace(new RegExp(DUMMY_DIGIT, 'g'), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$AsYouTypeFormatter$2e$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIGIT_PLACEHOLDER"]);
                // If a prefix of a national (significant) number is not as simple
                // as just a basic national prefix, then just prepend such prefix
                // before the national (significant) number, optionally spacing
                // the two with a whitespace.
                if (!nationalPrefixIncludedInTemplate) {
                    if (prefixBeforeNationalSignificantNumberThatIsNotNationalPrefix) {
                        // Prepend the prefix to the template manually.
                        template = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$AsYouTypeFormatter$2e$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["repeat"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$AsYouTypeFormatter$2e$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIGIT_PLACEHOLDER"], prefixBeforeNationalSignificantNumberThatIsNotNationalPrefix.length) + ' ' + template;
                    } else if (nationalPrefix) {
                        // Prepend national prefix to the template manually.
                        template = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$AsYouTypeFormatter$2e$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["repeat"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$AsYouTypeFormatter$2e$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIGIT_PLACEHOLDER"], nationalPrefix.length) + this.getSeparatorAfterNationalPrefix(format) + template;
                    }
                }
                if (international) {
                    template = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$helpers$2f$applyInternationalSeparatorStyle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(template);
                }
                return template;
            }
        },
        {
            key: "formatNextNationalNumberDigits",
            value: function formatNextNationalNumberDigits(digits) {
                var result = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$AsYouTypeFormatter$2e$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["populateTemplateWithDigits"])(this.populatedNationalNumberTemplate, this.populatedNationalNumberTemplatePosition, digits);
                if (!result) {
                    // Reset the format.
                    this.resetFormat();
                    return;
                }
                this.populatedNationalNumberTemplate = result[0];
                this.populatedNationalNumberTemplatePosition = result[1];
                // Return the formatted phone number so far.
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$AsYouTypeFormatter$2e$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cutAndStripNonPairedParens"])(this.populatedNationalNumberTemplate, this.populatedNationalNumberTemplatePosition + 1);
            // The old way which was good for `input-format` but is not so good
            // for `react-phone-number-input`'s default input (`InputBasic`).
            // return closeNonPairedParens(this.populatedNationalNumberTemplate, this.populatedNationalNumberTemplatePosition + 1)
            // 	.replace(new RegExp(DIGIT_PLACEHOLDER, 'g'), ' ')
            }
        },
        {
            key: "shouldTryNationalPrefixFormattingRule",
            value: function shouldTryNationalPrefixFormattingRule(format, _ref5) {
                var international = _ref5.international, nationalPrefix = _ref5.nationalPrefix;
                if (format.nationalPrefixFormattingRule()) {
                    // In some countries, `national_prefix_formatting_rule` is `($1)`,
                    // so it applies even if the user hasn't input a national prefix.
                    // `format.usesNationalPrefix()` detects such cases.
                    var usesNationalPrefix = format.usesNationalPrefix();
                    if (usesNationalPrefix && nationalPrefix || !usesNationalPrefix && !international) {
                        return true;
                    }
                }
            }
        }
    ]);
}();
;
 //# sourceMappingURL=AsYouTypeFormatter.js.map
}),
"[project]/node_modules/libphonenumber-js/es6/AsYouTypeParser.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>AsYouTypeParser,
    "extractFormattedDigitsAndPlus",
    ()=>extractFormattedDigitsAndPlus
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$helpers$2f$extractCountryCallingCode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/libphonenumber-js/es6/helpers/extractCountryCallingCode.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$helpers$2f$extractCountryCallingCodeFromInternationalNumberWithoutPlusSign$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/libphonenumber-js/es6/helpers/extractCountryCallingCodeFromInternationalNumberWithoutPlusSign.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$helpers$2f$extractNationalNumberFromPossiblyIncompleteNumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/libphonenumber-js/es6/helpers/extractNationalNumberFromPossiblyIncompleteNumber.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$helpers$2f$stripIddPrefix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/libphonenumber-js/es6/helpers/stripIddPrefix.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$helpers$2f$parseDigits$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/libphonenumber-js/es6/helpers/parseDigits.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/libphonenumber-js/es6/constants.js [app-client] (ecmascript)");
function _typeof(o) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o) {
        return typeof o;
    } : function(o) {
        return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    }, _typeof(o);
}
function _slicedToArray(r, e) {
    return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();
}
function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(r, a) {
    if (r) {
        if ("string" == typeof r) return _arrayLikeToArray(r, a);
        var t = ({}).toString.call(r).slice(8, -1);
        return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
    }
}
function _arrayLikeToArray(r, a) {
    (null == a || a > r.length) && (a = r.length);
    for(var e = 0, n = Array(a); e < a; e++)n[e] = r[e];
    return n;
}
function _iterableToArrayLimit(r, l) {
    var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
    if (null != t) {
        var e, n, i, u, a = [], f = !0, o = !1;
        try {
            if (i = (t = t.call(r)).next, 0 === l) {
                if (Object(t) !== t) return;
                f = !1;
            } else for(; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);
        } catch (r) {
            o = !0, n = r;
        } finally{
            try {
                if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
            } finally{
                if (o) throw n;
            }
        }
        return a;
    }
}
function _arrayWithHoles(r) {
    if (Array.isArray(r)) return r;
}
function _classCallCheck(a, n) {
    if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(e, r) {
    for(var t = 0; t < r.length; t++){
        var o = r[t];
        o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);
    }
}
function _createClass(e, r, t) {
    return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
        writable: !1
    }), e;
}
function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return "symbol" == _typeof(i) ? i : i + "";
}
function _toPrimitive(t, r) {
    if ("object" != _typeof(t) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
;
;
;
;
;
;
var VALID_FORMATTED_PHONE_NUMBER_DIGITS_PART = '[' + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VALID_PUNCTUATION"] + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VALID_DIGITS"] + ']+';
var VALID_FORMATTED_PHONE_NUMBER_DIGITS_PART_PATTERN = new RegExp('^' + VALID_FORMATTED_PHONE_NUMBER_DIGITS_PART + '$', 'i');
var VALID_FORMATTED_PHONE_NUMBER_PART = '(?:' + '[' + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PLUS_CHARS"] + ']' + '[' + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VALID_PUNCTUATION"] + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VALID_DIGITS"] + ']*' + '|' + '[' + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VALID_PUNCTUATION"] + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VALID_DIGITS"] + ']+' + ')';
var AFTER_PHONE_NUMBER_DIGITS_END_PATTERN = new RegExp('[^' + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VALID_PUNCTUATION"] + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VALID_DIGITS"] + ']+' + '.*' + '$');
// Tests whether `national_prefix_for_parsing` could match
// different national prefixes.
// Matches anything that's not a digit or a square bracket.
var COMPLEX_NATIONAL_PREFIX = /[^\d\[\]]/;
var AsYouTypeParser = /*#__PURE__*/ function() {
    function AsYouTypeParser(_ref) {
        var defaultCountry = _ref.defaultCountry, defaultCallingCode = _ref.defaultCallingCode, metadata = _ref.metadata, onNationalSignificantNumberChange = _ref.onNationalSignificantNumberChange;
        _classCallCheck(this, AsYouTypeParser);
        this.defaultCountry = defaultCountry;
        this.defaultCallingCode = defaultCallingCode;
        this.metadata = metadata;
        this.onNationalSignificantNumberChange = onNationalSignificantNumberChange;
    }
    return _createClass(AsYouTypeParser, [
        {
            key: "input",
            value: function input(text, state) {
                var _extractFormattedDigi = extractFormattedDigitsAndPlus(text), _extractFormattedDigi2 = _slicedToArray(_extractFormattedDigi, 2), formattedDigits = _extractFormattedDigi2[0], hasPlus = _extractFormattedDigi2[1];
                var digits = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$helpers$2f$parseDigits$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(formattedDigits);
                // Checks for a special case: just a leading `+` has been entered.
                var justLeadingPlus;
                if (hasPlus) {
                    if (!state.digits) {
                        state.startInternationalNumber(undefined, undefined);
                        if (!digits) {
                            justLeadingPlus = true;
                        }
                    }
                }
                if (digits) {
                    this.inputDigits(digits, state);
                }
                return {
                    digits: digits,
                    justLeadingPlus: justLeadingPlus
                };
            }
        },
        {
            key: "inputDigits",
            value: function inputDigits(nextDigits, state) {
                var digits = state.digits;
                var hasReceivedThreeLeadingDigits = digits.length < 3 && digits.length + nextDigits.length >= 3;
                // Append phone number digits.
                state.appendDigits(nextDigits);
                // Attempt to extract IDD prefix:
                // Some users input their phone number in international format,
                // but in an "out-of-country" dialing format instead of using the leading `+`.
                // https://github.com/catamphetamine/libphonenumber-js/issues/185
                // Detect such numbers as soon as there're at least 3 digits.
                // Google's library attempts to extract IDD prefix at 3 digits,
                // so this library just copies that behavior.
                // I guess that's because the most commot IDD prefixes are
                // `00` (Europe) and `011` (US).
                // There exist really long IDD prefixes too:
                // for example, in Australia the default IDD prefix is `0011`,
                // and it could even be as long as `14880011`.
                // An IDD prefix is extracted here, and then every time when
                // there's a new digit and the number couldn't be formatted.
                if (hasReceivedThreeLeadingDigits) {
                    this.extractIddPrefix(state);
                }
                if (this.isWaitingForCountryCallingCode(state)) {
                    if (!this.extractCountryCallingCode(state)) {
                        return;
                    }
                } else {
                    state.appendNationalSignificantNumberDigits(nextDigits);
                }
                // If a phone number is being input in international format,
                // then it's not valid for it to have a national prefix.
                // Still, some people incorrectly input such numbers with a national prefix.
                // In such cases, only attempt to strip a national prefix if the number becomes too long.
                // (but that is done later, not here)
                if (!state.international) {
                    if (!this.hasExtractedNationalSignificantNumber) {
                        this.extractNationalSignificantNumber(state.getNationalDigits(), function(stateUpdate) {
                            return state.update(stateUpdate);
                        });
                    }
                }
            }
        },
        {
            key: "isWaitingForCountryCallingCode",
            value: function isWaitingForCountryCallingCode(_ref2) {
                var international = _ref2.international, callingCode = _ref2.callingCode;
                return international && !callingCode;
            }
        },
        {
            key: "extractCountryCallingCode",
            value: function extractCountryCallingCode(state) {
                var _extractCountryCallin = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$helpers$2f$extractCountryCallingCode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])('+' + state.getDigitsWithoutInternationalPrefix(), state.country, this.defaultCountry, this.defaultCallingCode, this.metadata.metadata), countryCallingCode = _extractCountryCallin.countryCallingCode, number = _extractCountryCallin.number;
                if (countryCallingCode) {
                    state.setCallingCode(countryCallingCode);
                    state.update({
                        nationalSignificantNumber: number
                    });
                    return true;
                }
            }
        },
        {
            key: "reset",
            value: function reset(numberingPlan) {
                if (numberingPlan) {
                    this.hasSelectedNumberingPlan = true;
                    var nationalPrefixForParsing = numberingPlan._nationalPrefixForParsing();
                    this.couldPossiblyExtractAnotherNationalSignificantNumber = nationalPrefixForParsing && COMPLEX_NATIONAL_PREFIX.test(nationalPrefixForParsing);
                } else {
                    this.hasSelectedNumberingPlan = undefined;
                    this.couldPossiblyExtractAnotherNationalSignificantNumber = undefined;
                }
            }
        },
        {
            key: "extractNationalSignificantNumber",
            value: function extractNationalSignificantNumber(nationalDigits, setState) {
                if (!this.hasSelectedNumberingPlan) {
                    return;
                }
                var _extractNationalNumbe = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$helpers$2f$extractNationalNumberFromPossiblyIncompleteNumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(nationalDigits, this.metadata), nationalPrefix = _extractNationalNumbe.nationalPrefix, nationalNumber = _extractNationalNumbe.nationalNumber, carrierCode = _extractNationalNumbe.carrierCode;
                if (nationalNumber === nationalDigits) {
                    return;
                }
                this.onExtractedNationalNumber(nationalPrefix, carrierCode, nationalNumber, nationalDigits, setState);
                return true;
            }
        },
        {
            key: "extractAnotherNationalSignificantNumber",
            value: function extractAnotherNationalSignificantNumber(nationalDigits, prevNationalSignificantNumber, setState) {
                if (!this.hasExtractedNationalSignificantNumber) {
                    return this.extractNationalSignificantNumber(nationalDigits, setState);
                }
                if (!this.couldPossiblyExtractAnotherNationalSignificantNumber) {
                    return;
                }
                var _extractNationalNumbe2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$helpers$2f$extractNationalNumberFromPossiblyIncompleteNumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(nationalDigits, this.metadata), nationalPrefix = _extractNationalNumbe2.nationalPrefix, nationalNumber = _extractNationalNumbe2.nationalNumber, carrierCode = _extractNationalNumbe2.carrierCode;
                // If a national prefix has been extracted previously,
                // then it's always extracted as additional digits are added.
                // That's assuming `extractNationalNumberFromPossiblyIncompleteNumber()`
                // doesn't do anything different from what it currently does.
                // So, just in case, here's this check, though it doesn't occur.
                /* istanbul ignore if */ if (nationalNumber === prevNationalSignificantNumber) {
                    return;
                }
                this.onExtractedNationalNumber(nationalPrefix, carrierCode, nationalNumber, nationalDigits, setState);
                return true;
            }
        },
        {
            key: "onExtractedNationalNumber",
            value: function onExtractedNationalNumber(nationalPrefix, carrierCode, nationalSignificantNumber, nationalDigits, setState) {
                // Tells if the parsed national (significant) number is present as-is in the input string.
                // For example, when inputting "0343515551212999" Argentinian mobile number,
                // the parsed national (significant) number is "93435551212999".
                // There, one can see how it stripped "0" national prefix and prepended a "9",
                // because that's how it is instructed to do in Argentina's metadata.
                // So in the described example, the parsed national (significant) number is not present
                // as-is in the input string. Instead, it's "modified" in the input string.
                // https://gitlab.com/catamphetamine/libphonenumber-js/-/blob/master/METADATA.md#national_prefix_for_parsing--national_prefix_transform_rule
                var nationalSignificantNumberIsModified = false;
                // In some countries, a phone number could have a prefix that is not a "national prefix"
                // but rather some other type of "utility" prefix.
                // For example, when calling within Australia, one could prepend `1831` prefix to hide
                // caller's phone number.
                // https://gitlab.com/catamphetamine/libphonenumber-js/-/blob/master/METADATA.md#national_prefix_for_parsing--national_prefix_transform_rule
                var prefixBeforeNationalSignificantNumberThatIsNotNationalPrefix;
                // `nationalSignificantNumber` could be empty. In that case, `.lastIndexOf()` still works correctly.
                var nationalSignificantNumberIndex = nationalDigits.lastIndexOf(nationalSignificantNumber);
                // If the parsed national (significant) number is the last substring of the `nationalDigits`,
                // then it means that it's present as-is in the input string.
                // In any other case, the parsed national (significant) number is "modified" in the input string.
                if (nationalSignificantNumberIndex < 0 || nationalSignificantNumberIndex !== nationalDigits.length - nationalSignificantNumber.length) {
                    nationalSignificantNumberIsModified = true;
                } else {
                    var prefixBeforeNationalNumber = nationalDigits.slice(0, nationalSignificantNumberIndex);
                    // When national (significant) number is equal to the `nationalDigits`,
                    // this `onExtractedNationalNumber()` function simply doesn't get called.
                    // This means that at this point, `prefixBeforeNationalNumber` is always non-empty.
                    // Still, added this `if` check just to prevent potential silly bugs.
                    // The `!prefixBeforeNationalNumber` case is not really testable
                    // so this line is exluded from the code coverage.
                    /* istanbul ignore if */ if (prefixBeforeNationalNumber) {
                        if (prefixBeforeNationalNumber !== nationalPrefix) {
                            prefixBeforeNationalSignificantNumberThatIsNotNationalPrefix = prefixBeforeNationalNumber;
                        }
                    }
                }
                setState({
                    nationalPrefix: nationalPrefix,
                    carrierCode: carrierCode,
                    nationalSignificantNumber: nationalSignificantNumber,
                    nationalSignificantNumberIsModified: nationalSignificantNumberIsModified,
                    prefixBeforeNationalSignificantNumberThatIsNotNationalPrefix: prefixBeforeNationalSignificantNumberThatIsNotNationalPrefix
                });
                // `onExtractedNationalNumber()` is only called when
                // the national (significant) number actually did change.
                this.hasExtractedNationalSignificantNumber = true;
                this.onNationalSignificantNumberChange();
            }
        },
        {
            key: "reExtractNationalSignificantNumber",
            value: function reExtractNationalSignificantNumber(state) {
                // Attempt to extract a national prefix.
                //
                // Some people incorrectly input national prefix
                // in an international phone number.
                // For example, some people write British phone numbers as `+44(0)...`.
                //
                // Also, in some rare cases, it is valid for a national prefix
                // to be a part of an international phone number.
                // For example, mobile phone numbers in Mexico are supposed to be
                // dialled internationally using a `1` national prefix,
                // so the national prefix will be part of an international number.
                //
                // Quote from:
                // https://www.mexperience.com/dialing-cell-phones-in-mexico/
                //
                // "Dialing a Mexican cell phone from abroad
                // When you are calling a cell phone number in Mexico from outside Mexico,
                // its necessary to dial an additional 1 after Mexicos country code
                // (which is 52) and before the area code.
                // You also ignore the 045, and simply dial the area code and the
                // cell phones number.
                //
                // If you dont add the 1, youll receive a recorded announcement
                // asking you to redial using it.
                //
                // For example, if you are calling from the USA to a cell phone
                // in Mexico City, you would dial +52  1  55  1234 5678.
                // (Note that this is different to calling a land line in Mexico City
                // from abroad, where the number dialed would be +52  55  1234 5678)".
                //
                // Google's demo output:
                // https://libphonenumber.appspot.com/phonenumberparser?number=%2b5215512345678&country=MX
                //
                if (this.extractAnotherNationalSignificantNumber(state.getNationalDigits(), state.nationalSignificantNumber, function(stateUpdate) {
                    return state.update(stateUpdate);
                })) {
                    return true;
                }
                // If no format matches the phone number, then it could be
                // "a really long IDD" (quote from a comment in Google's library).
                // An IDD prefix is first extracted when the user has entered at least 3 digits,
                // and then here  every time when there's a new digit and the number
                // couldn't be formatted.
                // For example, in Australia the default IDD prefix is `0011`,
                // and it could even be as long as `14880011`.
                //
                // Could also check `!hasReceivedThreeLeadingDigits` here
                // to filter out the case when this check duplicates the one
                // already performed when there're 3 leading digits,
                // but it's not a big deal, and in most cases there
                // will be a suitable `format` when there're 3 leading digits.
                //
                if (this.extractIddPrefix(state)) {
                    this.extractCallingCodeAndNationalSignificantNumber(state);
                    return true;
                }
                // Google's AsYouType formatter supports sort of an "autocorrection" feature
                // when it "autocorrects" numbers that have been input for a country
                // with that country's calling code.
                // Such "autocorrection" feature looks weird, but different people have been requesting it:
                // https://github.com/catamphetamine/libphonenumber-js/issues/376
                // https://github.com/catamphetamine/libphonenumber-js/issues/375
                // https://github.com/catamphetamine/libphonenumber-js/issues/316
                if (this.fixMissingPlus(state)) {
                    this.extractCallingCodeAndNationalSignificantNumber(state);
                    return true;
                }
            }
        },
        {
            key: "extractIddPrefix",
            value: function extractIddPrefix(state) {
                // An IDD prefix can't be present in a number written with a `+`.
                // Also, don't re-extract an IDD prefix if has already been extracted.
                var international = state.international, IDDPrefix = state.IDDPrefix, digits = state.digits, nationalSignificantNumber = state.nationalSignificantNumber;
                if (international || IDDPrefix) {
                    return;
                }
                // Some users input their phone number in "out-of-country"
                // dialing format instead of using the leading `+`.
                // https://github.com/catamphetamine/libphonenumber-js/issues/185
                // Detect such numbers.
                var numberWithoutIDD = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$helpers$2f$stripIddPrefix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(digits, this.defaultCountry, this.defaultCallingCode, this.metadata.metadata);
                if (numberWithoutIDD !== undefined && numberWithoutIDD !== digits) {
                    // If an IDD prefix was stripped then convert the IDD-prefixed number
                    // to international number for subsequent parsing.
                    state.update({
                        IDDPrefix: digits.slice(0, digits.length - numberWithoutIDD.length)
                    });
                    this.startInternationalNumber(state, {
                        country: undefined,
                        callingCode: undefined
                    });
                    return true;
                }
            }
        },
        {
            key: "fixMissingPlus",
            value: function fixMissingPlus(state) {
                if (!state.international) {
                    var _extractCountryCallin2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$helpers$2f$extractCountryCallingCodeFromInternationalNumberWithoutPlusSign$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(state.digits, state.country, this.defaultCountry, this.defaultCallingCode, this.metadata.metadata), newCallingCode = _extractCountryCallin2.countryCallingCode;
                    if (newCallingCode) {
                        state.update({
                            missingPlus: true
                        });
                        this.startInternationalNumber(state, {
                            country: state.country,
                            callingCode: newCallingCode
                        });
                        return true;
                    }
                }
            }
        },
        {
            key: "startInternationalNumber",
            value: function startInternationalNumber(state, _ref3) {
                var country = _ref3.country, callingCode = _ref3.callingCode;
                state.startInternationalNumber(country, callingCode);
                // If a national (significant) number has been extracted before, reset it.
                if (state.nationalSignificantNumber) {
                    state.resetNationalSignificantNumber();
                    this.onNationalSignificantNumberChange();
                    this.hasExtractedNationalSignificantNumber = undefined;
                }
            }
        },
        {
            key: "extractCallingCodeAndNationalSignificantNumber",
            value: function extractCallingCodeAndNationalSignificantNumber(state) {
                if (this.extractCountryCallingCode(state)) {
                    // `this.extractCallingCode()` is currently called when the number
                    // couldn't be formatted during the standard procedure.
                    // Normally, the national prefix would be re-extracted
                    // for an international number if such number couldn't be formatted,
                    // but since it's already not able to be formatted,
                    // there won't be yet another retry, so also extract national prefix here.
                    this.extractNationalSignificantNumber(state.getNationalDigits(), function(stateUpdate) {
                        return state.update(stateUpdate);
                    });
                }
            }
        }
    ]);
}();
;
function extractFormattedPhoneNumber(text) {
    // Attempt to extract a possible number from the string passed in.
    var startsAt = text.search(VALID_FORMATTED_PHONE_NUMBER_PART);
    if (startsAt < 0) {
        return;
    }
    // Trim everything to the left of the phone number.
    text = text.slice(startsAt);
    // Trim the `+`.
    var hasPlus;
    if (text[0] === '+') {
        hasPlus = true;
        text = text.slice('+'.length);
    }
    // Trim everything to the right of the phone number.
    text = text.replace(AFTER_PHONE_NUMBER_DIGITS_END_PATTERN, '');
    // Re-add the previously trimmed `+`.
    if (hasPlus) {
        text = '+' + text;
    }
    return text;
}
/**
 * Extracts formatted phone number digits (and a `+`) from text (if there're any).
 * @param  {string} text
 * @return {any[]}
 */ function _extractFormattedDigitsAndPlus(text) {
    // Extract a formatted phone number part from text.
    var extractedNumber = extractFormattedPhoneNumber(text) || '';
    // Trim a `+`.
    if (extractedNumber[0] === '+') {
        return [
            extractedNumber.slice('+'.length),
            true
        ];
    }
    return [
        extractedNumber
    ];
}
function extractFormattedDigitsAndPlus(text) {
    var _extractFormattedDigi3 = _extractFormattedDigitsAndPlus(text), _extractFormattedDigi4 = _slicedToArray(_extractFormattedDigi3, 2), formattedDigits = _extractFormattedDigi4[0], hasPlus = _extractFormattedDigi4[1];
    // If the extracted phone number part
    // can possibly be a part of some valid phone number
    // then parse phone number characters from a formatted phone number.
    if (!VALID_FORMATTED_PHONE_NUMBER_DIGITS_PART_PATTERN.test(formattedDigits)) {
        formattedDigits = '';
    }
    return [
        formattedDigits,
        hasPlus
    ];
} //# sourceMappingURL=AsYouTypeParser.js.map
}),
"[project]/node_modules/libphonenumber-js/es6/AsYouType.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>AsYouType
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$metadata$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/libphonenumber-js/es6/metadata.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$PhoneNumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/libphonenumber-js/es6/PhoneNumber.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$AsYouTypeState$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/libphonenumber-js/es6/AsYouTypeState.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$AsYouTypeFormatter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/libphonenumber-js/es6/AsYouTypeFormatter.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$AsYouTypeFormatter$2e$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/libphonenumber-js/es6/AsYouTypeFormatter.util.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$AsYouTypeParser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/libphonenumber-js/es6/AsYouTypeParser.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$helpers$2f$getCountryByCallingCode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/libphonenumber-js/es6/helpers/getCountryByCallingCode.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$helpers$2f$getCountryByNationalNumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/libphonenumber-js/es6/helpers/getCountryByNationalNumber.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$helpers$2f$isObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/libphonenumber-js/es6/helpers/isObject.js [app-client] (ecmascript)");
function _typeof(o) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o) {
        return typeof o;
    } : function(o) {
        return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    }, _typeof(o);
}
function _slicedToArray(r, e) {
    return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();
}
function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(r, a) {
    if (r) {
        if ("string" == typeof r) return _arrayLikeToArray(r, a);
        var t = ({}).toString.call(r).slice(8, -1);
        return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
    }
}
function _arrayLikeToArray(r, a) {
    (null == a || a > r.length) && (a = r.length);
    for(var e = 0, n = Array(a); e < a; e++)n[e] = r[e];
    return n;
}
function _iterableToArrayLimit(r, l) {
    var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
    if (null != t) {
        var e, n, i, u, a = [], f = !0, o = !1;
        try {
            if (i = (t = t.call(r)).next, 0 === l) {
                if (Object(t) !== t) return;
                f = !1;
            } else for(; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);
        } catch (r) {
            o = !0, n = r;
        } finally{
            try {
                if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
            } finally{
                if (o) throw n;
            }
        }
        return a;
    }
}
function _arrayWithHoles(r) {
    if (Array.isArray(r)) return r;
}
function _classCallCheck(a, n) {
    if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(e, r) {
    for(var t = 0; t < r.length; t++){
        var o = r[t];
        o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);
    }
}
function _createClass(e, r, t) {
    return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
        writable: !1
    }), e;
}
function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return "symbol" == _typeof(i) ? i : i + "";
}
function _toPrimitive(t, r) {
    if ("object" != _typeof(t) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
;
;
;
;
;
;
;
;
var USE_NON_GEOGRAPHIC_COUNTRY_CODE = false;
var AsYouType = /*#__PURE__*/ function() {
    /**
   * @param {(string|object)?} [optionsOrDefaultCountry] - The default country used for parsing non-international phone numbers. Can also be an `options` object.
   * @param {Object} metadata
   */ function AsYouType(optionsOrDefaultCountry, metadata) {
        _classCallCheck(this, AsYouType);
        this.metadata = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$metadata$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](metadata);
        var _this$getCountryAndCa = this.getCountryAndCallingCode(optionsOrDefaultCountry), _this$getCountryAndCa2 = _slicedToArray(_this$getCountryAndCa, 2), defaultCountry = _this$getCountryAndCa2[0], defaultCallingCode = _this$getCountryAndCa2[1];
        // `this.defaultCountry` and `this.defaultCallingCode` aren't required to be in sync.
        // For example, `this.defaultCountry` could be `"AR"` and `this.defaultCallingCode` could be `undefined`.
        // So `this.defaultCountry` and `this.defaultCallingCode` are totally independent.
        this.defaultCountry = defaultCountry;
        this.defaultCallingCode = defaultCallingCode;
        this.reset();
    }
    return _createClass(AsYouType, [
        {
            key: "getCountryAndCallingCode",
            value: function getCountryAndCallingCode(optionsOrDefaultCountry) {
                // Set `defaultCountry` and `defaultCallingCode` options.
                var defaultCountry;
                var defaultCallingCode;
                // Turns out `null` also has type "object". Weird.
                if (optionsOrDefaultCountry) {
                    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$helpers$2f$isObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(optionsOrDefaultCountry)) {
                        defaultCountry = optionsOrDefaultCountry.defaultCountry;
                        defaultCallingCode = optionsOrDefaultCountry.defaultCallingCode;
                    } else {
                        defaultCountry = optionsOrDefaultCountry;
                    }
                }
                if (defaultCountry && !this.metadata.hasCountry(defaultCountry)) {
                    defaultCountry = undefined;
                }
                if (defaultCallingCode) {
                    /* istanbul ignore if */ if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
                    ;
                }
                return [
                    defaultCountry,
                    defaultCallingCode
                ];
            }
        },
        {
            key: "input",
            value: function input(text) {
                var _this$parser$input = this.parser.input(text, this.state), digits = _this$parser$input.digits, justLeadingPlus = _this$parser$input.justLeadingPlus;
                if (justLeadingPlus) {
                    this.formattedOutput = '+';
                } else if (digits) {
                    this.determineTheCountryIfNeeded();
                    // Match the available formats by the currently available leading digits.
                    if (this.state.nationalSignificantNumber) {
                        this.formatter.narrowDownMatchingFormats(this.state);
                    }
                    var formattedNationalNumber;
                    if (this.metadata.hasSelectedNumberingPlan()) {
                        formattedNationalNumber = this.formatter.format(digits, this.state);
                    }
                    if (formattedNationalNumber === undefined) {
                        // See if another national (significant) number could be re-extracted.
                        if (this.parser.reExtractNationalSignificantNumber(this.state)) {
                            this.determineTheCountryIfNeeded();
                            // If it could, then re-try formatting the new national (significant) number.
                            var nationalDigits = this.state.getNationalDigits();
                            if (nationalDigits) {
                                formattedNationalNumber = this.formatter.format(nationalDigits, this.state);
                            }
                        }
                    }
                    this.formattedOutput = formattedNationalNumber ? this.getFullNumber(formattedNationalNumber) : this.getNonFormattedNumber();
                }
                return this.formattedOutput;
            }
        },
        {
            key: "reset",
            value: function reset() {
                var _this = this;
                this.state = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$AsYouTypeState$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
                    onCountryChange: function onCountryChange(country) {
                        // Before version `1.6.0`, the official `AsYouType` formatter API
                        // included a `.country` property on an `AsYouType` instance.
                        // Since that property (along with the others) have been moved to
                        // `this.state`, `this.country` property is emulated for compatibility
                        // with the old versions.
                        _this.country = country;
                    },
                    onCallingCodeChange: function onCallingCodeChange(callingCode, country) {
                        _this.metadata.selectNumberingPlan(country, callingCode);
                        _this.formatter.reset(_this.metadata.numberingPlan, _this.state);
                        _this.parser.reset(_this.metadata.numberingPlan);
                    }
                });
                this.formatter = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$AsYouTypeFormatter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["default"]({
                    state: this.state,
                    metadata: this.metadata
                });
                this.parser = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$AsYouTypeParser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
                    defaultCountry: this.defaultCountry,
                    defaultCallingCode: this.defaultCallingCode,
                    metadata: this.metadata,
                    state: this.state,
                    onNationalSignificantNumberChange: function onNationalSignificantNumberChange() {
                        _this.determineTheCountryIfNeeded();
                        _this.formatter.reset(_this.metadata.numberingPlan, _this.state);
                    }
                });
                this.state.reset({
                    country: this.defaultCountry,
                    callingCode: this.defaultCallingCode
                });
                this.formattedOutput = '';
                return this;
            }
        },
        {
            key: "isInternational",
            value: function isInternational() {
                return this.state.international;
            }
        },
        {
            key: "getCallingCode",
            value: function getCallingCode() {
                // If the number is being input in national format and some "default calling code"
                // has been passed to `AsYouType` constructor, then `this.state.callingCode`
                // is equal to that "default calling code".
                //
                // If the number is being input in national format and no "default calling code"
                // has been passed to `AsYouType` constructor, then returns `undefined`,
                // even if a "default country" has been passed to `AsYouType` constructor.
                //
                if (this.isInternational()) {
                    return this.state.callingCode;
                }
            }
        },
        {
            key: "getCountryCallingCode",
            value: function getCountryCallingCode() {
                return this.getCallingCode();
            }
        },
        {
            key: "getCountry",
            value: function getCountry() {
                var digits = this.state.digits;
                // Return `undefined` if no digits have been input yet.
                if (digits) {
                    return this._getCountry();
                }
            }
        },
        {
            key: "_getCountry",
            value: function _getCountry() {
                var country = this.state.country;
                /* istanbul ignore if */ if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
                ;
                return country;
            }
        },
        {
            key: "determineTheCountryIfNeeded",
            value: function determineTheCountryIfNeeded() {
                // Suppose a user enters a phone number in international format,
                // and there're several countries corresponding to that country calling code,
                // and a country has been derived from the number, and then
                // a user enters one more digit and the number is no longer
                // valid for the derived country, so the country should be re-derived
                // on every new digit in those cases.
                //
                // If the phone number is being input in national format,
                // then it could be a case when `defaultCountry` wasn't specified
                // when creating `AsYouType` instance, and just `defaultCallingCode` was specified,
                // and that "calling code" could correspond to a "non-geographic entity",
                // or there could be several countries corresponding to that country calling code.
                // In those cases, `this.country` is `undefined` and should be derived
                // from the number. Again, if country calling code is ambiguous, then
                // `this.country` should be re-derived with each new digit.
                //
                if (!this.state.country || this.isCountryCallingCodeAmbiguous()) {
                    this.determineTheCountry();
                }
            }
        },
        {
            key: "getFullNumber",
            value: function getFullNumber(formattedNationalNumber) {
                var _this2 = this;
                if (this.isInternational()) {
                    var prefix = function prefix(text) {
                        return _this2.formatter.getInternationalPrefixBeforeCountryCallingCode(_this2.state, {
                            spacing: text ? true : false
                        }) + text;
                    };
                    var callingCode = this.state.callingCode;
                    if (!callingCode) {
                        return prefix("".concat(this.state.getDigitsWithoutInternationalPrefix()));
                    }
                    if (!formattedNationalNumber) {
                        return prefix(callingCode);
                    }
                    return prefix("".concat(callingCode, " ").concat(formattedNationalNumber));
                }
                return formattedNationalNumber;
            }
        },
        {
            key: "getNonFormattedNationalNumberWithPrefix",
            value: function getNonFormattedNationalNumberWithPrefix() {
                var _this$state = this.state, nationalSignificantNumber = _this$state.nationalSignificantNumber, prefixBeforeNationalSignificantNumberThatIsNotNationalPrefix = _this$state.prefixBeforeNationalSignificantNumberThatIsNotNationalPrefix, nationalPrefix = _this$state.nationalPrefix;
                var number = nationalSignificantNumber;
                var prefix = prefixBeforeNationalSignificantNumberThatIsNotNationalPrefix || nationalPrefix;
                if (prefix) {
                    number = prefix + number;
                }
                return number;
            }
        },
        {
            key: "getNonFormattedNumber",
            value: function getNonFormattedNumber() {
                var nationalSignificantNumberIsModified = this.state.nationalSignificantNumberIsModified;
                return this.getFullNumber(nationalSignificantNumberIsModified ? this.state.getNationalDigits() : this.getNonFormattedNationalNumberWithPrefix());
            }
        },
        {
            key: "getNonFormattedTemplate",
            value: function getNonFormattedTemplate() {
                var number = this.getNonFormattedNumber();
                if (number) {
                    return number.replace(/[\+\d]/g, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$AsYouTypeFormatter$2e$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIGIT_PLACEHOLDER"]);
                }
            }
        },
        {
            key: "isCountryCallingCodeAmbiguous",
            value: function isCountryCallingCodeAmbiguous() {
                var callingCode = this.state.callingCode;
                var countryCodes = this.metadata.getCountryCodesForCallingCode(callingCode);
                return countryCodes && countryCodes.length > 1;
            }
        },
        {
            key: "determineTheCountry",
            value: function determineTheCountry() {
                this.state.setCountry((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$helpers$2f$getCountryByCallingCode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(this.isInternational() ? this.state.callingCode : this.defaultCallingCode, {
                    nationalNumber: this.state.nationalSignificantNumber,
                    metadata: this.metadata
                }));
            }
        },
        {
            key: "getNumberValue",
            value: function getNumberValue() {
                var _this$state2 = this.state, digits = _this$state2.digits, callingCode = _this$state2.callingCode, country = _this$state2.country, nationalSignificantNumber = _this$state2.nationalSignificantNumber;
                // Will return `undefined` if no digits have been input.
                if (!digits) {
                    return;
                }
                if (this.isInternational()) {
                    if (callingCode) {
                        return '+' + callingCode + nationalSignificantNumber;
                    } else {
                        return '+' + digits;
                    }
                } else {
                    if (country || callingCode) {
                        var callingCode_ = country ? this.metadata.countryCallingCode() : callingCode;
                        return '+' + callingCode_ + nationalSignificantNumber;
                    }
                }
            }
        },
        {
            key: "getNumber",
            value: function getNumber() {
                var _this$state3 = this.state, nationalSignificantNumber = _this$state3.nationalSignificantNumber, carrierCode = _this$state3.carrierCode, callingCode = _this$state3.callingCode;
                // `this._getCountry()` is basically same as `this.state.country`
                // with the only change that it return `undefined` in case of a
                // "non-geographic" numbering plan instead of `"001"` "internal use" value.
                var country = this._getCountry();
                if (!nationalSignificantNumber) {
                    return;
                }
                // `state.country` and `state.callingCode` aren't required to be in sync.
                // For example, `country` could be `"AR"` and `callingCode` could be `undefined`.
                // So `country` and `callingCode` are totally independent.
                if (!country && !callingCode) {
                    return;
                }
                // By default, if `defaultCountry` parameter was passed when
                // creating `AsYouType` instance, `state.country` is gonna be
                // that `defaultCountry`, which doesn't entirely conform with
                // `parsePhoneNumber()`'s behavior where it attempts to determine
                // the country more precisely in cases when multiple countries
                // could correspond to the same `countryCallingCode`.
                // https://gitlab.com/catamphetamine/libphonenumber-js/-/issues/103#note_1417192969
                //
                // Because `AsYouType.getNumber()` method is supposed to be a 1:1
                // equivalent for `parsePhoneNumber(AsYouType.getNumberValue())`,
                // then it should also behave accordingly in cases of `country` ambiguity.
                // That's how users of this library would expect it to behave anyway.
                //
                if (country) {
                    if (country === this.defaultCountry) {
                        // `state.country` and `state.callingCode` aren't required to be in sync.
                        // For example, `state.country` could be `"AR"` and `state.callingCode` could be `undefined`.
                        // So `state.country` and `state.callingCode` are totally independent.
                        var metadata = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$metadata$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](this.metadata.metadata);
                        metadata.selectNumberingPlan(country);
                        var _callingCode = metadata.numberingPlan.callingCode();
                        var ambiguousCountries = this.metadata.getCountryCodesForCallingCode(_callingCode);
                        if (ambiguousCountries.length > 1) {
                            var exactCountry = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$helpers$2f$getCountryByNationalNumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(nationalSignificantNumber, {
                                countries: ambiguousCountries,
                                metadata: this.metadata.metadata
                            });
                            if (exactCountry) {
                                country = exactCountry;
                            }
                        }
                    }
                }
                var phoneNumber = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$PhoneNumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](country || callingCode, nationalSignificantNumber, this.metadata.metadata);
                if (carrierCode) {
                    phoneNumber.carrierCode = carrierCode;
                }
                // Phone number extensions are not supported by "As You Type" formatter.
                return phoneNumber;
            }
        },
        {
            key: "isPossible",
            value: function isPossible() {
                var phoneNumber = this.getNumber();
                if (!phoneNumber) {
                    return false;
                }
                return phoneNumber.isPossible();
            }
        },
        {
            key: "isValid",
            value: function isValid() {
                var phoneNumber = this.getNumber();
                if (!phoneNumber) {
                    return false;
                }
                return phoneNumber.isValid();
            }
        },
        {
            key: "getNationalNumber",
            value: function getNationalNumber() {
                return this.state.nationalSignificantNumber;
            }
        },
        {
            key: "getChars",
            value: function getChars() {
                return (this.state.international ? '+' : '') + this.state.digits;
            }
        },
        {
            key: "getTemplate",
            value: function getTemplate() {
                return this.formatter.getTemplate(this.state) || this.getNonFormattedTemplate() || '';
            }
        }
    ]);
}();
;
 //# sourceMappingURL=AsYouType.js.map
}),
"[project]/node_modules/libphonenumber-js/es6/formatIncompletePhoneNumber.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>formatIncompletePhoneNumber
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$AsYouType$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/libphonenumber-js/es6/AsYouType.js [app-client] (ecmascript)");
;
function formatIncompletePhoneNumber(value, optionsOrDefaultCountry, metadata) {
    if (!metadata) {
        metadata = optionsOrDefaultCountry;
        optionsOrDefaultCountry = undefined;
    }
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$AsYouType$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](optionsOrDefaultCountry, metadata).input(value);
} //# sourceMappingURL=formatIncompletePhoneNumber.js.map
}),
"[project]/node_modules/libphonenumber-js/es6/formatIncompletePhoneNumber.js [app-client] (ecmascript) <export default as formatIncompletePhoneNumber>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "formatIncompletePhoneNumber",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$formatIncompletePhoneNumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libphonenumber$2d$js$2f$es6$2f$formatIncompletePhoneNumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/libphonenumber-js/es6/formatIncompletePhoneNumber.js [app-client] (ecmascript)");
}),
"[project]/node_modules/lucide-react/dist/esm/icons/phone.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * @license lucide-react v0.544.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ __turbopack_context__.s([
    "__iconNode",
    ()=>__iconNode,
    "default",
    ()=>Phone
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lucide-react/dist/esm/createLucideIcon.js [app-client] (ecmascript)");
;
const __iconNode = [
    [
        "path",
        {
            d: "M13.832 16.568a1 1 0 0 0 1.213-.303l.355-.465A2 2 0 0 1 17 15h3a2 2 0 0 1 2 2v3a2 2 0 0 1-2 2A18 18 0 0 1 2 4a2 2 0 0 1 2-2h3a2 2 0 0 1 2 2v3a2 2 0 0 1-.8 1.6l-.468.351a1 1 0 0 0-.292 1.233 14 14 0 0 0 6.392 6.384",
            key: "9njp5v"
        }
    ]
];
const Phone = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])("phone", __iconNode);
;
 //# sourceMappingURL=phone.js.map
}),
"[project]/node_modules/lucide-react/dist/esm/icons/phone.js [app-client] (ecmascript) <export default as PhoneIcon>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "PhoneIcon",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$phone$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$phone$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lucide-react/dist/esm/icons/phone.js [app-client] (ecmascript)");
}),
"[project]/node_modules/framer-motion/dist/es/utils/use-composed-ref.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "useComposedRefs",
    ()=>useComposedRefs
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
;
/**
 * Taken from https://github.com/radix-ui/primitives/blob/main/packages/react/compose-refs/src/compose-refs.tsx
 */ /**
 * Set a given ref to a given value
 * This utility takes care of different types of refs: callback refs and RefObject(s)
 */ function setRef(ref, value) {
    if (typeof ref === "function") {
        return ref(value);
    } else if (ref !== null && ref !== undefined) {
        ref.current = value;
    }
}
/**
 * A utility to compose multiple refs together
 * Accepts callback refs and RefObject(s)
 */ function composeRefs(...refs) {
    return (node)=>{
        let hasCleanup = false;
        const cleanups = refs.map((ref)=>{
            const cleanup = setRef(ref, node);
            if (!hasCleanup && typeof cleanup === "function") {
                hasCleanup = true;
            }
            return cleanup;
        });
        // React <19 will log an error to the console if a callback ref returns a
        // value. We don't use ref cleanups internally so this will only happen if a
        // user's ref callback returns a value, which we only expect if they are
        // using the cleanup functionality added in React 19.
        if (hasCleanup) {
            return ()=>{
                for(let i = 0; i < cleanups.length; i++){
                    const cleanup = cleanups[i];
                    if (typeof cleanup === "function") {
                        cleanup();
                    } else {
                        setRef(refs[i], null);
                    }
                }
            };
        }
    };
}
/**
 * A custom hook that composes multiple refs
 * Accepts callback refs and RefObject(s)
 */ function useComposedRefs(...refs) {
    // eslint-disable-next-line react-hooks/exhaustive-deps
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"](composeRefs(...refs), refs);
}
;
}),
"[project]/node_modules/framer-motion/dist/es/components/AnimatePresence/PopChild.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "PopChild",
    ()=>PopChild
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$motion$2d$dom$2f$dist$2f$es$2f$utils$2f$is$2d$html$2d$element$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/motion-dom/dist/es/utils/is-html-element.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$framer$2d$motion$2f$dist$2f$es$2f$context$2f$MotionConfigContext$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/framer-motion/dist/es/context/MotionConfigContext.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$framer$2d$motion$2f$dist$2f$es$2f$utils$2f$use$2d$composed$2d$ref$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/framer-motion/dist/es/utils/use-composed-ref.mjs [app-client] (ecmascript)");
"use client";
;
;
;
;
;
;
/**
 * Measurement functionality has to be within a separate component
 * to leverage snapshot lifecycle.
 */ class PopChildMeasure extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Component"] {
    getSnapshotBeforeUpdate(prevProps) {
        const element = this.props.childRef.current;
        if (element && prevProps.isPresent && !this.props.isPresent) {
            const parent = element.offsetParent;
            const parentWidth = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$motion$2d$dom$2f$dist$2f$es$2f$utils$2f$is$2d$html$2d$element$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isHTMLElement"])(parent) ? parent.offsetWidth || 0 : 0;
            const size = this.props.sizeRef.current;
            size.height = element.offsetHeight || 0;
            size.width = element.offsetWidth || 0;
            size.top = element.offsetTop;
            size.left = element.offsetLeft;
            size.right = parentWidth - size.width - size.left;
        }
        return null;
    }
    /**
     * Required with getSnapshotBeforeUpdate to stop React complaining.
     */ componentDidUpdate() {}
    render() {
        return this.props.children;
    }
}
function PopChild({ children, isPresent, anchorX, root }) {
    const id = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useId"])();
    const ref = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(null);
    const size = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])({
        width: 0,
        height: 0,
        top: 0,
        left: 0,
        right: 0
    });
    const { nonce } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useContext"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$framer$2d$motion$2f$dist$2f$es$2f$context$2f$MotionConfigContext$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MotionConfigContext"]);
    const composedRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$framer$2d$motion$2f$dist$2f$es$2f$utils$2f$use$2d$composed$2d$ref$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useComposedRefs"])(ref, children?.ref);
    /**
     * We create and inject a style block so we can apply this explicit
     * sizing in a non-destructive manner by just deleting the style block.
     *
     * We can't apply size via render as the measurement happens
     * in getSnapshotBeforeUpdate (post-render), likewise if we apply the
     * styles directly on the DOM node, we might be overwriting
     * styles set via the style prop.
     */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useInsertionEffect"])({
        "PopChild.useInsertionEffect": ()=>{
            const { width, height, top, left, right } = size.current;
            if (isPresent || !ref.current || !width || !height) return;
            const x = anchorX === "left" ? `left: ${left}` : `right: ${right}`;
            ref.current.dataset.motionPopId = id;
            const style = document.createElement("style");
            if (nonce) style.nonce = nonce;
            const parent = root ?? document.head;
            parent.appendChild(style);
            if (style.sheet) {
                style.sheet.insertRule(`
          [data-motion-pop-id="${id}"] {
            position: absolute !important;
            width: ${width}px !important;
            height: ${height}px !important;
            ${x}px !important;
            top: ${top}px !important;
          }
        `);
            }
            return ({
                "PopChild.useInsertionEffect": ()=>{
                    if (parent.contains(style)) {
                        parent.removeChild(style);
                    }
                }
            })["PopChild.useInsertionEffect"];
        }
    }["PopChild.useInsertionEffect"], [
        isPresent
    ]);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(PopChildMeasure, {
        isPresent: isPresent,
        childRef: ref,
        sizeRef: size,
        children: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cloneElement"](children, {
            ref: composedRef
        })
    });
}
;
}),
"[project]/node_modules/framer-motion/dist/es/components/AnimatePresence/PresenceChild.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "PresenceChild",
    ()=>PresenceChild
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$framer$2d$motion$2f$dist$2f$es$2f$context$2f$PresenceContext$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/framer-motion/dist/es/context/PresenceContext.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$framer$2d$motion$2f$dist$2f$es$2f$utils$2f$use$2d$constant$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/framer-motion/dist/es/utils/use-constant.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$framer$2d$motion$2f$dist$2f$es$2f$components$2f$AnimatePresence$2f$PopChild$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/framer-motion/dist/es/components/AnimatePresence/PopChild.mjs [app-client] (ecmascript)");
"use client";
;
;
;
;
;
;
const PresenceChild = ({ children, initial, isPresent, onExitComplete, custom, presenceAffectsLayout, mode, anchorX, root })=>{
    const presenceChildren = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$framer$2d$motion$2f$dist$2f$es$2f$utils$2f$use$2d$constant$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useConstant"])(newChildrenMap);
    const id = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useId"])();
    let isReusedContext = true;
    let context = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
        "PresenceChild.useMemo[context]": ()=>{
            isReusedContext = false;
            return {
                id,
                initial,
                isPresent,
                custom,
                onExitComplete: ({
                    "PresenceChild.useMemo[context]": (childId)=>{
                        presenceChildren.set(childId, true);
                        for (const isComplete of presenceChildren.values()){
                            if (!isComplete) return; // can stop searching when any is incomplete
                        }
                        onExitComplete && onExitComplete();
                    }
                })["PresenceChild.useMemo[context]"],
                register: ({
                    "PresenceChild.useMemo[context]": (childId)=>{
                        presenceChildren.set(childId, false);
                        return ({
                            "PresenceChild.useMemo[context]": ()=>presenceChildren.delete(childId)
                        })["PresenceChild.useMemo[context]"];
                    }
                })["PresenceChild.useMemo[context]"]
            };
        }
    }["PresenceChild.useMemo[context]"], [
        isPresent,
        presenceChildren,
        onExitComplete
    ]);
    /**
     * If the presence of a child affects the layout of the components around it,
     * we want to make a new context value to ensure they get re-rendered
     * so they can detect that layout change.
     */ if (presenceAffectsLayout && isReusedContext) {
        context = {
            ...context
        };
    }
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
        "PresenceChild.useMemo": ()=>{
            presenceChildren.forEach({
                "PresenceChild.useMemo": (_, key)=>presenceChildren.set(key, false)
            }["PresenceChild.useMemo"]);
        }
    }["PresenceChild.useMemo"], [
        isPresent
    ]);
    /**
     * If there's no `motion` components to fire exit animations, we want to remove this
     * component immediately.
     */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"]({
        "PresenceChild.useEffect": ()=>{
            !isPresent && !presenceChildren.size && onExitComplete && onExitComplete();
        }
    }["PresenceChild.useEffect"], [
        isPresent
    ]);
    if (mode === "popLayout") {
        children = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$framer$2d$motion$2f$dist$2f$es$2f$components$2f$AnimatePresence$2f$PopChild$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PopChild"], {
            isPresent: isPresent,
            anchorX: anchorX,
            root: root,
            children: children
        });
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$framer$2d$motion$2f$dist$2f$es$2f$context$2f$PresenceContext$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PresenceContext"].Provider, {
        value: context,
        children: children
    });
};
function newChildrenMap() {
    return new Map();
}
;
}),
"[project]/node_modules/framer-motion/dist/es/components/AnimatePresence/utils.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getChildKey",
    ()=>getChildKey,
    "onlyElements",
    ()=>onlyElements
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
;
const getChildKey = (child)=>child.key || "";
function onlyElements(children) {
    const filtered = [];
    // We use forEach here instead of map as map mutates the component key by preprending `.$`
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Children"].forEach(children, (child)=>{
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isValidElement"])(child)) filtered.push(child);
    });
    return filtered;
}
;
}),
"[project]/node_modules/framer-motion/dist/es/components/AnimatePresence/index.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "AnimatePresence",
    ()=>AnimatePresence
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$framer$2d$motion$2f$dist$2f$es$2f$context$2f$LayoutGroupContext$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/framer-motion/dist/es/context/LayoutGroupContext.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$framer$2d$motion$2f$dist$2f$es$2f$utils$2f$use$2d$constant$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/framer-motion/dist/es/utils/use-constant.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$framer$2d$motion$2f$dist$2f$es$2f$utils$2f$use$2d$isomorphic$2d$effect$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/framer-motion/dist/es/utils/use-isomorphic-effect.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$framer$2d$motion$2f$dist$2f$es$2f$components$2f$AnimatePresence$2f$PresenceChild$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/framer-motion/dist/es/components/AnimatePresence/PresenceChild.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$framer$2d$motion$2f$dist$2f$es$2f$components$2f$AnimatePresence$2f$use$2d$presence$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/framer-motion/dist/es/components/AnimatePresence/use-presence.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$framer$2d$motion$2f$dist$2f$es$2f$components$2f$AnimatePresence$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/framer-motion/dist/es/components/AnimatePresence/utils.mjs [app-client] (ecmascript)");
"use client";
;
;
;
;
;
;
;
;
/**
 * `AnimatePresence` enables the animation of components that have been removed from the tree.
 *
 * When adding/removing more than a single child, every child **must** be given a unique `key` prop.
 *
 * Any `motion` components that have an `exit` property defined will animate out when removed from
 * the tree.
 *
 * ```jsx
 * import { motion, AnimatePresence } from 'framer-motion'
 *
 * export const Items = ({ items }) => (
 *   <AnimatePresence>
 *     {items.map(item => (
 *       <motion.div
 *         key={item.id}
 *         initial={{ opacity: 0 }}
 *         animate={{ opacity: 1 }}
 *         exit={{ opacity: 0 }}
 *       />
 *     ))}
 *   </AnimatePresence>
 * )
 * ```
 *
 * You can sequence exit animations throughout a tree using variants.
 *
 * If a child contains multiple `motion` components with `exit` props, it will only unmount the child
 * once all `motion` components have finished animating out. Likewise, any components using
 * `usePresence` all need to call `safeToRemove`.
 *
 * @public
 */ const AnimatePresence = ({ children, custom, initial = true, onExitComplete, presenceAffectsLayout = true, mode = "sync", propagate = false, anchorX = "left", root })=>{
    const [isParentPresent, safeToRemove] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$framer$2d$motion$2f$dist$2f$es$2f$components$2f$AnimatePresence$2f$use$2d$presence$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["usePresence"])(propagate);
    /**
     * Filter any children that aren't ReactElements. We can only track components
     * between renders with a props.key.
     */ const presentChildren = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
        "AnimatePresence.useMemo[presentChildren]": ()=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$framer$2d$motion$2f$dist$2f$es$2f$components$2f$AnimatePresence$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["onlyElements"])(children)
    }["AnimatePresence.useMemo[presentChildren]"], [
        children
    ]);
    /**
     * Track the keys of the currently rendered children. This is used to
     * determine which children are exiting.
     */ const presentKeys = propagate && !isParentPresent ? [] : presentChildren.map(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$framer$2d$motion$2f$dist$2f$es$2f$components$2f$AnimatePresence$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getChildKey"]);
    /**
     * If `initial={false}` we only want to pass this to components in the first render.
     */ const isInitialRender = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(true);
    /**
     * A ref containing the currently present children. When all exit animations
     * are complete, we use this to re-render the component with the latest children
     * *committed* rather than the latest children *rendered*.
     */ const pendingPresentChildren = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(presentChildren);
    /**
     * Track which exiting children have finished animating out.
     */ const exitComplete = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$framer$2d$motion$2f$dist$2f$es$2f$utils$2f$use$2d$constant$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useConstant"])({
        "AnimatePresence.useConstant[exitComplete]": ()=>new Map()
    }["AnimatePresence.useConstant[exitComplete]"]);
    /**
     * Save children to render as React state. To ensure this component is concurrent-safe,
     * we check for exiting children via an effect.
     */ const [diffedChildren, setDiffedChildren] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])(presentChildren);
    const [renderedChildren, setRenderedChildren] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])(presentChildren);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$framer$2d$motion$2f$dist$2f$es$2f$utils$2f$use$2d$isomorphic$2d$effect$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useIsomorphicLayoutEffect"])({
        "AnimatePresence.useIsomorphicLayoutEffect": ()=>{
            isInitialRender.current = false;
            pendingPresentChildren.current = presentChildren;
            /**
         * Update complete status of exiting children.
         */ for(let i = 0; i < renderedChildren.length; i++){
                const key = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$framer$2d$motion$2f$dist$2f$es$2f$components$2f$AnimatePresence$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getChildKey"])(renderedChildren[i]);
                if (!presentKeys.includes(key)) {
                    if (exitComplete.get(key) !== true) {
                        exitComplete.set(key, false);
                    }
                } else {
                    exitComplete.delete(key);
                }
            }
        }
    }["AnimatePresence.useIsomorphicLayoutEffect"], [
        renderedChildren,
        presentKeys.length,
        presentKeys.join("-")
    ]);
    const exitingChildren = [];
    if (presentChildren !== diffedChildren) {
        let nextChildren = [
            ...presentChildren
        ];
        /**
         * Loop through all the currently rendered components and decide which
         * are exiting.
         */ for(let i = 0; i < renderedChildren.length; i++){
            const child = renderedChildren[i];
            const key = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$framer$2d$motion$2f$dist$2f$es$2f$components$2f$AnimatePresence$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getChildKey"])(child);
            if (!presentKeys.includes(key)) {
                nextChildren.splice(i, 0, child);
                exitingChildren.push(child);
            }
        }
        /**
         * If we're in "wait" mode, and we have exiting children, we want to
         * only render these until they've all exited.
         */ if (mode === "wait" && exitingChildren.length) {
            nextChildren = exitingChildren;
        }
        setRenderedChildren((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$framer$2d$motion$2f$dist$2f$es$2f$components$2f$AnimatePresence$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["onlyElements"])(nextChildren));
        setDiffedChildren(presentChildren);
        /**
         * Early return to ensure once we've set state with the latest diffed
         * children, we can immediately re-render.
         */ return null;
    }
    if (("TURBOPACK compile-time value", "development") !== "production" && mode === "wait" && renderedChildren.length > 1) {
        console.warn(`You're attempting to animate multiple children within AnimatePresence, but its mode is set to "wait". This will lead to odd visual behaviour.`);
    }
    /**
     * If we've been provided a forceRender function by the LayoutGroupContext,
     * we can use it to force a re-render amongst all surrounding components once
     * all components have finished animating out.
     */ const { forceRender } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useContext"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$framer$2d$motion$2f$dist$2f$es$2f$context$2f$LayoutGroupContext$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LayoutGroupContext"]);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Fragment"], {
        children: renderedChildren.map((child)=>{
            const key = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$framer$2d$motion$2f$dist$2f$es$2f$components$2f$AnimatePresence$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getChildKey"])(child);
            const isPresent = propagate && !isParentPresent ? false : presentChildren === renderedChildren || presentKeys.includes(key);
            const onExit = ()=>{
                if (exitComplete.has(key)) {
                    exitComplete.set(key, true);
                } else {
                    return;
                }
                let isEveryExitComplete = true;
                exitComplete.forEach((isExitComplete)=>{
                    if (!isExitComplete) isEveryExitComplete = false;
                });
                if (isEveryExitComplete) {
                    forceRender?.();
                    setRenderedChildren(pendingPresentChildren.current);
                    propagate && safeToRemove?.();
                    onExitComplete && onExitComplete();
                }
            };
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$framer$2d$motion$2f$dist$2f$es$2f$components$2f$AnimatePresence$2f$PresenceChild$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PresenceChild"], {
                isPresent: isPresent,
                initial: !isInitialRender.current || initial ? undefined : false,
                custom: custom,
                presenceAffectsLayout: presenceAffectsLayout,
                mode: mode,
                root: root,
                onExitComplete: isPresent ? undefined : onExit,
                anchorX: anchorX,
                children: child
            }, key);
        })
    });
};
;
}),
]);

//# sourceMappingURL=node_modules_9353b878._.js.map