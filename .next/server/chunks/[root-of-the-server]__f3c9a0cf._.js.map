{"version":3,"sources":["turbopack:///[project]/node_modules/vcard-creator/dist/vcard-creator.js","turbopack:///[project]/src/app/vcard/route.ts","turbopack:///[project]/node_modules/next/dist/esm/build/templates/app-route.js","turbopack:///[project]/node_modules/libphonenumber-js/source/helpers/isObject.js","turbopack:///[project]/node_modules/libphonenumber-js/source/helpers/getPossibleCountriesForNumber.js","turbopack:///[project]/node_modules/libphonenumber-js/source/helpers/getCountryByCallingCode.js","turbopack:///[project]/node_modules/libphonenumber-js/source/helpers/extractNationalNumber.js","turbopack:///[project]/node_modules/libphonenumber-js/source/isValid.js","turbopack:///[project]/node_modules/libphonenumber-js/source/helpers/extractCountryCallingCodeFromInternationalNumberWithoutPlusSign.js","turbopack:///[project]/node_modules/libphonenumber-js/source/helpers/extractCountryCallingCode.js","turbopack:///[project]/node_modules/libphonenumber-js/source/helpers/checkNumberLength.js","turbopack:///[project]/node_modules/libphonenumber-js/source/helpers/formatNationalNumberUsingFormat.js","turbopack:///[project]/node_modules/libphonenumber-js/source/helpers/getIddPrefix.js","turbopack:///[project]/node_modules/libphonenumber-js/source/isPossible.js","turbopack:///[project]/node_modules/libphonenumber-js/source/AsYouTypeFormatter.complete.js","turbopack:///[project]/node_modules/libphonenumber-js/source/helpers/stripIddPrefix.js","turbopack:///[project]/node_modules/libphonenumber-js/source/formatIncompletePhoneNumber.js","turbopack:///[project]/node_modules/libphonenumber-js/source/constants.js","turbopack:///[project]/src/utils/string.ts","turbopack:///[project]/src/lib/libphonenumber.ts","turbopack:///[project]/node_modules/libphonenumber-js/source/helpers/extension/createExtensionPattern.js","turbopack:///[project]/node_modules/libphonenumber-js/source/helpers/getCountryByNationalNumber.js","turbopack:///[project]/node_modules/libphonenumber-js/source/helpers/getNumberType.js","turbopack:///[project]/node_modules/libphonenumber-js/source/AsYouTypeFormatter.util.js","turbopack:///[project]/node_modules/next/dist/src/build/templates/app-route.ts","turbopack:///[project]/node_modules/libphonenumber-js/source/helpers/matchesEntirely.js","turbopack:///[project]/node_modules/libphonenumber-js/source/AsYouTypeFormatter.PatternParser.js","turbopack:///[project]/node_modules/libphonenumber-js/source/format.js","turbopack:///[project]/node_modules/libphonenumber-js/source/metadata.js","turbopack:///[project]/node_modules/libphonenumber-js/source/tools/semver-compare.js","turbopack:///[project]/node_modules/libphonenumber-js/source/helpers/parseDigits.js","turbopack:///[project]/node_modules/libphonenumber-js/source/helpers/mergeArrays.js","turbopack:///[project]/node_modules/libphonenumber-js/source/PhoneNumber.js","turbopack:///[project]/node_modules/libphonenumber-js/source/AsYouTypeFormatter.js","turbopack:///[project]/node_modules/libphonenumber-js/source/AsYouTypeFormatter.PatternMatcher.js","turbopack:///[project]/node_modules/libphonenumber-js/source/AsYouType.js","turbopack:///[project]/node_modules/libphonenumber-js/source/AsYouTypeParser.js","turbopack:///[project]/node_modules/libphonenumber-js/source/helpers/extractNationalNumberFromPossiblyIncompleteNumber.js","turbopack:///[project]/node_modules/libphonenumber-js/source/helpers/RFC3966.js","turbopack:///[project]/node_modules/libphonenumber-js/source/helpers/isViablePhoneNumber.js","turbopack:///[project]/node_modules/libphonenumber-js/source/AsYouTypeState.js","turbopack:///[project]/node_modules/libphonenumber-js/source/helpers/applyInternationalSeparatorStyle.js"],"sourcesContent":["!function(e,t){\"object\"==typeof exports&&\"object\"==typeof module?module.exports=t():\"function\"==typeof define&&define.amd?define([],t):\"object\"==typeof exports?exports.vcardcreator=t():e.vcardcreator=t()}(\"undefined\"!=typeof self?self:this,(()=>{return e={20:(e,t,r)=>{var n=r(595);e.exports=function(e,t,r){return(t=n(t))in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e},e.exports.__esModule=!0,e.exports.default=e.exports},110:(e,t,r)=>{var n=r(871).default;e.exports=function(e,t){if(\"object\"!=n(e)||!e)return e;var r=e[Symbol.toPrimitive];if(void 0!==r){var i=r.call(e,t||\"default\");if(\"object\"!=n(i))return i;throw new TypeError(\"@@toPrimitive must return a primitive value.\")}return(\"string\"===t?String:Number)(e)},e.exports.__esModule=!0,e.exports.default=e.exports},136:function(e,t,r){var n,i,o;\"undefined\"!=typeof globalThis?globalThis:\"undefined\"!=typeof self&&self,i=[t,r(704)],void 0===(o=\"function\"==typeof(n=function(e,t){\"use strict\";var n=r(957);Object.defineProperty(e,\"__esModule\",{value:!0}),e.default=void 0,t=n(t),e.default=t.default})?n.apply(t,i):n)||(e.exports=o)},215:function(e,t){var r,n;\"undefined\"!=typeof globalThis?globalThis:\"undefined\"!=typeof self&&self,void 0===(n=\"function\"==typeof(r=function(e){\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.MIME_TYPES=e.Formats=e.DEFAULT_MIME_TYPE=e.DEFAULT_FORMAT=e.DEFAULT_FILENAME=e.DEFAULT_EXTENSION=e.DEFAULT_CONTENT_TYPE=e.DEFAULT_CHARACTER_SET=e.ContentTypes=e.ALLOWED_MULTIPLE_PROPERTIES=void 0;let t=e.ContentTypes=function(e){return e.VCALENDAR=\"text/x-vcalendar\",e.VCARD=\"text/x-vcard\",e}({}),r=e.Formats=function(e){return e.VCALENDAR=\"vcalendar\",e.VCARD=\"vcard\",e}({});e.ALLOWED_MULTIPLE_PROPERTIES=[\"address\",\"email\",\"phoneNumber\",\"social\",\"url\"],e.DEFAULT_CHARACTER_SET=\"utf-8\",e.DEFAULT_CONTENT_TYPE=t.VCARD,e.DEFAULT_EXTENSION=\"vcf\",e.DEFAULT_FILENAME=\"vcard\",e.DEFAULT_FORMAT=r.VCARD,e.DEFAULT_MIME_TYPE=\"JPEG\",e.MIME_TYPES=[\"aces\",\"avci\",\"avcs\",\"avif\",\"bmp\",\"cgm\",\"dicom-rle\",\"emf\",\"example\",\"fits\",\"g3fax\",\"gif\",\"heic\",\"heic-sequence\",\"heif\",\"heif-sequence\",\"hej2k\",\"hsj2\",\"ief\",\"jls\",\"jp2\",\"jpeg\",\"jph\",\"jphc\",\"jpm\",\"jpx\",\"jxr\",\"jxrA\",\"jxrS\",\"jxs\",\"jxsc\",\"jxsi\",\"jxss\",\"ktx\",\"ktx2\",\"naplps\",\"png\",\"prs.btif\",\"prs.pti\",\"pwg-raster\",\"svg+xml\",\"t38\",\"tiff\",\"tiff-fx\",\"vnd.adobe.photoshop\",\"vnd.airzip.accelerator.azv\",\"vnd.cns.inf2\",\"vnd.dece.graphic\",\"vnd.djvu\",\"vnd.dwg\",\"vnd.dxf\",\"vnd.dvb.subtitle\",\"vnd.fastbidsheet\",\"vnd.fpx\",\"vnd.fst\",\"vnd.fujixerox.edmics-mmr\",\"vnd.fujixerox.edmics-rlc\",\"vnd.globalgraphics.pgb\",\"vnd.microsoft.icon\",\"vnd.mix\",\"vnd.ms-modi\",\"vnd.mozilla.apng\",\"vnd.net-fpx\",\"vnd.pco.b16\",\"vnd.radiance\",\"vnd.sealed.png\",\"vnd.sealedmedia.softseal.gif\",\"vnd.sealedmedia.softseal.jpg\",\"vnd.svf\",\"vnd.tencent.tap\",\"vnd.valve.source.texture\",\"vnd.wap.wbmp\",\"vnd.xiff\",\"vnd.zbrush.pcx\",\"wmf\",\"x-emf\",\"x-wmf\"]})?r.apply(t,[t]):r)||(e.exports=n)},443:function(e,t){var r,n;\"undefined\"!=typeof globalThis?globalThis:\"undefined\"!=typeof self&&self,void 0===(n=\"function\"==typeof(r=function(e){\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.default=void 0;class t extends Error{constructor(e){super(e),Error.captureStackTrace&&Error.captureStackTrace(this,t),this.name=\"VCardException\"}}e.default=t})?r.apply(t,[t]):r)||(e.exports=n)},595:(e,t,r)=>{var n=r(871).default,i=r(110);e.exports=function(e){var t=i(e,\"string\");return\"symbol\"==n(t)?t:t+\"\"},e.exports.__esModule=!0,e.exports.default=e.exports},704:function(e,t,r){var n,i,o;\"undefined\"!=typeof globalThis?globalThis:\"undefined\"!=typeof self&&self,i=[t,r(20),r(443),r(979),r(215)],n=function(e,t,n,i,o){\"use strict\";var s=r(957);function a(e){if(\"function\"!=typeof WeakMap)return null;var t=new WeakMap,r=new WeakMap;return(a=function(e){return e?r:t})(e)}Object.defineProperty(e,\"__esModule\",{value:!0}),e.default=void 0,t=s(t),n=s(n),o=function(e,t){if(!t&&e&&e.__esModule)return e;if(null===e||\"object\"!=typeof e&&\"function\"!=typeof e)return{default:e};var r=a(t);if(r&&r.has(e))return r.get(e);var n={__proto__:null},i=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in e)if(\"default\"!==o&&{}.hasOwnProperty.call(e,o)){var s=i?Object.getOwnPropertyDescriptor(e,o):null;s&&(s.get||s.set)?Object.defineProperty(n,o,s):n[o]=e[o]}return n.default=e,r&&r.set(e,n),n}(o);e.default=class{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:o.DEFAULT_FORMAT;(0,t.default)(this,\"charset\",o.DEFAULT_CHARACTER_SET),(0,t.default)(this,\"contentType\",o.DEFAULT_CONTENT_TYPE),(0,t.default)(this,\"filename\",o.DEFAULT_FILENAME),(0,t.default)(this,\"fileExtension\",o.DEFAULT_EXTENSION),(0,t.default)(this,\"properties\",[]),(0,t.default)(this,\"definedElements\",{}),(0,t.default)(this,\"multiplePropertiesForElementAllowed\",o.ALLOWED_MULTIPLE_PROPERTIES),(0,t.default)(this,\"useVCalendar\",!1),e===o.Formats.VCALENDAR&&this.setFormat(e)}setFormat(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:o.DEFAULT_FORMAT;e===o.Formats.VCALENDAR?(console.warn(\"The format 'vcalendar' is deprecated and will be removed in the next major or minor release. Use 'vcard' instead.\"),this.contentType=o.ContentTypes.VCALENDAR,this.useVCalendar=!0):e===o.Formats.VCARD&&(this.contentType=o.ContentTypes.VCARD,this.useVCalendar=!1)}addAddress(){let e=arguments.length>7&&void 0!==arguments[7]?arguments[7]:\"WORK;POSTAL\";const t=`${arguments.length>0&&void 0!==arguments[0]?arguments[0]:\"\"};${arguments.length>1&&void 0!==arguments[1]?arguments[1]:\"\"};${arguments.length>2&&void 0!==arguments[2]?arguments[2]:\"\"};${arguments.length>3&&void 0!==arguments[3]?arguments[3]:\"\"};${arguments.length>4&&void 0!==arguments[4]?arguments[4]:\"\"};${arguments.length>5&&void 0!==arguments[5]?arguments[5]:\"\"};${arguments.length>6&&void 0!==arguments[6]?arguments[6]:\"\"}`;return this.setProperty(\"address\",`ADR${\"\"!==e?`;${e}`:\"\"}${this.getCharsetString()}`,t),this}addBirthday(e){return this.setProperty(\"birthday\",\"BDAY\",e),this}addCompany(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:\"\";return this.setProperty(\"company\",`ORG${this.getCharsetString()}`,e+(\"\"!==t?`;${t}`:\"\")),this}addEmail(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:\"\";return this.setProperty(\"email\",\"EMAIL;INTERNET\"+(\"\"!==t?`;${t}`:\"\"),e),this}addJobtitle(e){return this.setProperty(\"jobtitle\",`TITLE${this.getCharsetString()}`,e),this}addRole(e){return this.setProperty(\"role\",`ROLE${this.getCharsetString()}`,e),this}addMediaURL(e,t,r){return this.setProperty(r,`${e};VALUE=uri`,t),this}addMediaContent(e,t,r,o){if(!(0,i.isValidMimeType)(r))throw new n.default(`The MIME Media Type is invalid (${r})`);return this.setProperty(o,`${e};ENCODING=b;TYPE=${r.toUpperCase()}`,t),this}addName(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:\"\",t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:\"\",r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:\"\",n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:\"\",i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:\"\";const o=[n,t,r,e,i].filter((e=>!!e)),s=`${e};${t};${r};${n};${i}`;return this.setProperty(\"name\",`N${this.getCharsetString()}`,s),this.hasProperty(\"FN\")||this.setProperty(\"fullname\",`FN${this.getCharsetString()}`,o.join(\" \").trim()),this}addNickname(e){return this.setProperty(\"nickname\",\"NICKNAME\",Array.isArray(e)?e.join(\",\").trim():e),this}addNote(e){return this.setProperty(\"note\",`NOTE${this.getCharsetString()}`,e),this}addCategories(e){return this.setProperty(\"categories\",`CATEGORIES${this.getCharsetString()}`,e.join(\",\").trim()),this}addPhoneNumber(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:\"\";return this.setProperty(\"phoneNumber\",\"TEL\"+(\"\"!==t?`;${t}`:\"\"),`${e}`),this}addLogoURL(e){return this.addMediaURL(\"LOGO\",e,\"logo\"),this}addLogo(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:o.DEFAULT_MIME_TYPE;return this.addMediaContent(\"LOGO\",e,t,\"logo\"),this}addPhotoURL(e){return this.addMediaURL(\"PHOTO\",e,\"photo\"),this}addPhoto(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:o.DEFAULT_MIME_TYPE;return this.addMediaContent(\"PHOTO\",e,t,\"photo\"),this}addURL(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:\"\";return this.setProperty(\"url\",\"URL\"+(\"\"!==t?`;${t}`:\"\"),e),this}addSocial(e,t){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:\"\";const n=\"\"!==r?`;x-user=${r}`:\"\",i=\"\"!==t?`;type=${t}`:\"\";return this.setProperty(\"social\",`X-SOCIALPROFILE${i}${n}`,e),this}addUID(e){return this.setProperty(\"uid\",\"UID\",e),this}buildVCard(){const e=new Date;let t=\"\";return t+=\"BEGIN:VCARD\\r\\n\",t+=\"VERSION:3.0\\r\\n\",t+=`REV:${e.toISOString()}\\r\\n`,this.getProperties().forEach((e=>{t+=(0,i.fold)(`${e.key}:${(0,i.escape)(e.value)}\\r\\n`)})),t+=\"END:VCARD\\r\\n\",t}buildVCalendar(){console.warn(\"The method 'buildVCalendar' is deprecated and will be removed in the next major or minor release. Use 'buildVCard' instead.\");const e=(new Date).toISOString().replace(/-/g,\"\").replace(/:/g,\"\").substring(0,13),t=`${e}00`,r=`${e}01`,n=(0,i.b64encode)(this.buildVCard()),o=(0,i.chunkSplit)(n,74,\"\\n\").replace(/(.+)/g,\" $1\");return`BEGIN:VCALENDAR\\nVERSION:2.0\\nBEGIN:VEVENT\\nDTSTART;TZID=Europe/London:${t}\\nDTEND;TZID=Europe/London:${r}\\nSUMMARY:Click the attachment to save to your contacts\\nDTSTAMP:${t}Z\\nATTACH;VALUE=BINARY;ENCODING=BASE64;FMTTYPE=text/directory;\\n X-APPLE-FILENAME=${this.getFilename()}.${this.getFileExtension()}:\\n${o}END:VEVENT\\nEND:VCALENDAR\\n`}toString(){return this.getOutput()}getCharset(){return this.charset}getCharsetString(){let e=\"\";return this.charset===o.DEFAULT_CHARACTER_SET&&(e=`;CHARSET=${this.charset}`),e}getContentType(){return this.contentType}getFilename(){return this.filename}getFileExtension(){return this.fileExtension}getOutput(){return this.useVCalendar?this.buildVCalendar():this.buildVCard()}getProperties(){return this.properties}hasProperty(e){return this.getProperties().some((t=>t.key===e&&\"\"!==t.value))}setCharset(e){this.charset=e}setFilename(e){e&&(this.filename=e)}setProperty(e,t,r){if(!this.multiplePropertiesForElementAllowed.includes(e)&&this.definedElements[e])throw new n.default(`This element already exists (${e})`);this.definedElements[e]=!0,this.properties.push({key:t,value:r})}}},void 0===(o=n.apply(t,i))||(e.exports=o)},871:e=>{function t(r){return e.exports=t=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&\"function\"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?\"symbol\":typeof e},e.exports.__esModule=!0,e.exports.default=e.exports,t(r)}e.exports=t,e.exports.__esModule=!0,e.exports.default=e.exports},957:e=>{e.exports=function(e){return e&&e.__esModule?e:{default:e}},e.exports.__esModule=!0,e.exports.default=e.exports},979:function(e,t,r){var n,i,o;\"undefined\"!=typeof globalThis?globalThis:\"undefined\"!=typeof self&&self,i=[t,r(215)],n=function(e,t){\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.b64encode=function(e){try{return btoa(e)}catch{return Buffer.from(e).toString(\"base64\")}},e.chunkSplit=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:76;const r=t||76,n=(arguments.length>2&&void 0!==arguments[2]?arguments[2]:\"\\r\\n\")||\"\\r\\n\";if(t<1)return\"\";const i=e.match(new RegExp(`.{0,${r}}`,\"g\"));return i?i.join(n):\"\"},e.escape=function(e){let t=`${e}`.replace(/\\r\\n/g,\"\\\\n\");return t=t.replace(/\\n/g,\"\\\\n\"),t},e.fold=function(e){return e.length<=75?e:`${(e.match(/.{1,73}/g)||[]).join(\"\\r\\n \").trim()}\\r\\n`},e.isValidMimeType=function(e){return!(!e||!t.MIME_TYPES.includes(e.toLowerCase()))}},void 0===(o=n.apply(t,i))||(e.exports=o)}},t={},function r(n){var i=t[n];if(void 0!==i)return i.exports;var o=t[n]={exports:{}};return e[n].call(o.exports,o,o.exports,r),o.exports}(136);var e,t}));","import { NextResponse } from \"next/server\";\nimport sharp from \"sharp\";\nimport VCard from \"vcard-creator\";\n\nimport { USER } from \"@/features/profile/data/user\";\nimport { decodeEmail, decodePhoneNumber } from \"@/utils/string\";\n\nexport const dynamic = \"force-static\";\n\nexport async function GET() {\n  const card = new VCard();\n\n  card\n    .addName(USER.lastName, USER.firstName)\n    .addPhoneNumber(decodePhoneNumber(USER.phoneNumber))\n    .addAddress(USER.address)\n    .addEmail(decodeEmail(USER.email))\n    .addURL(USER.website);\n\n  const photo = await getVCardPhoto(USER.avatar);\n  if (photo) {\n    card.addPhoto(photo.image, photo.mine);\n  }\n\n  if (USER.jobs.length > 0) {\n    const company = USER.jobs[0];\n    card.addCompany(company.company).addJobtitle(company.title);\n  }\n\n  return new NextResponse(card.toString(), {\n    status: 200,\n    headers: {\n      \"Content-Type\": \"text/x-vcard\",\n      \"Content-Disposition\": `attachment; filename=${USER.username}-vcard.vcf`,\n    },\n  });\n}\n\nasync function getVCardPhoto(url: string) {\n  try {\n    const res = await fetch(url);\n\n    if (!res.ok) {\n      return null;\n    }\n\n    const buffer = Buffer.from(await res.arrayBuffer());\n    if (buffer.length === 0) {\n      return null;\n    }\n\n    const contentType = res.headers.get(\"Content-Type\") || \"\";\n    if (!contentType.startsWith(\"image/\")) {\n      return null;\n    }\n\n    const jpegBuffer = await convertImageToJpeg(buffer);\n    const image = jpegBuffer.toString(\"base64\");\n\n    return {\n      image,\n      mine: \"jpeg\",\n    };\n  } catch {\n    return null;\n  }\n}\n\nasync function convertImageToJpeg(imageBuffer: Buffer): Promise<Buffer> {\n  try {\n    const jpegBuffer = await sharp(imageBuffer)\n      .jpeg({\n        quality: 90,\n        progressive: true,\n        mozjpeg: true,\n      })\n      .toBuffer();\n\n    return jpegBuffer;\n  } catch (error) {\n    console.error(\"Error converting image to JPEG:\", error);\n    throw error;\n  }\n}\n","import { AppRouteRouteModule } from \"next/dist/esm/server/route-modules/app-route/module.compiled\";\nimport { RouteKind } from \"next/dist/esm/server/route-kind\";\nimport { patchFetch as _patchFetch } from \"next/dist/esm/server/lib/patch-fetch\";\nimport { addRequestMeta, getRequestMeta } from \"next/dist/esm/server/request-meta\";\nimport { getTracer, SpanKind } from \"next/dist/esm/server/lib/trace/tracer\";\nimport { setReferenceManifestsSingleton } from \"next/dist/esm/server/app-render/encryption-utils\";\nimport { createServerModuleMap } from \"next/dist/esm/server/app-render/action-utils\";\nimport { normalizeAppPath } from \"next/dist/esm/shared/lib/router/utils/app-paths\";\nimport { NodeNextRequest, NodeNextResponse } from \"next/dist/esm/server/base-http/node\";\nimport { NextRequestAdapter, signalFromNodeResponse } from \"next/dist/esm/server/web/spec-extension/adapters/next-request\";\nimport { BaseServerSpan } from \"next/dist/esm/server/lib/trace/constants\";\nimport { getRevalidateReason } from \"next/dist/esm/server/instrumentation/utils\";\nimport { sendResponse } from \"next/dist/esm/server/send-response\";\nimport { fromNodeOutgoingHttpHeaders, toNodeOutgoingHttpHeaders } from \"next/dist/esm/server/web/utils\";\nimport { getCacheControlHeader } from \"next/dist/esm/server/lib/cache-control\";\nimport { INFINITE_CACHE, NEXT_CACHE_TAGS_HEADER } from \"next/dist/esm/lib/constants\";\nimport { NoFallbackError } from \"next/dist/esm/shared/lib/no-fallback-error.external\";\nimport { CachedRouteKind } from \"next/dist/esm/server/response-cache\";\nimport * as userland from \"INNER_APP_ROUTE\";\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"\"\nconst routeModule = new AppRouteRouteModule({\n    definition: {\n        kind: RouteKind.APP_ROUTE,\n        page: \"/vcard/route\",\n        pathname: \"/vcard\",\n        filename: \"route\",\n        bundlePath: \"\"\n    },\n    distDir: process.env.__NEXT_RELATIVE_DIST_DIR || '',\n    relativeProjectDir: process.env.__NEXT_RELATIVE_PROJECT_DIR || '',\n    resolvedPagePath: \"[project]/src/app/vcard/route.ts\",\n    nextConfigOutput,\n    userland\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { workAsyncStorage, workUnitAsyncStorage, serverHooks } = routeModule;\nfunction patchFetch() {\n    return _patchFetch({\n        workAsyncStorage,\n        workUnitAsyncStorage\n    });\n}\nexport { routeModule, workAsyncStorage, workUnitAsyncStorage, serverHooks, patchFetch,  };\nexport async function handler(req, res, ctx) {\n    if (routeModule.isDev) {\n        addRequestMeta(req, 'devRequestTimingInternalsEnd', process.hrtime.bigint());\n    }\n    let srcPage = \"/vcard/route\";\n    // turbopack doesn't normalize `/index` in the page name\n    // so we need to to process dynamic routes properly\n    // TODO: fix turbopack providing differing value from webpack\n    if (process.env.TURBOPACK) {\n        srcPage = srcPage.replace(/\\/index$/, '') || '/';\n    } else if (srcPage === '/index') {\n        // we always normalize /index specifically\n        srcPage = '/';\n    }\n    const multiZoneDraftMode = process.env.__NEXT_MULTI_ZONE_DRAFT_MODE;\n    const prepareResult = await routeModule.prepare(req, res, {\n        srcPage,\n        multiZoneDraftMode\n    });\n    if (!prepareResult) {\n        res.statusCode = 400;\n        res.end('Bad Request');\n        ctx.waitUntil == null ? void 0 : ctx.waitUntil.call(ctx, Promise.resolve());\n        return null;\n    }\n    const { buildId, params, nextConfig, parsedUrl, isDraftMode, prerenderManifest, routerServerContext, isOnDemandRevalidate, revalidateOnlyGenerated, resolvedPathname, clientReferenceManifest, serverActionsManifest } = prepareResult;\n    const normalizedSrcPage = normalizeAppPath(srcPage);\n    let isIsr = Boolean(prerenderManifest.dynamicRoutes[normalizedSrcPage] || prerenderManifest.routes[resolvedPathname]);\n    const render404 = async ()=>{\n        // TODO: should route-module itself handle rendering the 404\n        if (routerServerContext == null ? void 0 : routerServerContext.render404) {\n            await routerServerContext.render404(req, res, parsedUrl, false);\n        } else {\n            res.end('This page could not be found');\n        }\n        return null;\n    };\n    if (isIsr && !isDraftMode) {\n        const isPrerendered = Boolean(prerenderManifest.routes[resolvedPathname]);\n        const prerenderInfo = prerenderManifest.dynamicRoutes[normalizedSrcPage];\n        if (prerenderInfo) {\n            if (prerenderInfo.fallback === false && !isPrerendered) {\n                if (nextConfig.experimental.adapterPath) {\n                    return await render404();\n                }\n                throw new NoFallbackError();\n            }\n        }\n    }\n    let cacheKey = null;\n    if (isIsr && !routeModule.isDev && !isDraftMode) {\n        cacheKey = resolvedPathname;\n        // ensure /index and / is normalized to one key\n        cacheKey = cacheKey === '/index' ? '/' : cacheKey;\n    }\n    const supportsDynamicResponse = // If we're in development, we always support dynamic HTML\n    routeModule.isDev === true || // If this is not SSG or does not have static paths, then it supports\n    // dynamic HTML.\n    !isIsr;\n    // This is a revalidation request if the request is for a static\n    // page and it is not being resumed from a postponed render and\n    // it is not a dynamic RSC request then it is a revalidation\n    // request.\n    const isStaticGeneration = isIsr && !supportsDynamicResponse;\n    // Before rendering (which initializes component tree modules), we have to\n    // set the reference manifests to our global store so Server Action's\n    // encryption util can access to them at the top level of the page module.\n    if (serverActionsManifest && clientReferenceManifest) {\n        setReferenceManifestsSingleton({\n            page: srcPage,\n            clientReferenceManifest,\n            serverActionsManifest,\n            serverModuleMap: createServerModuleMap({\n                serverActionsManifest\n            })\n        });\n    }\n    const method = req.method || 'GET';\n    const tracer = getTracer();\n    const activeSpan = tracer.getActiveScopeSpan();\n    const context = {\n        params,\n        prerenderManifest,\n        renderOpts: {\n            experimental: {\n                authInterrupts: Boolean(nextConfig.experimental.authInterrupts)\n            },\n            cacheComponents: Boolean(nextConfig.cacheComponents),\n            supportsDynamicResponse,\n            incrementalCache: getRequestMeta(req, 'incrementalCache'),\n            cacheLifeProfiles: nextConfig.cacheLife,\n            waitUntil: ctx.waitUntil,\n            onClose: (cb)=>{\n                res.on('close', cb);\n            },\n            onAfterTaskError: undefined,\n            onInstrumentationRequestError: (error, _request, errorContext)=>routeModule.onRequestError(req, error, errorContext, routerServerContext)\n        },\n        sharedContext: {\n            buildId\n        }\n    };\n    const nodeNextReq = new NodeNextRequest(req);\n    const nodeNextRes = new NodeNextResponse(res);\n    const nextReq = NextRequestAdapter.fromNodeNextRequest(nodeNextReq, signalFromNodeResponse(res));\n    try {\n        const invokeRouteModule = async (span)=>{\n            return routeModule.handle(nextReq, context).finally(()=>{\n                if (!span) return;\n                span.setAttributes({\n                    'http.status_code': res.statusCode,\n                    'next.rsc': false\n                });\n                const rootSpanAttributes = tracer.getRootSpanAttributes();\n                // We were unable to get attributes, probably OTEL is not enabled\n                if (!rootSpanAttributes) {\n                    return;\n                }\n                if (rootSpanAttributes.get('next.span_type') !== BaseServerSpan.handleRequest) {\n                    console.warn(`Unexpected root span type '${rootSpanAttributes.get('next.span_type')}'. Please report this Next.js issue https://github.com/vercel/next.js`);\n                    return;\n                }\n                const route = rootSpanAttributes.get('next.route');\n                if (route) {\n                    const name = `${method} ${route}`;\n                    span.setAttributes({\n                        'next.route': route,\n                        'http.route': route,\n                        'next.span_name': name\n                    });\n                    span.updateName(name);\n                } else {\n                    span.updateName(`${method} ${srcPage}`);\n                }\n            });\n        };\n        const isMinimalMode = Boolean(process.env.MINIMAL_MODE || getRequestMeta(req, 'minimalMode'));\n        const handleResponse = async (currentSpan)=>{\n            var _cacheEntry_value;\n            const responseGenerator = async ({ previousCacheEntry })=>{\n                try {\n                    if (!isMinimalMode && isOnDemandRevalidate && revalidateOnlyGenerated && !previousCacheEntry) {\n                        res.statusCode = 404;\n                        // on-demand revalidate always sets this header\n                        res.setHeader('x-nextjs-cache', 'REVALIDATED');\n                        res.end('This page could not be found');\n                        return null;\n                    }\n                    const response = await invokeRouteModule(currentSpan);\n                    req.fetchMetrics = context.renderOpts.fetchMetrics;\n                    let pendingWaitUntil = context.renderOpts.pendingWaitUntil;\n                    // Attempt using provided waitUntil if available\n                    // if it's not we fallback to sendResponse's handling\n                    if (pendingWaitUntil) {\n                        if (ctx.waitUntil) {\n                            ctx.waitUntil(pendingWaitUntil);\n                            pendingWaitUntil = undefined;\n                        }\n                    }\n                    const cacheTags = context.renderOpts.collectedTags;\n                    // If the request is for a static response, we can cache it so long\n                    // as it's not edge.\n                    if (isIsr) {\n                        const blob = await response.blob();\n                        // Copy the headers from the response.\n                        const headers = toNodeOutgoingHttpHeaders(response.headers);\n                        if (cacheTags) {\n                            headers[NEXT_CACHE_TAGS_HEADER] = cacheTags;\n                        }\n                        if (!headers['content-type'] && blob.type) {\n                            headers['content-type'] = blob.type;\n                        }\n                        const revalidate = typeof context.renderOpts.collectedRevalidate === 'undefined' || context.renderOpts.collectedRevalidate >= INFINITE_CACHE ? false : context.renderOpts.collectedRevalidate;\n                        const expire = typeof context.renderOpts.collectedExpire === 'undefined' || context.renderOpts.collectedExpire >= INFINITE_CACHE ? undefined : context.renderOpts.collectedExpire;\n                        // Create the cache entry for the response.\n                        const cacheEntry = {\n                            value: {\n                                kind: CachedRouteKind.APP_ROUTE,\n                                status: response.status,\n                                body: Buffer.from(await blob.arrayBuffer()),\n                                headers\n                            },\n                            cacheControl: {\n                                revalidate,\n                                expire\n                            }\n                        };\n                        return cacheEntry;\n                    } else {\n                        // send response without caching if not ISR\n                        await sendResponse(nodeNextReq, nodeNextRes, response, context.renderOpts.pendingWaitUntil);\n                        return null;\n                    }\n                } catch (err) {\n                    // if this is a background revalidate we need to report\n                    // the request error here as it won't be bubbled\n                    if (previousCacheEntry == null ? void 0 : previousCacheEntry.isStale) {\n                        await routeModule.onRequestError(req, err, {\n                            routerKind: 'App Router',\n                            routePath: srcPage,\n                            routeType: 'route',\n                            revalidateReason: getRevalidateReason({\n                                isStaticGeneration,\n                                isOnDemandRevalidate\n                            })\n                        }, routerServerContext);\n                    }\n                    throw err;\n                }\n            };\n            const cacheEntry = await routeModule.handleResponse({\n                req,\n                nextConfig,\n                cacheKey,\n                routeKind: RouteKind.APP_ROUTE,\n                isFallback: false,\n                prerenderManifest,\n                isRoutePPREnabled: false,\n                isOnDemandRevalidate,\n                revalidateOnlyGenerated,\n                responseGenerator,\n                waitUntil: ctx.waitUntil,\n                isMinimalMode\n            });\n            // we don't create a cacheEntry for ISR\n            if (!isIsr) {\n                return null;\n            }\n            if ((cacheEntry == null ? void 0 : (_cacheEntry_value = cacheEntry.value) == null ? void 0 : _cacheEntry_value.kind) !== CachedRouteKind.APP_ROUTE) {\n                var _cacheEntry_value1;\n                throw Object.defineProperty(new Error(`Invariant: app-route received invalid cache entry ${cacheEntry == null ? void 0 : (_cacheEntry_value1 = cacheEntry.value) == null ? void 0 : _cacheEntry_value1.kind}`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E701\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n            if (!isMinimalMode) {\n                res.setHeader('x-nextjs-cache', isOnDemandRevalidate ? 'REVALIDATED' : cacheEntry.isMiss ? 'MISS' : cacheEntry.isStale ? 'STALE' : 'HIT');\n            }\n            // Draft mode should never be cached\n            if (isDraftMode) {\n                res.setHeader('Cache-Control', 'private, no-cache, no-store, max-age=0, must-revalidate');\n            }\n            const headers = fromNodeOutgoingHttpHeaders(cacheEntry.value.headers);\n            if (!(isMinimalMode && isIsr)) {\n                headers.delete(NEXT_CACHE_TAGS_HEADER);\n            }\n            // If cache control is already set on the response we don't\n            // override it to allow users to customize it via next.config\n            if (cacheEntry.cacheControl && !res.getHeader('Cache-Control') && !headers.get('Cache-Control')) {\n                headers.set('Cache-Control', getCacheControlHeader(cacheEntry.cacheControl));\n            }\n            await sendResponse(nodeNextReq, nodeNextRes, // @ts-expect-error - Argument of type 'Buffer<ArrayBufferLike>' is not assignable to parameter of type 'BodyInit | null | undefined'.\n            new Response(cacheEntry.value.body, {\n                headers,\n                status: cacheEntry.value.status || 200\n            }));\n            return null;\n        };\n        // TODO: activeSpan code path is for when wrapped by\n        // next-server can be removed when this is no longer used\n        if (activeSpan) {\n            await handleResponse(activeSpan);\n        } else {\n            await tracer.withPropagatedContext(req.headers, ()=>tracer.trace(BaseServerSpan.handleRequest, {\n                    spanName: `${method} ${srcPage}`,\n                    kind: SpanKind.SERVER,\n                    attributes: {\n                        'http.method': method,\n                        'http.target': req.url\n                    }\n                }, handleResponse));\n        }\n    } catch (err) {\n        if (!(err instanceof NoFallbackError)) {\n            await routeModule.onRequestError(req, err, {\n                routerKind: 'App Router',\n                routePath: normalizedSrcPage,\n                routeType: 'route',\n                revalidateReason: getRevalidateReason({\n                    isStaticGeneration,\n                    isOnDemandRevalidate\n                })\n            });\n        }\n        // rethrow so that we can handle serving error page\n        // If this is during static generation, throw the error again.\n        if (isIsr) throw err;\n        // Otherwise, send a 500 response.\n        await sendResponse(nodeNextReq, nodeNextRes, new Response(null, {\n            status: 500\n        }));\n        return null;\n    }\n}\n\n//# sourceMappingURL=app-route.js.map\n","const objectConstructor = {}.constructor;\r\n\r\nexport default function isObject(object) {\r\n  return object !== undefined && object !== null && object.constructor === objectConstructor;\r\n}\r\n","import Metadata from '../metadata.js'\r\n\r\n/**\r\n * Returns a list of countries that the phone number could potentially belong to.\r\n * @param  {string} callingCode — Calling code.\r\n * @param  {string} nationalNumber — National (significant) number.\r\n * @param  {object} metadata — Metadata.\r\n * @return {string[]} A list of possible countries.\r\n */\r\nexport default function getPossibleCountriesForNumber(callingCode, nationalNumber, metadata) {\r\n\tconst _metadata = new Metadata(metadata)\r\n\tlet possibleCountries = _metadata.getCountryCodesForCallingCode(callingCode)\r\n\tif (!possibleCountries) {\r\n\t\treturn []\r\n\t}\r\n\treturn possibleCountries.filter((country) => {\r\n\t\treturn couldNationalNumberBelongToCountry(nationalNumber, country, metadata)\r\n\t})\r\n}\r\n\r\nfunction couldNationalNumberBelongToCountry(nationalNumber, country, metadata) {\r\n\tconst _metadata = new Metadata(metadata)\r\n\t_metadata.selectNumberingPlan(country)\r\n\tif (_metadata.numberingPlan.possibleLengths().indexOf(nationalNumber.length) >= 0) {\r\n\t\treturn true\r\n\t}\r\n\treturn false\r\n}","import getCountryByNationalNumber from './getCountryByNationalNumber.js'\r\n\r\nconst USE_NON_GEOGRAPHIC_COUNTRY_CODE = false\r\n\r\n// Returns the exact country for the `nationalNumber`\r\n// that belongs to the specified \"country calling code\".\r\nexport default function getCountryByCallingCode(callingCode, {\r\n\tnationalNumber: nationalPhoneNumber,\r\n\tmetadata\r\n}) {\r\n\t/* istanbul ignore if */\r\n\tif (USE_NON_GEOGRAPHIC_COUNTRY_CODE) {\r\n\t\tif (metadata.isNonGeographicCallingCode(callingCode)) {\r\n\t\t\treturn '001'\r\n\t\t}\r\n\t}\r\n\tconst possibleCountries = metadata.getCountryCodesForCallingCode(callingCode)\r\n\tif (!possibleCountries) {\r\n\t\treturn\r\n\t}\r\n\t// If there's just one country corresponding to the country code,\r\n\t// then just return it, without further phone number digits validation.\r\n\tif (possibleCountries.length === 1) {\r\n\t\treturn possibleCountries[0]\r\n\t}\r\n\treturn getCountryByNationalNumber(nationalPhoneNumber, {\r\n\t\tcountries: possibleCountries,\r\n\t\tmetadata: metadata.metadata\r\n\t})\r\n}","import extractNationalNumberFromPossiblyIncompleteNumber from './extractNationalNumberFromPossiblyIncompleteNumber.js'\r\nimport matchesEntirely from './matchesEntirely.js'\r\nimport checkNumberLength from './checkNumberLength.js'\r\nimport getCountryByCallingCode from './getCountryByCallingCode.js'\r\n\r\n/**\r\n * Strips national prefix and carrier code from a complete phone number.\r\n * The difference from the non-\"FromCompleteNumber\" function is that\r\n * it won't extract national prefix if the resultant number is too short\r\n * to be a complete number for the selected phone numbering plan.\r\n * @param  {string} number — Complete phone number digits.\r\n * @param  {string?} country — Country, if known.\r\n * @param  {Metadata} metadata — Metadata with a phone numbering plan selected.\r\n * @return {object} `{ nationalNumber: string, carrierCode: string? }`.\r\n */\r\nexport default function extractNationalNumber(number, country, metadata) {\r\n\t// Parsing national prefixes and carrier codes\r\n\t// is only required for local phone numbers\r\n\t// but some people don't understand that\r\n\t// and sometimes write international phone numbers\r\n\t// with national prefixes (or maybe even carrier codes).\r\n\t// http://ucken.blogspot.ru/2016/03/trunk-prefixes-in-skype4b.html\r\n\t// Google's original library forgives such mistakes\r\n\t// and so does this library, because it has been requested:\r\n\t// https://github.com/catamphetamine/libphonenumber-js/issues/127\r\n\tconst {\r\n\t\tcarrierCode,\r\n\t\tnationalNumber\r\n\t} = extractNationalNumberFromPossiblyIncompleteNumber(\r\n\t\tnumber,\r\n\t\tmetadata\r\n\t)\r\n\r\n\tif (nationalNumber !== number) {\r\n\t\tif (!shouldHaveExtractedNationalPrefix(number, nationalNumber, metadata)) {\r\n\t\t\t// Don't strip the national prefix.\r\n\t\t\treturn { nationalNumber: number }\r\n\t\t}\r\n\t\t// Check the national (significant) number length after extracting national prefix and carrier code.\r\n\t\t// Legacy generated metadata (before `1.0.18`) didn't support the \"possible lengths\" feature.\r\n\t\tif (metadata.numberingPlan.possibleLengths()) {\r\n\t\t\t// If an exact `country` is not specified, attempt to detect it from the assumed national number.\r\n\t\t\tif (!country) {\r\n\t\t\t\tcountry = getCountryByCallingCode(metadata.numberingPlan.callingCode(), {\r\n\t\t\t\t\tnationalNumber,\r\n\t\t\t\t\tmetadata\r\n\t\t\t\t})\r\n\t\t\t}\r\n\r\n\t\t\t// The number remaining after stripping the national prefix and carrier code\r\n\t\t\t// should be long enough to have a possible length for the country.\r\n\t\t\t// Otherwise, don't strip the national prefix and carrier code,\r\n\t\t\t// since the original number could be a valid number.\r\n\t\t\t// This check has been copy-pasted \"as is\" from Google's original library:\r\n\t\t\t// https://github.com/google/libphonenumber/blob/876268eb1ad6cdc1b7b5bef17fc5e43052702d57/java/libphonenumber/src/com/google/i18n/phonenumbers/PhoneNumberUtil.java#L3236-L3250\r\n\t\t\t// It doesn't check for the \"possibility\" of the original `number`.\r\n\t\t\t// I guess it's fine not checking that one. It works as is anyway.\r\n\t\t\tif (!isPossibleIncompleteNationalNumber(nationalNumber, country, metadata)) {\r\n\t\t\t\t// Don't strip the national prefix.\r\n\t\t\t\treturn { nationalNumber: number }\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn { nationalNumber, carrierCode }\r\n}\r\n\r\n// In some countries, the same digit could be a national prefix\r\n// or a leading digit of a valid phone number.\r\n// For example, in Russia, national prefix is `8`,\r\n// and also `800 555 35 35` is a valid number\r\n// in which `8` is not a national prefix, but the first digit\r\n// of a national (significant) number.\r\n// Same's with Belarus:\r\n// `82004910060` is a valid national (significant) number,\r\n// but `2004910060` is not.\r\n// To support such cases (to prevent the code from always stripping\r\n// national prefix), a condition is imposed: a national prefix\r\n// is not extracted when the original number is \"viable\" and the\r\n// resultant number is not, a \"viable\" national number being the one\r\n// that matches `national_number_pattern`.\r\nfunction shouldHaveExtractedNationalPrefix(nationalNumberBefore, nationalNumberAfter, metadata) {\r\n\t// The equivalent in Google's code is:\r\n\t// https://github.com/google/libphonenumber/blob/e326fa1fc4283bb05eb35cb3c15c18f98a31af33/java/libphonenumber/src/com/google/i18n/phonenumbers/PhoneNumberUtil.java#L2969-L3004\r\n\tif (matchesEntirely(nationalNumberBefore, metadata.nationalNumberPattern()) &&\r\n\t\t!matchesEntirely(nationalNumberAfter, metadata.nationalNumberPattern())) {\r\n\t\treturn false\r\n\t}\r\n\t// This \"is possible\" national number (length) check has been commented out\r\n\t// because it's superceded by the (effectively) same check done in the\r\n\t// `extractNationalNumber()` function after it calls `shouldHaveExtractedNationalPrefix()`.\r\n\t// In other words, why run the same check twice if it could only be run once.\r\n\t// // Check the national (significant) number length after extracting national prefix and carrier code.\r\n\t// // Fixes a minor \"weird behavior\" bug: https://gitlab.com/catamphetamine/libphonenumber-js/-/issues/57\r\n\t// // (Legacy generated metadata (before `1.0.18`) didn't support the \"possible lengths\" feature).\r\n\t// if (metadata.possibleLengths()) {\r\n\t// \tif (isPossibleIncompleteNationalNumber(nationalNumberBefore, metadata) &&\r\n\t// \t\t!isPossibleIncompleteNationalNumber(nationalNumberAfter, metadata)) {\r\n\t// \t\treturn false\r\n\t// \t}\r\n\t// }\r\n\treturn true\r\n}\r\n\r\nfunction isPossibleIncompleteNationalNumber(nationalNumber, country, metadata) {\r\n\tswitch (checkNumberLength(nationalNumber, country, metadata)) {\r\n\t\tcase 'TOO_SHORT':\r\n\t\tcase 'INVALID_LENGTH':\r\n\t\t// This library ignores \"local-only\" phone numbers (for simplicity).\r\n\t\t// See the readme for more info on what are \"local-only\" phone numbers.\r\n\t\t// case 'IS_POSSIBLE_LOCAL_ONLY':\r\n\t\t\treturn false\r\n\t\tdefault:\r\n\t\t\treturn true\r\n\t}\r\n}","import Metadata from './metadata.js'\r\nimport matchesEntirely from './helpers/matchesEntirely.js'\r\nimport getNumberType from './helpers/getNumberType.js'\r\n\r\n/**\r\n * Checks if a given phone number is valid.\r\n *\r\n * isValid(phoneNumberInstance, { ..., v2: true }, metadata)\r\n *\r\n * isPossible({ phone: '8005553535', country: 'RU' }, { ... }, metadata)\r\n * isPossible({ phone: '8005553535', country: 'RU' }, undefined, metadata)\r\n *\r\n * If the `number` is a string, it will be parsed to an object,\r\n * but only if it contains only valid phone number characters (including punctuation).\r\n * If the `number` is an object, it is used as is.\r\n *\r\n * The optional `defaultCountry` argument is the default country.\r\n * I.e. it does not restrict to just that country,\r\n * e.g. in those cases where several countries share\r\n * the same phone numbering rules (NANPA, Britain, etc).\r\n * For example, even though the number `07624 369230`\r\n * belongs to the Isle of Man (\"IM\" country code)\r\n * calling `isValidNumber('07624369230', 'GB', metadata)`\r\n * still returns `true` because the country is not restricted to `GB`,\r\n * it's just that `GB` is the default one for the phone numbering rules.\r\n * For restricting the country see `isValidNumberForRegion()`\r\n * though restricting a country might not be a good idea.\r\n * https://github.com/googlei18n/libphonenumber/blob/master/FAQ.md#when-should-i-use-isvalidnumberforregion\r\n *\r\n * Examples:\r\n *\r\n * ```js\r\n * isValidNumber('+78005553535', metadata)\r\n * isValidNumber('8005553535', 'RU', metadata)\r\n * isValidNumber('88005553535', 'RU', metadata)\r\n * isValidNumber({ phone: '8005553535', country: 'RU' }, metadata)\r\n * ```\r\n */\r\nexport default function isValidNumber(input, options, metadata)\r\n{\r\n\t// If assigning the `{}` default value is moved to the arguments above,\r\n\t// code coverage would decrease for some weird reason.\r\n\toptions = options || {}\r\n\r\n\tmetadata = new Metadata(metadata)\r\n\r\n\tmetadata.selectNumberingPlan(input.country, input.countryCallingCode)\r\n\r\n\t// By default, countries only have type regexps when it's required for\r\n\t// distinguishing different countries having the same `countryCallingCode`.\r\n\tif (metadata.hasTypes()) {\r\n\t\treturn getNumberType(input, options, metadata.metadata) !== undefined\r\n\t}\r\n\r\n\t// If there are no type regexps for this country in metadata then use\r\n\t// `nationalNumberPattern` as a \"better than nothing\" replacement.\r\n\tconst nationalNumber = options.v2 ? input.nationalNumber : input.phone\r\n\treturn matchesEntirely(nationalNumber, metadata.nationalNumberPattern())\r\n}","import Metadata from '../metadata.js'\r\nimport matchesEntirely from './matchesEntirely.js'\r\nimport extractNationalNumber from './extractNationalNumber.js'\r\nimport checkNumberLength from './checkNumberLength.js'\r\nimport getCountryCallingCode from '../getCountryCallingCode.js'\r\n\r\n/**\r\n * Sometimes some people incorrectly input international phone numbers\r\n * without the leading `+`. This function corrects such input.\r\n * @param  {string} number — Phone number digits.\r\n * @param  {string} [country] — Exact country of the phone number.\r\n * @param  {string} [defaultCountry]\r\n * @param  {string} [defaultCallingCode]\r\n * @param  {object} metadata\r\n * @return {object} `{ countryCallingCode: string?, number: string }`.\r\n */\r\nexport default function extractCountryCallingCodeFromInternationalNumberWithoutPlusSign(\r\n\tnumber,\r\n\tcountry,\r\n\tdefaultCountry,\r\n\tdefaultCallingCode,\r\n\tmetadata\r\n) {\r\n\tconst countryCallingCode = country || defaultCountry\r\n\t\t? getCountryCallingCode(country || defaultCountry, metadata)\r\n\t\t: defaultCallingCode\r\n\r\n\tif (number.indexOf(countryCallingCode) === 0) {\r\n\t\tmetadata = new Metadata(metadata)\r\n\t\tmetadata.selectNumberingPlan(country || defaultCountry, countryCallingCode)\r\n\r\n\t\tconst possibleShorterNumber = number.slice(countryCallingCode.length)\r\n\r\n\t\tconst {\r\n\t\t\tnationalNumber: possibleShorterNationalNumber,\r\n\t\t} = extractNationalNumber(\r\n\t\t\tpossibleShorterNumber,\r\n\t\t\tcountry,\r\n\t\t\tmetadata\r\n\t\t)\r\n\r\n\t\tconst {\r\n\t\t\tnationalNumber\r\n\t\t} = extractNationalNumber(\r\n\t\t\tnumber,\r\n\t\t\tcountry,\r\n\t\t\tmetadata\r\n\t\t)\r\n\r\n\t\t// If the number was not valid before but is valid now,\r\n\t\t// or if it was too long before, we consider the number\r\n\t\t// with the country calling code stripped to be a better result\r\n\t\t// and keep that instead.\r\n\t\t// For example, in Germany (+49), `49` is a valid area code,\r\n\t\t// so if a number starts with `49`, it could be both a valid\r\n\t\t// national German number or an international number without\r\n\t\t// a leading `+`.\r\n\t\tif (\r\n\t\t\t(\r\n\t\t\t\t!matchesEntirely(nationalNumber, metadata.nationalNumberPattern()) &&\r\n\t\t\t\tmatchesEntirely(possibleShorterNationalNumber, metadata.nationalNumberPattern())\r\n\t\t\t)\r\n\t\t\t||\r\n\t\t\tcheckNumberLength(nationalNumber, country, metadata) === 'TOO_LONG'\r\n\t\t) {\r\n\t\t\treturn {\r\n\t\t\t\tcountryCallingCode,\r\n\t\t\t\tnumber: possibleShorterNumber\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn { number }\r\n}","import stripIddPrefix from './stripIddPrefix.js'\r\nimport extractCountryCallingCodeFromInternationalNumberWithoutPlusSign from './extractCountryCallingCodeFromInternationalNumberWithoutPlusSign.js'\r\nimport Metadata from '../metadata.js'\r\nimport { MAX_LENGTH_COUNTRY_CODE } from '../constants.js'\r\n\r\n/**\r\n * Converts a phone number digits (possibly with a `+`)\r\n * into a calling code and the rest phone number digits.\r\n * The \"rest phone number digits\" could include\r\n * a national prefix, carrier code, and national\r\n * (significant) number.\r\n * @param  {string} number — Phone number digits (possibly with a `+`).\r\n * @param  {string} [country] — Country.\r\n * @param  {string} [defaultCountry] — Default country.\r\n * @param  {string} [defaultCallingCode] — Default calling code (some phone numbering plans are non-geographic).\r\n * @param  {object} metadata\r\n * @return {object} `{ countryCallingCodeSource: string?, countryCallingCode: string?, number: string }`\r\n * @example\r\n * // Returns `{ countryCallingCode: \"1\", number: \"2133734253\" }`.\r\n * extractCountryCallingCode('2133734253', null, 'US', null, metadata)\r\n * extractCountryCallingCode('2133734253', null, null, '1', metadata)\r\n * extractCountryCallingCode('+12133734253', null, null, null, metadata)\r\n * extractCountryCallingCode('+12133734253', null, 'RU', null, metadata)\r\n */\r\nexport default function extractCountryCallingCode(\r\n\tnumber,\r\n\tcountry,\r\n\tdefaultCountry,\r\n\tdefaultCallingCode,\r\n\tmetadata\r\n) {\r\n\tif (!number) {\r\n\t\treturn {}\r\n\t}\r\n\r\n\tlet isNumberWithIddPrefix\r\n\r\n\t// If this is not an international phone number,\r\n\t// then either extract an \"IDD\" prefix, or extract a\r\n\t// country calling code from a number by autocorrecting it\r\n\t// by prepending a leading `+` in cases when it starts\r\n\t// with the country calling code.\r\n\t// https://wikitravel.org/en/International_dialling_prefix\r\n\t// https://github.com/catamphetamine/libphonenumber-js/issues/376\r\n\tif (number[0] !== '+') {\r\n\t\t// Convert an \"out-of-country\" dialing phone number\r\n\t\t// to a proper international phone number.\r\n\t\tconst numberWithoutIDD = stripIddPrefix(number, country || defaultCountry, defaultCallingCode, metadata)\r\n\t\t// If an IDD prefix was stripped then\r\n\t\t// convert the number to international one\r\n\t\t// for subsequent parsing.\r\n\t\tif (numberWithoutIDD && numberWithoutIDD !== number) {\r\n\t\t\tisNumberWithIddPrefix = true\r\n\t\t\tnumber = '+' + numberWithoutIDD\r\n\t\t} else {\r\n\t\t\t// Check to see if the number starts with the country calling code\r\n\t\t\t// for the default country. If so, we remove the country calling code,\r\n\t\t\t// and do some checks on the validity of the number before and after.\r\n\t\t\t// https://github.com/catamphetamine/libphonenumber-js/issues/376\r\n\t\t\tif (country || defaultCountry || defaultCallingCode) {\r\n\t\t\t\tconst {\r\n\t\t\t\t\tcountryCallingCode,\r\n\t\t\t\t\tnumber: shorterNumber\r\n\t\t\t\t} = extractCountryCallingCodeFromInternationalNumberWithoutPlusSign(\r\n\t\t\t\t\tnumber,\r\n\t\t\t\t\tcountry,\r\n\t\t\t\t\tdefaultCountry,\r\n\t\t\t\t\tdefaultCallingCode,\r\n\t\t\t\t\tmetadata\r\n\t\t\t\t)\r\n\t\t\t\tif (countryCallingCode) {\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\tcountryCallingCodeSource: 'FROM_NUMBER_WITHOUT_PLUS_SIGN',\r\n\t\t\t\t\t\tcountryCallingCode,\r\n\t\t\t\t\t\tnumber: shorterNumber\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn {\r\n\t\t\t\t// No need to set it to `UNSPECIFIED`. It can be just `undefined`.\r\n\t\t\t\t// countryCallingCodeSource: 'UNSPECIFIED',\r\n\t\t\t\tnumber\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// `number` can only be international at this point.\r\n\r\n\t// Fast abortion: country codes do not begin with a '0'\r\n\tif (number[1] === '0') {\r\n\t\treturn {}\r\n\t}\r\n\r\n\tmetadata = new Metadata(metadata)\r\n\r\n\t// The thing with country phone codes\r\n\t// is that they are orthogonal to each other\r\n\t// i.e. there's no such country phone code A\r\n\t// for which country phone code B exists\r\n\t// where B starts with A.\r\n\t// Therefore, while scanning digits,\r\n\t// if a valid country code is found,\r\n\t// that means that it is the country code.\r\n\t//\r\n\tlet i = 2\r\n\twhile (i - 1 <= MAX_LENGTH_COUNTRY_CODE && i <= number.length) {\r\n\t\tconst countryCallingCode = number.slice(1, i)\r\n\t\tif (metadata.hasCallingCode(countryCallingCode)) {\r\n\t\t\tmetadata.selectNumberingPlan(countryCallingCode)\r\n\t\t\treturn {\r\n\t\t\t\tcountryCallingCodeSource: isNumberWithIddPrefix ? 'FROM_NUMBER_WITH_IDD' : 'FROM_NUMBER_WITH_PLUS_SIGN',\r\n\t\t\t\tcountryCallingCode,\r\n\t\t\t\tnumber: number.slice(i)\r\n\t\t\t}\r\n\t\t}\r\n\t\ti++\r\n\t}\r\n\r\n\treturn {}\r\n}\r\n\r\n// The possible values for the returned `countryCallingCodeSource` are:\r\n//\r\n// Copy-pasted from:\r\n// https://github.com/google/libphonenumber/blob/master/resources/phonenumber.proto\r\n//\r\n// // The source from which the country_code is derived. This is not set in the\r\n// // general parsing method, but in the method that parses and keeps raw_input.\r\n// // New fields could be added upon request.\r\n// enum CountryCodeSource {\r\n//  // Default value returned if this is not set, because the phone number was\r\n//  // created using parse, not parseAndKeepRawInput. hasCountryCodeSource will\r\n//  // return false if this is the case.\r\n//  UNSPECIFIED = 0;\r\n//\r\n//  // The country_code is derived based on a phone number with a leading \"+\",\r\n//  // e.g. the French number \"+33 1 42 68 53 00\".\r\n//  FROM_NUMBER_WITH_PLUS_SIGN = 1;\r\n//\r\n//  // The country_code is derived based on a phone number with a leading IDD,\r\n//  // e.g. the French number \"011 33 1 42 68 53 00\", as it is dialled from US.\r\n//  FROM_NUMBER_WITH_IDD = 5;\r\n//\r\n//  // The country_code is derived based on a phone number without a leading\r\n//  // \"+\", e.g. the French number \"33 1 42 68 53 00\" when defaultCountry is\r\n//  // supplied as France.\r\n//  FROM_NUMBER_WITHOUT_PLUS_SIGN = 10;\r\n//\r\n//  // The country_code is derived NOT based on the phone number itself, but\r\n//  // from the defaultCountry parameter provided in the parsing function by the\r\n//  // clients. This happens mostly for numbers written in the national format\r\n//  // (without country code). For example, this would be set when parsing the\r\n//  // French number \"01 42 68 53 00\", when defaultCountry is supplied as\r\n//  // France.\r\n//  FROM_DEFAULT_COUNTRY = 20;\r\n// }","import Metadata from '../metadata.js'\r\nimport mergeArrays from './mergeArrays.js'\r\n\r\nexport default function checkNumberLength(nationalNumber, country, metadata) {\r\n\treturn checkNumberLengthForType(nationalNumber, country, undefined, metadata)\r\n}\r\n\r\n// Checks whether a number is possible for a certain `country` based on the number length.\r\n//\r\n// This function is not supported by metadata generated with ancient versions of\r\n// `libphonenumber-js` (before version `1.0.18`) which didn't include \"possible lengths\".\r\n//\r\n// There was also a known issue with `checkNumberLength()` function:\r\n// if a number is possible only in a certain `country` among several `countries`\r\n// that share the same \"country calling code\", that function would check\r\n// the possibility of the phone number only in the \"main\" `country` for the \"country calling code\"\r\n// and would not check if it's actually be possible in the speciifc `country`.\r\n//\r\n// For example, \"+1310xxxx\" numbers are valid in Canada.\r\n// However, they are not possible in the US due to being too short.\r\n// Since Canada and the US share the same country calling code — \"+1\" —\r\n// `checkNumberLength()` function used to return not \"IS_POSSIBLE\" for \"+1310xxxx\" numbers.\r\n//\r\n// In such cases, when using \"/max\" metadata, `isValid()` could output `true`\r\n// but at the same time `isPossible()` could output `false`, which was contradictory.\r\n//\r\n// See https://issuetracker.google.com/issues/335892662 for the discusson in Google's issues.\r\n//\r\n// The solution suggested by Google was implemented: an optional `country` argument\r\n// was added to `checkNumberLength()` function. If present, that `country` will be used\r\n// to check phone number length for that specific `country` rather than the \"main\" country\r\n// for the shared \"country calling code\".\r\n//\r\nexport function checkNumberLengthForType(nationalNumber, country, type, metadata) {\r\n\t// If the exact `country` is specified, it's no necessarily already selected in `metadata`.\r\n\t// Most likely, in cases when there're multiple countries corresponding to the same\r\n\t// \"country calling code\", the \"main\" country for that \"country calling code\" will be selected.\r\n\tif (country) {\r\n\t\tmetadata = new Metadata(metadata.metadata)\r\n\t\tmetadata.selectNumberingPlan(country)\r\n\t}\r\n\r\n\tconst type_info = metadata.type(type)\r\n\r\n\t// There should always be \"<possiblePengths/>\" set for every type element.\r\n\t// This is declared in the XML schema.\r\n\t// For size efficiency, where a sub-description (e.g. fixed-line)\r\n\t// has the same \"<possiblePengths/>\" as the \"general description\", this is missing,\r\n\t// so we fall back to the \"general description\". Where no numbers of the type\r\n\t// exist at all, there is one possible length (-1) which is guaranteed\r\n\t// not to match the length of any real phone number.\r\n\tlet possible_lengths = type_info && type_info.possibleLengths() || metadata.possibleLengths()\r\n\t// let local_lengths = type_info && type.possibleLengthsLocal() || metadata.possibleLengthsLocal()\r\n\r\n\t// Metadata before version `1.0.18` didn't contain `possible_lengths`.\r\n\tif (!possible_lengths) {\r\n\t\treturn 'IS_POSSIBLE'\r\n\t}\r\n\r\n\tif (type === 'FIXED_LINE_OR_MOBILE') {\r\n\t\t// No such country in metadata.\r\n\t\t/* istanbul ignore next */\r\n\t\tif (!metadata.type('FIXED_LINE')) {\r\n\t\t\t// The rare case has been encountered where no fixedLine data is available\r\n\t\t\t// (true for some non-geographic entities), so we just check mobile.\r\n\t\t\treturn checkNumberLengthForType(nationalNumber, country, 'MOBILE', metadata)\r\n\t\t}\r\n\r\n\t\tconst mobile_type = metadata.type('MOBILE')\r\n\t\tif (mobile_type) {\r\n\t\t\t// Merge the mobile data in if there was any. \"Concat\" creates a new\r\n\t\t\t// array, it doesn't edit possible_lengths in place, so we don't need a copy.\r\n\t\t\t// Note that when adding the possible lengths from mobile, we have\r\n\t\t\t// to again check they aren't empty since if they are this indicates\r\n\t\t\t// they are the same as the general desc and should be obtained from there.\r\n\t\t\tpossible_lengths = mergeArrays(possible_lengths, mobile_type.possibleLengths())\r\n\t\t\t// The current list is sorted; we need to merge in the new list and\r\n\t\t\t// re-sort (duplicates are okay). Sorting isn't so expensive because\r\n\t\t\t// the lists are very small.\r\n\r\n\t\t\t// if (local_lengths) {\r\n\t\t\t// \tlocal_lengths = mergeArrays(local_lengths, mobile_type.possibleLengthsLocal())\r\n\t\t\t// } else {\r\n\t\t\t// \tlocal_lengths = mobile_type.possibleLengthsLocal()\r\n\t\t\t// }\r\n\t\t}\r\n\t}\r\n\t// If the type doesn't exist then return 'INVALID_LENGTH'.\r\n\telse if (type && !type_info) {\r\n\t\treturn 'INVALID_LENGTH'\r\n\t}\r\n\r\n\tconst actual_length = nationalNumber.length\r\n\r\n\t// In `libphonenumber-js` all \"local-only\" formats are dropped for simplicity.\r\n\t// // This is safe because there is never an overlap beween the possible lengths\r\n\t// // and the local-only lengths; this is checked at build time.\r\n\t// if (local_lengths && local_lengths.indexOf(nationalNumber.length) >= 0)\r\n\t// {\r\n\t// \treturn 'IS_POSSIBLE_LOCAL_ONLY'\r\n\t// }\r\n\r\n\tconst minimum_length = possible_lengths[0]\r\n\r\n\tif (minimum_length === actual_length) {\r\n\t\treturn 'IS_POSSIBLE'\r\n\t}\r\n\r\n\tif (minimum_length > actual_length) {\r\n\t\treturn 'TOO_SHORT'\r\n\t}\r\n\r\n\tif (possible_lengths[possible_lengths.length - 1] < actual_length) {\r\n\t\treturn 'TOO_LONG'\r\n\t}\r\n\r\n\t// We skip the first element since we've already checked it.\r\n\treturn possible_lengths.indexOf(actual_length, 1) >= 0 ? 'IS_POSSIBLE' : 'INVALID_LENGTH'\r\n}","import applyInternationalSeparatorStyle from './applyInternationalSeparatorStyle.js'\r\n\r\n// This was originally set to $1 but there are some countries for which the\r\n// first group is not used in the national pattern (e.g. Argentina) so the $1\r\n// group does not match correctly. Therefore, we use `\\d`, so that the first\r\n// group actually used in the pattern will be matched.\r\nexport const FIRST_GROUP_PATTERN = /(\\$\\d)/\r\n\r\nexport default function formatNationalNumberUsingFormat(\r\n\tnumber,\r\n\tformat,\r\n\t{\r\n\t\tuseInternationalFormat,\r\n\t\twithNationalPrefix,\r\n\t\tcarrierCode,\r\n\t\tmetadata\r\n\t}\r\n) {\r\n\tconst formattedNumber = number.replace(\r\n\t\tnew RegExp(format.pattern()),\r\n\t\tuseInternationalFormat\r\n\t\t\t? format.internationalFormat()\r\n\t\t\t: (\r\n\t\t\t\t// This library doesn't use `domestic_carrier_code_formatting_rule`,\r\n\t\t\t\t// because that one is only used when formatting phone numbers\r\n\t\t\t\t// for dialing from a mobile phone, and this is not a dialing library.\r\n\t\t\t\t// carrierCode && format.domesticCarrierCodeFormattingRule()\r\n\t\t\t\t// \t// First, replace the $CC in the formatting rule with the desired carrier code.\r\n\t\t\t\t// \t// Then, replace the $FG in the formatting rule with the first group\r\n\t\t\t\t// \t// and the carrier code combined in the appropriate way.\r\n\t\t\t\t// \t? format.format().replace(FIRST_GROUP_PATTERN, format.domesticCarrierCodeFormattingRule().replace('$CC', carrierCode))\r\n\t\t\t\t// \t: (\r\n\t\t\t\t// \t\twithNationalPrefix && format.nationalPrefixFormattingRule()\r\n\t\t\t\t// \t\t\t? format.format().replace(FIRST_GROUP_PATTERN, format.nationalPrefixFormattingRule())\r\n\t\t\t\t// \t\t\t: format.format()\r\n\t\t\t\t// \t)\r\n\t\t\t\twithNationalPrefix && format.nationalPrefixFormattingRule()\r\n\t\t\t\t\t? format.format().replace(FIRST_GROUP_PATTERN, format.nationalPrefixFormattingRule())\r\n\t\t\t\t\t: format.format()\r\n\t\t\t)\r\n\t)\r\n\tif (useInternationalFormat) {\r\n\t\treturn applyInternationalSeparatorStyle(formattedNumber)\r\n\t}\r\n\treturn formattedNumber\r\n}","import Metadata from '../metadata.js'\r\n\r\n/**\r\n * Pattern that makes it easy to distinguish whether a region has a single\r\n * international dialing prefix or not. If a region has a single international\r\n * prefix (e.g. 011 in USA), it will be represented as a string that contains\r\n * a sequence of ASCII digits, and possibly a tilde, which signals waiting for\r\n * the tone. If there are multiple available international prefixes in a\r\n * region, they will be represented as a regex string that always contains one\r\n * or more characters that are not ASCII digits or a tilde.\r\n */\r\nconst SINGLE_IDD_PREFIX_REG_EXP = /^[\\d]+(?:[~\\u2053\\u223C\\uFF5E][\\d]+)?$/\r\n\r\n// For regions that have multiple IDD prefixes\r\n// a preferred IDD prefix is returned.\r\nexport default function getIddPrefix(country, callingCode, metadata) {\r\n\tconst countryMetadata = new Metadata(metadata)\r\n\tcountryMetadata.selectNumberingPlan(country, callingCode)\r\n\tif (countryMetadata.defaultIDDPrefix()) {\r\n\t\treturn countryMetadata.defaultIDDPrefix()\r\n\t}\r\n\tif (SINGLE_IDD_PREFIX_REG_EXP.test(countryMetadata.IDDPrefix())) {\r\n\t\treturn countryMetadata.IDDPrefix()\r\n\t}\r\n}\r\n","import Metadata from './metadata.js'\r\nimport checkNumberLength from './helpers/checkNumberLength.js'\r\n\r\n/**\r\n * Checks if a phone number is \"possible\" (basically just checks its length).\r\n *\r\n * isPossible(phoneNumberInstance, { ..., v2: true }, metadata)\r\n *\r\n * isPossible({ phone: '8005553535', country: 'RU' }, { ... }, metadata)\r\n * isPossible({ phone: '8005553535', country: 'RU' }, undefined, metadata)\r\n *\r\n * @param  {object|PhoneNumber} input — If `options.v2: true` flag is passed, the `input` should be a `PhoneNumber` instance. Otherwise, it should be an object of shape `{ phone: '...', country: '...' }`.\r\n * @param  {object} [options]\r\n * @param  {object} metadata\r\n * @return {string}\r\n */\r\nexport default function isPossiblePhoneNumber(input, options, metadata) {\r\n\t/* istanbul ignore if */\r\n\tif (options === undefined) {\r\n\t\toptions = {}\r\n\t}\r\n\r\n\tmetadata = new Metadata(metadata)\r\n\r\n\tif (options.v2) {\r\n\t\tif (!input.countryCallingCode) {\r\n\t\t\tthrow new Error('Invalid phone number object passed')\r\n\t\t}\r\n\t\tmetadata.selectNumberingPlan(input.countryCallingCode)\r\n\t} else {\r\n\t\tif (!input.phone) {\r\n\t\t\treturn false\r\n\t\t}\r\n\t\tif (input.country) {\r\n\t\t\tif (!metadata.hasCountry(input.country)) {\r\n\t\t\t\tthrow new Error(`Unknown country: ${input.country}`)\r\n\t\t\t}\r\n\t\t\tmetadata.selectNumberingPlan(input.country)\r\n\t\t} else {\r\n\t\t\tif (!input.countryCallingCode) {\r\n\t\t\t\tthrow new Error('Invalid phone number object passed')\r\n\t\t\t}\r\n\t\t\tmetadata.selectNumberingPlan(input.countryCallingCode)\r\n\t\t}\r\n\t}\r\n\r\n\t// Old metadata (< 1.0.18) had no \"possible length\" data.\r\n\tif (metadata.possibleLengths()) {\r\n\t\treturn isPossibleNumber(input.phone || input.nationalNumber, input.country, metadata)\r\n\t} else {\r\n\t\t// There was a bug between `1.7.35` and `1.7.37` where \"possible_lengths\"\r\n\t\t// were missing for \"non-geographical\" numbering plans.\r\n\t\t// Just assume the number is possible in such cases:\r\n\t\t// it's unlikely that anyone generated their custom metadata\r\n\t\t// in that short period of time (one day).\r\n\t\t// This code can be removed in some future major version update.\r\n\t\tif (input.countryCallingCode && metadata.isNonGeographicCallingCode(input.countryCallingCode)) {\r\n\t\t\t// \"Non-geographic entities\" did't have `possibleLengths`\r\n\t\t\t// due to a bug in metadata generation process.\r\n\t\t\treturn true\r\n\t\t} else {\r\n\t\t\tthrow new Error('Missing \"possibleLengths\" in metadata. Perhaps the metadata has been generated before v1.0.18.');\r\n\t\t}\r\n\t}\r\n}\r\n\r\nexport function isPossibleNumber(nationalNumber, country, metadata) { //, isInternational) {\r\n\tswitch (checkNumberLength(nationalNumber, country, metadata)) {\r\n\t\tcase 'IS_POSSIBLE':\r\n\t\t\treturn true\r\n\t\t// This library ignores \"local-only\" phone numbers (for simplicity).\r\n\t\t// See the readme for more info on what are \"local-only\" phone numbers.\r\n\t\t// case 'IS_POSSIBLE_LOCAL_ONLY':\r\n\t\t// \treturn !isInternational\r\n\t\tdefault:\r\n\t\t\treturn false\r\n\t}\r\n}","import checkNumberLength from './helpers/checkNumberLength.js'\r\nimport parseDigits from './helpers/parseDigits.js'\r\nimport formatNationalNumberUsingFormat from './helpers/formatNationalNumberUsingFormat.js'\r\n\r\nexport default function formatCompleteNumber(state, format, {\r\n\tmetadata,\r\n\tshouldTryNationalPrefixFormattingRule,\r\n\tgetSeparatorAfterNationalPrefix\r\n}) {\r\n\tconst matcher = new RegExp(`^(?:${format.pattern()})$`)\r\n\tif (matcher.test(state.nationalSignificantNumber)) {\r\n\t\treturn formatNationalNumberWithAndWithoutNationalPrefixFormattingRule(\r\n\t\t\tstate,\r\n\t\t\tformat,\r\n\t\t\t{\r\n\t\t\t\tmetadata,\r\n\t\t\t\tshouldTryNationalPrefixFormattingRule,\r\n\t\t\t\tgetSeparatorAfterNationalPrefix\r\n\t\t\t}\r\n\t\t)\r\n\t}\r\n}\r\n\r\nexport function canFormatCompleteNumber(nationalSignificantNumber, country, metadata) {\r\n\treturn checkNumberLength(nationalSignificantNumber, country, metadata) === 'IS_POSSIBLE'\r\n}\r\n\r\nfunction formatNationalNumberWithAndWithoutNationalPrefixFormattingRule(state, format, {\r\n\tmetadata,\r\n\tshouldTryNationalPrefixFormattingRule,\r\n\tgetSeparatorAfterNationalPrefix\r\n}) {\r\n\t// `format` has already been checked for `nationalPrefix` requirement.\r\n\r\n\tconst {\r\n\t\tnationalSignificantNumber,\r\n\t\tinternational,\r\n\t\tnationalPrefix,\r\n\t\tcarrierCode\r\n\t} = state\r\n\r\n\t// Format the number with using `national_prefix_formatting_rule`.\r\n\t// If the resulting formatted number is a valid formatted number, then return it.\r\n\t//\r\n\t// Google's AsYouType formatter is different in a way that it doesn't try\r\n\t// to format using the \"national prefix formatting rule\", and instead it\r\n\t// simply prepends a national prefix followed by a \" \" character.\r\n\t// This code does that too, but as a fallback.\r\n\t// The reason is that \"national prefix formatting rule\" may use parentheses,\r\n\t// which wouldn't be included has it used the simpler Google's way.\r\n\t//\r\n\tif (shouldTryNationalPrefixFormattingRule(format)) {\r\n\t\tconst formattedNumber = formatNationalNumber(state, format, {\r\n\t\t\tuseNationalPrefixFormattingRule: true,\r\n\t\t\tgetSeparatorAfterNationalPrefix,\r\n\t\t\tmetadata\r\n\t\t})\r\n\t\tif (formattedNumber) {\r\n\t\t\treturn formattedNumber\r\n\t\t}\r\n\t}\r\n\r\n\t// Format the number without using `national_prefix_formatting_rule`.\r\n\treturn formatNationalNumber(state, format, {\r\n\t\tuseNationalPrefixFormattingRule: false,\r\n\t\tgetSeparatorAfterNationalPrefix,\r\n\t\tmetadata\r\n\t})\r\n}\r\n\r\nfunction formatNationalNumber(state, format, {\r\n\tmetadata,\r\n\tuseNationalPrefixFormattingRule,\r\n\tgetSeparatorAfterNationalPrefix\r\n}) {\r\n\tlet formattedNationalNumber = formatNationalNumberUsingFormat(\r\n\t\tstate.nationalSignificantNumber,\r\n\t\tformat,\r\n\t\t{\r\n\t\t\tcarrierCode: state.carrierCode,\r\n\t\t\tuseInternationalFormat: state.international,\r\n\t\t\twithNationalPrefix: useNationalPrefixFormattingRule,\r\n\t\t\tmetadata\r\n\t\t}\r\n\t)\r\n\tif (!useNationalPrefixFormattingRule) {\r\n\t\tif (state.nationalPrefix) {\r\n\t\t\t// If a national prefix was extracted, then just prepend it,\r\n\t\t\t// followed by a \" \" character.\r\n\t\t\tformattedNationalNumber = state.nationalPrefix +\r\n\t\t\t\tgetSeparatorAfterNationalPrefix(format) +\r\n\t\t\t\tformattedNationalNumber\r\n\t\t} else if (state.prefixBeforeNationalSignificantNumberThatIsNotNationalPrefix) {\r\n\t\t\tformattedNationalNumber = state.prefixBeforeNationalSignificantNumberThatIsNotNationalPrefix +\r\n\t\t\t\t' ' +\r\n\t\t\t\tformattedNationalNumber\r\n\t\t}\r\n\t}\r\n\tif (isValidFormattedNationalNumber(formattedNationalNumber, state)) {\r\n\t\treturn formattedNationalNumber\r\n\t}\r\n}\r\n\r\n// Check that the formatted phone number contains exactly\r\n// the same digits that have been input by the user.\r\n// For example, when \"0111523456789\" is input for `AR` country,\r\n// the extracted `this.nationalSignificantNumber` is \"91123456789\",\r\n// which means that the national part of `this.digits` isn't simply equal to\r\n// `this.nationalPrefix` + `this.nationalSignificantNumber`.\r\n//\r\n// Also, a `format` can add extra digits to the `this.nationalSignificantNumber`\r\n// being formatted via `metadata[country].national_prefix_transform_rule`.\r\n// For example, for `VI` country, it prepends `340` to the national number,\r\n// and if this check hasn't been implemented, then there would be a bug\r\n// when `340` \"area coude\" is \"duplicated\" during input for `VI` country:\r\n// https://github.com/catamphetamine/libphonenumber-js/issues/318\r\n//\r\n// So, all these \"gotchas\" are filtered out.\r\n//\r\n// In the original Google's code, the comments say:\r\n// \"Check that we didn't remove nor add any extra digits when we matched\r\n// this formatting pattern. This usually happens after we entered the last\r\n// digit during AYTF. Eg: In case of MX, we swallow mobile token (1) when\r\n// formatted but AYTF should retain all the number entered and not change\r\n// in order to match a format (of same leading digits and length) display\r\n// in that way.\"\r\n// \"If it's the same (i.e entered number and format is same), then it's\r\n// safe to return this in formatted number as nothing is lost / added.\"\r\n// Otherwise, don't use this format.\r\n// https://github.com/google/libphonenumber/commit/3e7c1f04f5e7200f87fb131e6f85c6e99d60f510#diff-9149457fa9f5d608a11bb975c6ef4bc5\r\n// https://github.com/google/libphonenumber/commit/3ac88c7106e7dcb553bcc794b15f19185928a1c6#diff-2dcb77e833422ee304da348b905cde0b\r\n//\r\nfunction isValidFormattedNationalNumber(formattedNationalNumber, state) {\r\n\treturn parseDigits(formattedNationalNumber) === state.getNationalDigits()\r\n}","import Metadata from '../metadata.js'\r\nimport { VALID_DIGITS } from '../constants.js'\r\n\r\nconst CAPTURING_DIGIT_PATTERN = new RegExp('([' + VALID_DIGITS + '])')\r\n\r\nexport default function stripIddPrefix(number, country, callingCode, metadata) {\r\n\tif (!country) {\r\n\t\treturn\r\n\t}\r\n\t// Check if the number is IDD-prefixed.\r\n\tconst countryMetadata = new Metadata(metadata)\r\n\tcountryMetadata.selectNumberingPlan(country, callingCode)\r\n\tconst IDDPrefixPattern = new RegExp(countryMetadata.IDDPrefix())\r\n\tif (number.search(IDDPrefixPattern) !== 0) {\r\n\t\treturn\r\n\t}\r\n\t// Strip IDD prefix.\r\n\tnumber = number.slice(number.match(IDDPrefixPattern)[0].length)\r\n\t// If there're any digits after an IDD prefix,\r\n\t// then those digits are a country calling code.\r\n\t// Since no country code starts with a `0`,\r\n\t// the code below validates that the next digit (if present) is not `0`.\r\n\tconst matchedGroups = number.match(CAPTURING_DIGIT_PATTERN)\r\n\tif (matchedGroups && matchedGroups[1] != null && matchedGroups[1].length > 0) {\r\n\t\tif (matchedGroups[1] === '0') {\r\n\t\t\treturn\r\n\t\t}\r\n\t}\r\n\treturn number\r\n}","import AsYouType from './AsYouType.js'\r\n\r\n/**\r\n * Formats a (possibly incomplete) phone number.\r\n * The phone number can be either in E.164 format\r\n * or in a form of national number digits.\r\n * @param {string} value - A possibly incomplete phone number. Either in E.164 format or in a form of national number digits.\r\n * @param {string|object} [optionsOrDefaultCountry] - A two-letter (\"ISO 3166-1 alpha-2\") country code, or an object of shape `{ defaultCountry?: string, defaultCallingCode?: string }`.\r\n * @return {string} Formatted (possibly incomplete) phone number.\r\n */\r\nexport default function formatIncompletePhoneNumber(value, optionsOrDefaultCountry, metadata) {\r\n\tif (!metadata) {\r\n\t\tmetadata = optionsOrDefaultCountry\r\n\t\toptionsOrDefaultCountry = undefined\r\n\t}\r\n\treturn new AsYouType(optionsOrDefaultCountry, metadata).input(value)\r\n}","// The minimum length of the national significant number.\r\nexport const MIN_LENGTH_FOR_NSN = 2\r\n\r\n// The ITU says the maximum length should be 15,\r\n// but one can find longer numbers in Germany.\r\nexport const MAX_LENGTH_FOR_NSN = 17\r\n\r\n// The maximum length of the country calling code.\r\nexport const MAX_LENGTH_COUNTRY_CODE = 3\r\n\r\n// Digits accepted in phone numbers\r\n// (ascii, fullwidth, arabic-indic, and eastern arabic digits).\r\nexport const VALID_DIGITS = '0-9\\uFF10-\\uFF19\\u0660-\\u0669\\u06F0-\\u06F9'\r\n\r\n// `DASHES` will be right after the opening square bracket of the \"character class\"\r\nconst DASHES = '-\\u2010-\\u2015\\u2212\\u30FC\\uFF0D'\r\nconst SLASHES = '\\uFF0F/'\r\nconst DOTS = '\\uFF0E.'\r\nexport const WHITESPACE = ' \\u00A0\\u00AD\\u200B\\u2060\\u3000'\r\nconst BRACKETS = '()\\uFF08\\uFF09\\uFF3B\\uFF3D\\\\[\\\\]'\r\n// export const OPENING_BRACKETS = '(\\uFF08\\uFF3B\\\\\\['\r\nconst TILDES = '~\\u2053\\u223C\\uFF5E'\r\n\r\n// Regular expression of acceptable punctuation found in phone numbers. This\r\n// excludes punctuation found as a leading character only. This consists of dash\r\n// characters, white space characters, full stops, slashes, square brackets,\r\n// parentheses and tildes. Full-width variants are also present.\r\nexport const VALID_PUNCTUATION = `${DASHES}${SLASHES}${DOTS}${WHITESPACE}${BRACKETS}${TILDES}`\r\n\r\nexport const PLUS_CHARS = '+\\uFF0B'\r\n// const LEADING_PLUS_CHARS_PATTERN = new RegExp('^[' + PLUS_CHARS + ']+')","import { formatIncompletePhoneNumber } from \"@/lib/libphonenumber\";\n\nexport function decodeEmail(email: string) {\n  return atob(email);\n}\n\nexport function decodePhoneNumber(phone: string) {\n  return atob(phone);\n}\n\nexport function formatPhoneNumber(phone: string) {\n  return formatIncompletePhoneNumber(phone);\n}\n","import type { MetadataJson } from \"libphonenumber-js/core\";\nimport { formatIncompletePhoneNumber as _formatIncompletePhoneNumber } from \"libphonenumber-js/core\";\n\nimport metadataJson from \"@/assets/libphonenumber.metadata.json\";\n\nconst metadata = metadataJson as MetadataJson;\n\n/**\n * Formats an incomplete phone number string according to the metadata provided (currently only for Viet Nam).\n *\n * Uses `libphonenumber-js`'s `formatIncompletePhoneNumber` function with custom metadata.\n *\n * @param phone - The phone number string to format (may be incomplete).\n * @returns The formatted phone number string.\n *\n * @remarks\n * - Only Viet Nam (VN) metadata is included by default. To add more countries, update and run the `generate-libphonenumber-metadata` script in `package.json`.\n * - This function is useful for formatting user input as they type a phone number.\n *\n * @see https://www.npmjs.com/package/libphonenumber-js#customizing-metadata\n */\nexport function formatIncompletePhoneNumber(phone: string) {\n  return _formatIncompletePhoneNumber(phone, metadata);\n}\n","import { VALID_DIGITS } from '../../constants.js'\r\n\r\n// The RFC 3966 format for extensions.\r\nconst RFC3966_EXTN_PREFIX = ';ext='\r\n\r\n/**\r\n * Helper method for constructing regular expressions for parsing. Creates\r\n * an expression that captures up to max_length digits.\r\n * @return {string} RegEx pattern to capture extension digits.\r\n */\r\nconst getExtensionDigitsPattern = (maxLength) => `([${VALID_DIGITS}]{1,${maxLength}})`\r\n\r\n/**\r\n * Helper initialiser method to create the regular-expression pattern to match\r\n * extensions.\r\n * Copy-pasted from Google's `libphonenumber`:\r\n * https://github.com/google/libphonenumber/blob/55b2646ec9393f4d3d6661b9c82ef9e258e8b829/javascript/i18n/phonenumbers/phonenumberutil.js#L759-L766\r\n * @return {string} RegEx pattern to capture extensions.\r\n */\r\nexport default function createExtensionPattern(purpose) {\r\n\t// We cap the maximum length of an extension based on the ambiguity of the way\r\n\t// the extension is prefixed. As per ITU, the officially allowed length for\r\n\t// extensions is actually 40, but we don't support this since we haven't seen real\r\n\t// examples and this introduces many false interpretations as the extension labels\r\n\t// are not standardized.\r\n\t/** @type {string} */\r\n\tvar extLimitAfterExplicitLabel = '20';\r\n\t/** @type {string} */\r\n\tvar extLimitAfterLikelyLabel = '15';\r\n\t/** @type {string} */\r\n\tvar extLimitAfterAmbiguousChar = '9';\r\n\t/** @type {string} */\r\n\tvar extLimitWhenNotSure = '6';\r\n\r\n\t/** @type {string} */\r\n\tvar possibleSeparatorsBetweenNumberAndExtLabel = \"[ \\u00A0\\\\t,]*\";\r\n\t// Optional full stop (.) or colon, followed by zero or more spaces/tabs/commas.\r\n\t/** @type {string} */\r\n\tvar possibleCharsAfterExtLabel = \"[:\\\\.\\uFF0E]?[ \\u00A0\\\\t,-]*\";\r\n\t/** @type {string} */\r\n\tvar optionalExtnSuffix = \"#?\";\r\n\r\n\t// Here the extension is called out in more explicit way, i.e mentioning it obvious\r\n\t// patterns like \"ext.\".\r\n\t/** @type {string} */\r\n\tvar explicitExtLabels =\r\n\t  \"(?:e?xt(?:ensi(?:o\\u0301?|\\u00F3))?n?|\\uFF45?\\uFF58\\uFF54\\uFF4E?|\\u0434\\u043E\\u0431|anexo)\";\r\n\t// One-character symbols that can be used to indicate an extension, and less\r\n\t// commonly used or more ambiguous extension labels.\r\n\t/** @type {string} */\r\n\tvar ambiguousExtLabels = \"(?:[x\\uFF58#\\uFF03~\\uFF5E]|int|\\uFF49\\uFF4E\\uFF54)\";\r\n\t// When extension is not separated clearly.\r\n\t/** @type {string} */\r\n\tvar ambiguousSeparator = \"[- ]+\";\r\n\t// This is the same as possibleSeparatorsBetweenNumberAndExtLabel, but not matching\r\n\t// comma as extension label may have it.\r\n\t/** @type {string} */\r\n\tvar possibleSeparatorsNumberExtLabelNoComma = \"[ \\u00A0\\\\t]*\";\r\n\t// \",,\" is commonly used for auto dialling the extension when connected. First\r\n\t// comma is matched through possibleSeparatorsBetweenNumberAndExtLabel, so we do\r\n\t// not repeat it here. Semi-colon works in Iphone and Android also to pop up a\r\n\t// button with the extension number following.\r\n\t/** @type {string} */\r\n\tvar autoDiallingAndExtLabelsFound = \"(?:,{2}|;)\";\r\n\r\n\t/** @type {string} */\r\n\tvar rfcExtn = RFC3966_EXTN_PREFIX\r\n\t     + getExtensionDigitsPattern(extLimitAfterExplicitLabel);\r\n\t/** @type {string} */\r\n\tvar explicitExtn = possibleSeparatorsBetweenNumberAndExtLabel + explicitExtLabels\r\n\t     + possibleCharsAfterExtLabel\r\n\t     + getExtensionDigitsPattern(extLimitAfterExplicitLabel)\r\n\t     + optionalExtnSuffix;\r\n\t/** @type {string} */\r\n\tvar ambiguousExtn = possibleSeparatorsBetweenNumberAndExtLabel + ambiguousExtLabels\r\n\t     + possibleCharsAfterExtLabel\r\n\t+ getExtensionDigitsPattern(extLimitAfterAmbiguousChar)\r\n\t+ optionalExtnSuffix;\r\n\t/** @type {string} */\r\n\tvar americanStyleExtnWithSuffix = ambiguousSeparator\r\n\t+ getExtensionDigitsPattern(extLimitWhenNotSure) + \"#\";\r\n\r\n\t/** @type {string} */\r\n\tvar autoDiallingExtn = possibleSeparatorsNumberExtLabelNoComma\r\n\t     + autoDiallingAndExtLabelsFound + possibleCharsAfterExtLabel\r\n\t     + getExtensionDigitsPattern(extLimitAfterLikelyLabel)\r\n\t+ optionalExtnSuffix;\r\n\t/** @type {string} */\r\n\tvar onlyCommasExtn = possibleSeparatorsNumberExtLabelNoComma\r\n\t    + \"(?:,)+\" + possibleCharsAfterExtLabel\r\n\t    + getExtensionDigitsPattern(extLimitAfterAmbiguousChar)\r\n\t    + optionalExtnSuffix;\r\n\r\n\t// The first regular expression covers RFC 3966 format, where the extension is added\r\n\t// using \";ext=\". The second more generic where extension is mentioned with explicit\r\n\t// labels like \"ext:\". In both the above cases we allow more numbers in extension than\r\n\t// any other extension labels. The third one captures when single character extension\r\n\t// labels or less commonly used labels are used. In such cases we capture fewer\r\n\t// extension digits in order to reduce the chance of falsely interpreting two\r\n\t// numbers beside each other as a number + extension. The fourth one covers the\r\n\t// special case of American numbers where the extension is written with a hash\r\n\t// at the end, such as \"- 503#\". The fifth one is exclusively for extension\r\n\t// autodialling formats which are used when dialling and in this case we accept longer\r\n\t// extensions. The last one is more liberal on the number of commas that acts as\r\n\t// extension labels, so we have a strict cap on the number of digits in such extensions.\r\n\treturn rfcExtn + \"|\"\r\n\t       + explicitExtn + \"|\"\r\n\t       + ambiguousExtn + \"|\"\r\n\t       + americanStyleExtnWithSuffix + \"|\"\r\n\t       + autoDiallingExtn + \"|\"\r\n\t       + onlyCommasExtn;\r\n}","import Metadata from '../metadata.js'\r\nimport getNumberType from './getNumberType.js'\r\n\r\n// Returns the exact country that the `nationalPhoneNumber` belongs to\r\n// in cases of ambiguity, i.e. when multiple countries share the same \"country calling code\".\r\nexport default function getCountryByNationalNumber(nationalPhoneNumber, {\r\n\tcountries,\r\n\tmetadata\r\n}) {\r\n\t// Re-create `metadata` because it will be selecting a `country`.\r\n\tmetadata = new Metadata(metadata)\r\n\r\n\t// const matchingCountries = []\r\n\r\n\tfor (const country of countries) {\r\n\t\tmetadata.selectNumberingPlan(country)\r\n\t\t// \"Leading digits\" patterns are only defined for about 20% of all countries.\r\n\t\t// By definition, matching \"leading digits\" is a sufficient but not a necessary\r\n\t\t// condition for a phone number to belong to a country.\r\n\t\t// The point of \"leading digits\" check is that it's the fastest one to get a match.\r\n\t\t// https://gitlab.com/catamphetamine/libphonenumber-js/blob/master/METADATA.md#leading_digits\r\n\t\t// I'd suppose that \"leading digits\" patterns are mutually exclusive for different countries\r\n\t\t// because of the intended use of that feature.\r\n\t\tif (metadata.leadingDigits()) {\r\n\t\t\tif (nationalPhoneNumber &&\r\n\t\t\t\tnationalPhoneNumber.search(metadata.leadingDigits()) === 0) {\r\n\t\t\t\treturn country\r\n\t\t\t}\r\n\t\t}\r\n\t\t// Else perform full validation with all of those\r\n\t\t// fixed-line/mobile/etc regular expressions.\r\n\t\telse if (getNumberType({ phone: nationalPhoneNumber, country }, undefined, metadata.metadata)) {\r\n\t\t\t// When multiple countries share the same \"country calling code\",\r\n\t\t\t// type patterns aren't guaranteed to be unique among them.\r\n\t\t\t// For example, both `US` and `CA` have the same pattern for `toll_free` numbers.\r\n\t\t\t// https://gitlab.com/catamphetamine/libphonenumber-js/-/issues/103#note_1417147572\r\n\t\t\t//\r\n\t\t\t// That means that this `if` condition could be `true` for multiple countries from the list.\r\n\t\t\t// Currently, it just returns the first one, which is also the \"main\" country for the \"country calling code\".\r\n\t\t\t// In an example with `toll_free` numbers above, `\"US\"` would be returned even though\r\n\t\t\t// it could as well be `\"CA\"`.\r\n\t\t\t//\r\n\t\t\t// There was also a time when this attempted to be overly smart\r\n\t\t\t// and kept track of all such multiple matching countries\r\n\t\t\t// and then picked the one that matched the `defaultCountry`, if provided.\r\n\t\t\t// For example, with `toll_free` numbers above, and with `defaultCountry: \"CA\"`,\r\n\t\t\t// it would've returned `\"CA\"` instead of `\"US\"`.\r\n\t\t\t// Later it turned out that such \"overly smart\" behavior turned out to be just confusing,\r\n\t\t\t// so this \"overly smart\" country detection was reverted to returning the \"main\" country\r\n\t\t\t// for the \"country calling code\".\r\n\t\t\t// https://gitlab.com/catamphetamine/libphonenumber-js/-/issues/154\r\n\t\t\t//\r\n\t\t\treturn country\r\n\t\t\t//\r\n\t\t\t// The \"overly smart\" behavior code:\r\n\t\t\t//\r\n\t\t\t// if (defaultCountry) {\r\n\t\t\t// \tif (country === defaultCountry) {\r\n\t\t\t// \t\treturn country\r\n\t\t\t// \t} else {\r\n\t\t\t// \t\tmatchingCountries.push(country)\r\n\t\t\t// \t}\r\n\t\t\t// } else {\r\n\t\t\t// \treturn country\r\n\t\t\t// }\r\n\t\t}\r\n\t}\r\n\r\n\t// // Return the first (\"main\") one of the `matchingCountries`.\r\n\t// if (matchingCountries.length > 0) {\r\n\t// \treturn matchingCountries[0]\r\n\t// }\r\n}","import Metadata from '../metadata.js'\r\nimport matchesEntirely from './matchesEntirely.js'\r\n\r\nconst NON_FIXED_LINE_PHONE_TYPES = [\r\n\t'MOBILE',\r\n\t'PREMIUM_RATE',\r\n\t'TOLL_FREE',\r\n\t'SHARED_COST',\r\n\t'VOIP',\r\n\t'PERSONAL_NUMBER',\r\n\t'PAGER',\r\n\t'UAN',\r\n\t'VOICEMAIL'\r\n]\r\n\r\n// Finds out national phone number type (fixed line, mobile, etc)\r\nexport default function getNumberType(input, options, metadata)\r\n{\r\n\t// If assigning the `{}` default value is moved to the arguments above,\r\n\t// code coverage would decrease for some weird reason.\r\n\toptions = options || {}\r\n\r\n\t// When `parse()` returns an empty object — `{}` —\r\n\t// that means that the phone number is malformed,\r\n\t// so it can't possibly be valid.\r\n\tif (!input.country && !input.countryCallingCode) {\r\n\t\treturn\r\n\t}\r\n\r\n\tmetadata = new Metadata(metadata)\r\n\r\n\tmetadata.selectNumberingPlan(input.country, input.countryCallingCode)\r\n\r\n\tconst nationalNumber = options.v2 ? input.nationalNumber : input.phone\r\n\r\n\t// The following is copy-pasted from the original function:\r\n\t// https://github.com/googlei18n/libphonenumber/blob/3ea547d4fbaa2d0b67588904dfa5d3f2557c27ff/javascript/i18n/phonenumbers/phonenumberutil.js#L2835\r\n\r\n\t// Is this national number even valid for this country\r\n\tif (!matchesEntirely(nationalNumber, metadata.nationalNumberPattern())) {\r\n\t\treturn\r\n\t}\r\n\r\n\t// Is it fixed line number\r\n\tif (isNumberTypeEqualTo(nationalNumber, 'FIXED_LINE', metadata)) {\r\n\t\t// Because duplicate regular expressions are removed\r\n\t\t// to reduce metadata size, if \"mobile\" pattern is \"\"\r\n\t\t// then it means it was removed due to being a duplicate of the fixed-line pattern.\r\n\t\t//\r\n\t\tif (metadata.type('MOBILE') && metadata.type('MOBILE').pattern() === '') {\r\n\t\t\treturn 'FIXED_LINE_OR_MOBILE'\r\n\t\t}\r\n\r\n\t\t// `MOBILE` type pattern isn't included if it matched `FIXED_LINE` one.\r\n\t\t// For example, for \"US\" country.\r\n\t\t// Old metadata (< `1.0.18`) had a specific \"types\" data structure\r\n\t\t// that happened to be `undefined` for `MOBILE` in that case.\r\n\t\t// Newer metadata (>= `1.0.18`) has another data structure that is\r\n\t\t// not `undefined` for `MOBILE` in that case (it's just an empty array).\r\n\t\t// So this `if` is just for backwards compatibility with old metadata.\r\n\t\tif (!metadata.type('MOBILE')) {\r\n\t\t\treturn 'FIXED_LINE_OR_MOBILE'\r\n\t\t}\r\n\r\n\t\t// Check if the number happens to qualify as both fixed line and mobile.\r\n\t\t// (no such country in the minimal metadata set)\r\n\t\t/* istanbul ignore if */\r\n\t\tif (isNumberTypeEqualTo(nationalNumber, 'MOBILE', metadata)) {\r\n\t\t\treturn 'FIXED_LINE_OR_MOBILE'\r\n\t\t}\r\n\r\n\t\treturn 'FIXED_LINE'\r\n\t}\r\n\r\n\tfor (const type of NON_FIXED_LINE_PHONE_TYPES) {\r\n\t\tif (isNumberTypeEqualTo(nationalNumber, type, metadata)) {\r\n\t\t\treturn type\r\n\t\t}\r\n\t}\r\n}\r\n\r\nexport function isNumberTypeEqualTo(nationalNumber, type, metadata) {\r\n\ttype = metadata.type(type)\r\n\tif (!type || !type.pattern()) {\r\n\t\treturn false\r\n\t}\r\n\t// Check if any possible number lengths are present;\r\n\t// if so, we use them to avoid checking\r\n\t// the validation pattern if they don't match.\r\n\t// If they are absent, this means they match\r\n\t// the general description, which we have\r\n\t// already checked before a specific number type.\r\n\tif (type.possibleLengths() &&\r\n\t\ttype.possibleLengths().indexOf(nationalNumber.length) < 0) {\r\n\t\treturn false\r\n\t}\r\n\treturn matchesEntirely(nationalNumber, type.pattern())\r\n}","// Should be the same as `DIGIT_PLACEHOLDER` in `libphonenumber-metadata-generator`.\r\nexport const DIGIT_PLACEHOLDER = 'x' // '\\u2008' (punctuation space)\r\nconst DIGIT_PLACEHOLDER_MATCHER = new RegExp(DIGIT_PLACEHOLDER)\r\n\r\n// Counts all occurences of a symbol in a string.\r\n// Unicode-unsafe (because using `.split()`).\r\nexport function countOccurences(symbol, string) {\r\n\tlet count = 0\r\n\t// Using `.split('')` to iterate through a string here\r\n\t// to avoid requiring `Symbol.iterator` polyfill.\r\n\t// `.split('')` is generally not safe for Unicode,\r\n\t// but in this particular case for counting brackets it is safe.\r\n\t// for (const character of string)\r\n\tfor (const character of string.split('')) {\r\n\t\tif (character === symbol) {\r\n\t\t\tcount++\r\n\t\t}\r\n\t}\r\n\treturn count\r\n}\r\n\r\n// Repeats a string (or a symbol) N times.\r\n// http://stackoverflow.com/questions/202605/repeat-string-javascript\r\nexport function repeat(string, times) {\r\n\tif (times < 1) {\r\n\t\treturn ''\r\n\t}\r\n\tlet result = ''\r\n\twhile (times > 1) {\r\n\t\tif (times & 1) {\r\n\t\t\tresult += string\r\n\t\t}\r\n\t\ttimes >>= 1\r\n\t\tstring += string\r\n\t}\r\n\treturn result + string\r\n}\r\n\r\nexport function cutAndStripNonPairedParens(string, cutBeforeIndex) {\r\n\tif (string[cutBeforeIndex] === ')') {\r\n\t\tcutBeforeIndex++\r\n\t}\r\n\treturn stripNonPairedParens(string.slice(0, cutBeforeIndex))\r\n}\r\n\r\nexport function closeNonPairedParens(template, cut_before) {\r\n\tconst retained_template = template.slice(0, cut_before)\r\n\tconst opening_braces = countOccurences('(', retained_template)\r\n\tconst closing_braces = countOccurences(')', retained_template)\r\n\tlet dangling_braces = opening_braces - closing_braces\r\n\twhile (dangling_braces > 0 && cut_before < template.length) {\r\n\t\tif (template[cut_before] === ')') {\r\n\t\t\tdangling_braces--\r\n\t\t}\r\n\t\tcut_before++\r\n\t}\r\n\treturn template.slice(0, cut_before)\r\n}\r\n\r\nexport function stripNonPairedParens(string) {\r\n\tconst dangling_braces =[]\r\n\tlet i = 0\r\n\twhile (i < string.length) {\r\n\t\tif (string[i] === '(') {\r\n\t\t\tdangling_braces.push(i)\r\n\t\t}\r\n\t\telse if (string[i] === ')') {\r\n\t\t\tdangling_braces.pop()\r\n\t\t}\r\n\t\ti++\r\n\t}\r\n\tlet start = 0\r\n\tlet cleared_string = ''\r\n\tdangling_braces.push(string.length)\r\n\tfor (const index of dangling_braces) {\r\n\t\tcleared_string += string.slice(start, index)\r\n\t\tstart = index + 1\r\n\t}\r\n\treturn cleared_string\r\n}\r\n\r\nexport function populateTemplateWithDigits(template, position, digits) {\r\n\t// Using `.split('')` to iterate through a string here\r\n\t// to avoid requiring `Symbol.iterator` polyfill.\r\n\t// `.split('')` is generally not safe for Unicode,\r\n\t// but in this particular case for `digits` it is safe.\r\n\t// for (const digit of digits)\r\n\tfor (const digit of digits.split('')) {\r\n\t\t// If there is room for more digits in current `template`,\r\n\t\t// then set the next digit in the `template`,\r\n\t\t// and return the formatted digits so far.\r\n\t\t// If more digits are entered than the current format could handle.\r\n\t\tif (template.slice(position + 1).search(DIGIT_PLACEHOLDER_MATCHER) < 0) {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tposition = template.search(DIGIT_PLACEHOLDER_MATCHER)\r\n\t\ttemplate = template.replace(DIGIT_PLACEHOLDER_MATCHER, digit)\r\n\t}\r\n\treturn [template, position]\r\n}","import {\n  AppRouteRouteModule,\n  type AppRouteRouteHandlerContext,\n  type AppRouteRouteModuleOptions,\n} from '../../server/route-modules/app-route/module.compiled'\nimport { RouteKind } from '../../server/route-kind'\nimport { patchFetch as _patchFetch } from '../../server/lib/patch-fetch'\nimport type { IncomingMessage, ServerResponse } from 'node:http'\nimport { addRequestMeta, getRequestMeta } from '../../server/request-meta'\nimport { getTracer, type Span, SpanKind } from '../../server/lib/trace/tracer'\nimport { setReferenceManifestsSingleton } from '../../server/app-render/encryption-utils'\nimport { createServerModuleMap } from '../../server/app-render/action-utils'\nimport { normalizeAppPath } from '../../shared/lib/router/utils/app-paths'\nimport { NodeNextRequest, NodeNextResponse } from '../../server/base-http/node'\nimport {\n  NextRequestAdapter,\n  signalFromNodeResponse,\n} from '../../server/web/spec-extension/adapters/next-request'\nimport { BaseServerSpan } from '../../server/lib/trace/constants'\nimport { getRevalidateReason } from '../../server/instrumentation/utils'\nimport { sendResponse } from '../../server/send-response'\nimport {\n  fromNodeOutgoingHttpHeaders,\n  toNodeOutgoingHttpHeaders,\n} from '../../server/web/utils'\nimport { getCacheControlHeader } from '../../server/lib/cache-control'\nimport { INFINITE_CACHE, NEXT_CACHE_TAGS_HEADER } from '../../lib/constants'\nimport { NoFallbackError } from '../../shared/lib/no-fallback-error.external'\nimport {\n  CachedRouteKind,\n  type ResponseCacheEntry,\n  type ResponseGenerator,\n} from '../../server/response-cache'\n\nimport * as userland from 'VAR_USERLAND'\n\n// These are injected by the loader afterwards. This is injected as a variable\n// instead of a replacement because this could also be `undefined` instead of\n// an empty string.\ndeclare const nextConfigOutput: AppRouteRouteModuleOptions['nextConfigOutput']\n\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\n// INJECT:nextConfigOutput\n\nconst routeModule = new AppRouteRouteModule({\n  definition: {\n    kind: RouteKind.APP_ROUTE,\n    page: 'VAR_DEFINITION_PAGE',\n    pathname: 'VAR_DEFINITION_PATHNAME',\n    filename: 'VAR_DEFINITION_FILENAME',\n    bundlePath: 'VAR_DEFINITION_BUNDLE_PATH',\n  },\n  distDir: process.env.__NEXT_RELATIVE_DIST_DIR || '',\n  relativeProjectDir: process.env.__NEXT_RELATIVE_PROJECT_DIR || '',\n  resolvedPagePath: 'VAR_RESOLVED_PAGE_PATH',\n  nextConfigOutput,\n  userland,\n})\n\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { workAsyncStorage, workUnitAsyncStorage, serverHooks } = routeModule\n\nfunction patchFetch() {\n  return _patchFetch({\n    workAsyncStorage,\n    workUnitAsyncStorage,\n  })\n}\n\nexport {\n  routeModule,\n  workAsyncStorage,\n  workUnitAsyncStorage,\n  serverHooks,\n  patchFetch,\n}\n\nexport async function handler(\n  req: IncomingMessage,\n  res: ServerResponse,\n  ctx: {\n    waitUntil: (prom: Promise<void>) => void\n  }\n) {\n  if (routeModule.isDev) {\n    addRequestMeta(req, 'devRequestTimingInternalsEnd', process.hrtime.bigint())\n  }\n  let srcPage = 'VAR_DEFINITION_PAGE'\n\n  // turbopack doesn't normalize `/index` in the page name\n  // so we need to to process dynamic routes properly\n  // TODO: fix turbopack providing differing value from webpack\n  if (process.env.TURBOPACK) {\n    srcPage = srcPage.replace(/\\/index$/, '') || '/'\n  } else if (srcPage === '/index') {\n    // we always normalize /index specifically\n    srcPage = '/'\n  }\n  const multiZoneDraftMode = process.env\n    .__NEXT_MULTI_ZONE_DRAFT_MODE as any as boolean\n\n  const prepareResult = await routeModule.prepare(req, res, {\n    srcPage,\n    multiZoneDraftMode,\n  })\n\n  if (!prepareResult) {\n    res.statusCode = 400\n    res.end('Bad Request')\n    ctx.waitUntil?.(Promise.resolve())\n    return null\n  }\n\n  const {\n    buildId,\n    params,\n    nextConfig,\n    parsedUrl,\n    isDraftMode,\n    prerenderManifest,\n    routerServerContext,\n    isOnDemandRevalidate,\n    revalidateOnlyGenerated,\n    resolvedPathname,\n    clientReferenceManifest,\n    serverActionsManifest,\n  } = prepareResult\n\n  const normalizedSrcPage = normalizeAppPath(srcPage)\n\n  let isIsr = Boolean(\n    prerenderManifest.dynamicRoutes[normalizedSrcPage] ||\n      prerenderManifest.routes[resolvedPathname]\n  )\n\n  const render404 = async () => {\n    // TODO: should route-module itself handle rendering the 404\n    if (routerServerContext?.render404) {\n      await routerServerContext.render404(req, res, parsedUrl, false)\n    } else {\n      res.end('This page could not be found')\n    }\n    return null\n  }\n\n  if (isIsr && !isDraftMode) {\n    const isPrerendered = Boolean(prerenderManifest.routes[resolvedPathname])\n    const prerenderInfo = prerenderManifest.dynamicRoutes[normalizedSrcPage]\n\n    if (prerenderInfo) {\n      if (prerenderInfo.fallback === false && !isPrerendered) {\n        if (nextConfig.experimental.adapterPath) {\n          return await render404()\n        }\n        throw new NoFallbackError()\n      }\n    }\n  }\n\n  let cacheKey: string | null = null\n\n  if (isIsr && !routeModule.isDev && !isDraftMode) {\n    cacheKey = resolvedPathname\n    // ensure /index and / is normalized to one key\n    cacheKey = cacheKey === '/index' ? '/' : cacheKey\n  }\n\n  const supportsDynamicResponse: boolean =\n    // If we're in development, we always support dynamic HTML\n    routeModule.isDev === true ||\n    // If this is not SSG or does not have static paths, then it supports\n    // dynamic HTML.\n    !isIsr\n\n  // This is a revalidation request if the request is for a static\n  // page and it is not being resumed from a postponed render and\n  // it is not a dynamic RSC request then it is a revalidation\n  // request.\n  const isStaticGeneration = isIsr && !supportsDynamicResponse\n\n  // Before rendering (which initializes component tree modules), we have to\n  // set the reference manifests to our global store so Server Action's\n  // encryption util can access to them at the top level of the page module.\n  if (serverActionsManifest && clientReferenceManifest) {\n    setReferenceManifestsSingleton({\n      page: srcPage,\n      clientReferenceManifest,\n      serverActionsManifest,\n      serverModuleMap: createServerModuleMap({\n        serverActionsManifest,\n      }),\n    })\n  }\n\n  const method = req.method || 'GET'\n  const tracer = getTracer()\n  const activeSpan = tracer.getActiveScopeSpan()\n\n  const context: AppRouteRouteHandlerContext = {\n    params,\n    prerenderManifest,\n    renderOpts: {\n      experimental: {\n        authInterrupts: Boolean(nextConfig.experimental.authInterrupts),\n      },\n      cacheComponents: Boolean(nextConfig.cacheComponents),\n      supportsDynamicResponse,\n      incrementalCache: getRequestMeta(req, 'incrementalCache'),\n      cacheLifeProfiles: nextConfig.cacheLife,\n      waitUntil: ctx.waitUntil,\n      onClose: (cb) => {\n        res.on('close', cb)\n      },\n      onAfterTaskError: undefined,\n      onInstrumentationRequestError: (error, _request, errorContext) =>\n        routeModule.onRequestError(\n          req,\n          error,\n          errorContext,\n          routerServerContext\n        ),\n    },\n    sharedContext: {\n      buildId,\n    },\n  }\n  const nodeNextReq = new NodeNextRequest(req)\n  const nodeNextRes = new NodeNextResponse(res)\n\n  const nextReq = NextRequestAdapter.fromNodeNextRequest(\n    nodeNextReq,\n    signalFromNodeResponse(res)\n  )\n\n  try {\n    const invokeRouteModule = async (span?: Span) => {\n      return routeModule.handle(nextReq, context).finally(() => {\n        if (!span) return\n\n        span.setAttributes({\n          'http.status_code': res.statusCode,\n          'next.rsc': false,\n        })\n\n        const rootSpanAttributes = tracer.getRootSpanAttributes()\n        // We were unable to get attributes, probably OTEL is not enabled\n        if (!rootSpanAttributes) {\n          return\n        }\n\n        if (\n          rootSpanAttributes.get('next.span_type') !==\n          BaseServerSpan.handleRequest\n        ) {\n          console.warn(\n            `Unexpected root span type '${rootSpanAttributes.get(\n              'next.span_type'\n            )}'. Please report this Next.js issue https://github.com/vercel/next.js`\n          )\n          return\n        }\n\n        const route = rootSpanAttributes.get('next.route')\n        if (route) {\n          const name = `${method} ${route}`\n\n          span.setAttributes({\n            'next.route': route,\n            'http.route': route,\n            'next.span_name': name,\n          })\n          span.updateName(name)\n        } else {\n          span.updateName(`${method} ${srcPage}`)\n        }\n      })\n    }\n    const isMinimalMode = Boolean(\n      process.env.MINIMAL_MODE || getRequestMeta(req, 'minimalMode')\n    )\n\n    const handleResponse = async (currentSpan?: Span) => {\n      const responseGenerator: ResponseGenerator = async ({\n        previousCacheEntry,\n      }) => {\n        try {\n          if (\n            !isMinimalMode &&\n            isOnDemandRevalidate &&\n            revalidateOnlyGenerated &&\n            !previousCacheEntry\n          ) {\n            res.statusCode = 404\n            // on-demand revalidate always sets this header\n            res.setHeader('x-nextjs-cache', 'REVALIDATED')\n            res.end('This page could not be found')\n            return null\n          }\n\n          const response = await invokeRouteModule(currentSpan)\n\n          ;(req as any).fetchMetrics = (context.renderOpts as any).fetchMetrics\n          let pendingWaitUntil = context.renderOpts.pendingWaitUntil\n\n          // Attempt using provided waitUntil if available\n          // if it's not we fallback to sendResponse's handling\n          if (pendingWaitUntil) {\n            if (ctx.waitUntil) {\n              ctx.waitUntil(pendingWaitUntil)\n              pendingWaitUntil = undefined\n            }\n          }\n          const cacheTags = context.renderOpts.collectedTags\n\n          // If the request is for a static response, we can cache it so long\n          // as it's not edge.\n          if (isIsr) {\n            const blob = await response.blob()\n\n            // Copy the headers from the response.\n            const headers = toNodeOutgoingHttpHeaders(response.headers)\n\n            if (cacheTags) {\n              headers[NEXT_CACHE_TAGS_HEADER] = cacheTags\n            }\n\n            if (!headers['content-type'] && blob.type) {\n              headers['content-type'] = blob.type\n            }\n\n            const revalidate =\n              typeof context.renderOpts.collectedRevalidate === 'undefined' ||\n              context.renderOpts.collectedRevalidate >= INFINITE_CACHE\n                ? false\n                : context.renderOpts.collectedRevalidate\n\n            const expire =\n              typeof context.renderOpts.collectedExpire === 'undefined' ||\n              context.renderOpts.collectedExpire >= INFINITE_CACHE\n                ? undefined\n                : context.renderOpts.collectedExpire\n\n            // Create the cache entry for the response.\n            const cacheEntry: ResponseCacheEntry = {\n              value: {\n                kind: CachedRouteKind.APP_ROUTE,\n                status: response.status,\n                body: Buffer.from(await blob.arrayBuffer()),\n                headers,\n              },\n              cacheControl: { revalidate, expire },\n            }\n\n            return cacheEntry\n          } else {\n            // send response without caching if not ISR\n            await sendResponse(\n              nodeNextReq,\n              nodeNextRes,\n              response,\n              context.renderOpts.pendingWaitUntil\n            )\n            return null\n          }\n        } catch (err) {\n          // if this is a background revalidate we need to report\n          // the request error here as it won't be bubbled\n          if (previousCacheEntry?.isStale) {\n            await routeModule.onRequestError(\n              req,\n              err,\n              {\n                routerKind: 'App Router',\n                routePath: srcPage,\n                routeType: 'route',\n                revalidateReason: getRevalidateReason({\n                  isStaticGeneration,\n                  isOnDemandRevalidate,\n                }),\n              },\n              routerServerContext\n            )\n          }\n          throw err\n        }\n      }\n\n      const cacheEntry = await routeModule.handleResponse({\n        req,\n        nextConfig,\n        cacheKey,\n        routeKind: RouteKind.APP_ROUTE,\n        isFallback: false,\n        prerenderManifest,\n        isRoutePPREnabled: false,\n        isOnDemandRevalidate,\n        revalidateOnlyGenerated,\n        responseGenerator,\n        waitUntil: ctx.waitUntil,\n        isMinimalMode,\n      })\n\n      // we don't create a cacheEntry for ISR\n      if (!isIsr) {\n        return null\n      }\n\n      if (cacheEntry?.value?.kind !== CachedRouteKind.APP_ROUTE) {\n        throw new Error(\n          `Invariant: app-route received invalid cache entry ${cacheEntry?.value?.kind}`\n        )\n      }\n\n      if (!isMinimalMode) {\n        res.setHeader(\n          'x-nextjs-cache',\n          isOnDemandRevalidate\n            ? 'REVALIDATED'\n            : cacheEntry.isMiss\n              ? 'MISS'\n              : cacheEntry.isStale\n                ? 'STALE'\n                : 'HIT'\n        )\n      }\n\n      // Draft mode should never be cached\n      if (isDraftMode) {\n        res.setHeader(\n          'Cache-Control',\n          'private, no-cache, no-store, max-age=0, must-revalidate'\n        )\n      }\n\n      const headers = fromNodeOutgoingHttpHeaders(cacheEntry.value.headers)\n\n      if (!(isMinimalMode && isIsr)) {\n        headers.delete(NEXT_CACHE_TAGS_HEADER)\n      }\n\n      // If cache control is already set on the response we don't\n      // override it to allow users to customize it via next.config\n      if (\n        cacheEntry.cacheControl &&\n        !res.getHeader('Cache-Control') &&\n        !headers.get('Cache-Control')\n      ) {\n        headers.set(\n          'Cache-Control',\n          getCacheControlHeader(cacheEntry.cacheControl)\n        )\n      }\n\n      await sendResponse(\n        nodeNextReq,\n        nodeNextRes,\n        // @ts-expect-error - Argument of type 'Buffer<ArrayBufferLike>' is not assignable to parameter of type 'BodyInit | null | undefined'.\n        new Response(cacheEntry.value.body, {\n          headers,\n          status: cacheEntry.value.status || 200,\n        })\n      )\n      return null\n    }\n\n    // TODO: activeSpan code path is for when wrapped by\n    // next-server can be removed when this is no longer used\n    if (activeSpan) {\n      await handleResponse(activeSpan)\n    } else {\n      await tracer.withPropagatedContext(req.headers, () =>\n        tracer.trace(\n          BaseServerSpan.handleRequest,\n          {\n            spanName: `${method} ${srcPage}`,\n            kind: SpanKind.SERVER,\n            attributes: {\n              'http.method': method,\n              'http.target': req.url,\n            },\n          },\n          handleResponse\n        )\n      )\n    }\n  } catch (err) {\n    if (!(err instanceof NoFallbackError)) {\n      await routeModule.onRequestError(req, err, {\n        routerKind: 'App Router',\n        routePath: normalizedSrcPage,\n        routeType: 'route',\n        revalidateReason: getRevalidateReason({\n          isStaticGeneration,\n          isOnDemandRevalidate,\n        }),\n      })\n    }\n\n    // rethrow so that we can handle serving error page\n\n    // If this is during static generation, throw the error again.\n    if (isIsr) throw err\n\n    // Otherwise, send a 500 response.\n    await sendResponse(\n      nodeNextReq,\n      nodeNextRes,\n      new Response(null, { status: 500 })\n    )\n    return null\n  }\n}\n","/**\r\n * Checks whether the entire input sequence can be matched\r\n * against the regular expression.\r\n * @return {boolean}\r\n */\r\nexport default function matchesEntirely(text, regularExpressionText) {\r\n\t// If the assigning of the `''` default value is moved to the arguments above,\r\n\t// the code coverage would decrease for some weird reason.\r\n\ttext = text || ''\r\n\treturn new RegExp('^(?:' + regularExpressionText + ')$').test(text)\r\n}","export default class PatternParser {\r\n\tparse(pattern) {\r\n\t\tthis.context = [{\r\n\t\t\tor: true,\r\n\t\t\tinstructions: []\r\n\t\t}]\r\n\r\n\t\tthis.parsePattern(pattern)\r\n\r\n\t\tif (this.context.length !== 1) {\r\n\t\t\tthrow new Error('Non-finalized contexts left when pattern parse ended')\r\n\t\t}\r\n\r\n\t\tconst { branches, instructions } = this.context[0]\r\n\r\n\t\tif (branches) {\r\n\t\t\treturn {\r\n\t\t\t\top: '|',\r\n\t\t\t\targs: branches.concat([\r\n\t\t\t\t\texpandSingleElementArray(instructions)\r\n\t\t\t\t])\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/* istanbul ignore if */\r\n\t\tif (instructions.length === 0) {\r\n\t\t\tthrow new Error('Pattern is required')\r\n\t\t}\r\n\r\n\t\tif (instructions.length === 1) {\r\n\t\t\treturn instructions[0]\r\n\t\t}\r\n\r\n\t\treturn instructions\r\n\t}\r\n\r\n\tstartContext(context) {\r\n\t\tthis.context.push(context)\r\n\t}\r\n\r\n\tendContext() {\r\n\t\tthis.context.pop()\r\n\t}\r\n\r\n\tgetContext() {\r\n\t\treturn this.context[this.context.length - 1]\r\n\t}\r\n\r\n\tparsePattern(pattern) {\r\n\t\tif (!pattern) {\r\n\t\t\tthrow new Error('Pattern is required')\r\n\t\t}\r\n\r\n\t\tconst match = pattern.match(OPERATOR)\r\n\t\tif (!match) {\r\n\t\t\tif (ILLEGAL_CHARACTER_REGEXP.test(pattern)) {\r\n\t\t\t\tthrow new Error(`Illegal characters found in a pattern: ${pattern}`)\r\n\t\t\t}\r\n\t\t\tthis.getContext().instructions = this.getContext().instructions.concat(\r\n\t\t\t\tpattern.split('')\r\n\t\t\t)\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tconst operator = match[1]\r\n\t\tconst before = pattern.slice(0, match.index)\r\n\t\tconst rightPart = pattern.slice(match.index + operator.length)\r\n\r\n\t\tswitch (operator) {\r\n\t\t\tcase '(?:':\r\n\t\t\t\tif (before) {\r\n\t\t\t\t\tthis.parsePattern(before)\r\n\t\t\t\t}\r\n\t\t\t\tthis.startContext({\r\n\t\t\t\t\tor: true,\r\n\t\t\t\t\tinstructions: [],\r\n\t\t\t\t\tbranches: []\r\n\t\t\t\t})\r\n\t\t\t\tbreak\r\n\r\n\t\t\tcase ')':\r\n\t\t\t\tif (!this.getContext().or) {\r\n\t\t\t\t\tthrow new Error('\")\" operator must be preceded by \"(?:\" operator')\r\n\t\t\t\t}\r\n\t\t\t\tif (before) {\r\n\t\t\t\t\tthis.parsePattern(before)\r\n\t\t\t\t}\r\n\t\t\t\tif (this.getContext().instructions.length === 0) {\r\n\t\t\t\t\tthrow new Error('No instructions found after \"|\" operator in an \"or\" group')\r\n\t\t\t\t}\r\n\t\t\t\tconst { branches } = this.getContext()\r\n\t\t\t\tbranches.push(\r\n\t\t\t\t\texpandSingleElementArray(\r\n\t\t\t\t\t\tthis.getContext().instructions\r\n\t\t\t\t\t)\r\n\t\t\t\t)\r\n\t\t\t\tthis.endContext()\r\n\t\t\t\tthis.getContext().instructions.push({\r\n\t\t\t\t\top: '|',\r\n\t\t\t\t\targs: branches\r\n\t\t\t\t})\r\n\t\t\t\tbreak\r\n\r\n\t\t\tcase '|':\r\n\t\t\t\tif (!this.getContext().or) {\r\n\t\t\t\t\tthrow new Error('\"|\" operator can only be used inside \"or\" groups')\r\n\t\t\t\t}\r\n\t\t\t\tif (before) {\r\n\t\t\t\t\tthis.parsePattern(before)\r\n\t\t\t\t}\r\n\t\t\t\t// The top-level is an implicit \"or\" group, if required.\r\n\t\t\t\tif (!this.getContext().branches) {\r\n\t\t\t\t\t// `branches` are not defined only for the root implicit \"or\" operator.\r\n\t\t\t\t\t/* istanbul ignore else */\r\n\t\t\t\t\tif (this.context.length === 1) {\r\n\t\t\t\t\t\tthis.getContext().branches = []\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tthrow new Error('\"branches\" not found in an \"or\" group context')\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tthis.getContext().branches.push(\r\n\t\t\t\t\texpandSingleElementArray(\r\n\t\t\t\t\t\tthis.getContext().instructions\r\n\t\t\t\t\t)\r\n\t\t\t\t)\r\n\t\t\t\tthis.getContext().instructions = []\r\n\t\t\t\tbreak\r\n\r\n\t\t\tcase '[':\r\n\t\t\t\tif (before) {\r\n\t\t\t\t\tthis.parsePattern(before)\r\n\t\t\t\t}\r\n\t\t\t\tthis.startContext({\r\n\t\t\t\t\toneOfSet: true\r\n\t\t\t\t})\r\n\t\t\t\tbreak\r\n\r\n\t\t\tcase ']':\r\n\t\t\t\tif (!this.getContext().oneOfSet) {\r\n\t\t\t\t\tthrow new Error('\"]\" operator must be preceded by \"[\" operator')\r\n\t\t\t\t}\r\n\t\t\t\tthis.endContext()\r\n\t\t\t\tthis.getContext().instructions.push({\r\n\t\t\t\t\top: '[]',\r\n\t\t\t\t\targs: parseOneOfSet(before)\r\n\t\t\t\t})\r\n\t\t\t\tbreak\r\n\r\n\t\t\t/* istanbul ignore next */\r\n\t\t\tdefault:\r\n\t\t\t\tthrow new Error(`Unknown operator: ${operator}`)\r\n\t\t}\r\n\r\n\t\tif (rightPart) {\r\n\t\t\tthis.parsePattern(rightPart)\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction parseOneOfSet(pattern) {\r\n\tconst values = []\r\n\tlet i = 0\r\n\twhile (i < pattern.length) {\r\n\t\tif (pattern[i] === '-') {\r\n\t\t\tif (i === 0 || i === pattern.length - 1) {\r\n\t\t\t\tthrow new Error(`Couldn't parse a one-of set pattern: ${pattern}`)\r\n\t\t\t}\r\n\t\t\tconst prevValue = pattern[i - 1].charCodeAt(0) + 1\r\n\t\t\tconst nextValue = pattern[i + 1].charCodeAt(0) - 1\r\n\t\t\tlet value = prevValue\r\n\t\t\twhile (value <= nextValue) {\r\n\t\t\t\tvalues.push(String.fromCharCode(value))\r\n\t\t\t\tvalue++\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tvalues.push(pattern[i])\r\n\t\t}\r\n\t\ti++\r\n\t}\r\n\treturn values\r\n}\r\n\r\nconst ILLEGAL_CHARACTER_REGEXP = /[\\(\\)\\[\\]\\?\\:\\|]/\r\n\r\nconst OPERATOR = new RegExp(\r\n\t// any of:\r\n\t'(' +\r\n\t\t// or operator\r\n\t\t'\\\\|' +\r\n\t\t// or\r\n\t\t'|' +\r\n\t\t// or group start\r\n\t\t'\\\\(\\\\?\\\\:' +\r\n\t\t// or\r\n\t\t'|' +\r\n\t\t// or group end\r\n\t\t'\\\\)' +\r\n\t\t// or\r\n\t\t'|' +\r\n\t\t// one-of set start\r\n\t\t'\\\\[' +\r\n\t\t// or\r\n\t\t'|' +\r\n\t\t// one-of set end\r\n\t\t'\\\\]' +\r\n\t')'\r\n)\r\n\r\nfunction expandSingleElementArray(array) {\r\n\tif (array.length === 1) {\r\n\t\treturn array[0]\r\n\t}\r\n\treturn array\r\n}","// This is a port of Google Android `libphonenumber`'s\r\n// `phonenumberutil.js` of December 31th, 2018.\r\n//\r\n// https://github.com/googlei18n/libphonenumber/commits/master/javascript/i18n/phonenumbers/phonenumberutil.js\r\n\r\nimport matchesEntirely from './helpers/matchesEntirely.js'\r\nimport formatNationalNumberUsingFormat from './helpers/formatNationalNumberUsingFormat.js'\r\nimport Metadata, { getCountryCallingCode } from './metadata.js'\r\nimport getIddPrefix from './helpers/getIddPrefix.js'\r\nimport { formatRFC3966 } from './helpers/RFC3966.js'\r\n\r\nconst DEFAULT_OPTIONS = {\r\n\tformatExtension: (formattedNumber, extension, metadata) => `${formattedNumber}${metadata.ext()}${extension}`\r\n}\r\n\r\n/**\r\n * Formats a phone number.\r\n *\r\n * format(phoneNumberInstance, 'INTERNATIONAL', { ..., v2: true }, metadata)\r\n * format(phoneNumberInstance, 'NATIONAL', { ..., v2: true }, metadata)\r\n *\r\n * format({ phone: '8005553535', country: 'RU' }, 'INTERNATIONAL', { ... }, metadata)\r\n * format({ phone: '8005553535', country: 'RU' }, 'NATIONAL', undefined, metadata)\r\n *\r\n * @param  {object|PhoneNumber} input — If `options.v2: true` flag is passed, the `input` should be a `PhoneNumber` instance. Otherwise, it should be an object of shape `{ phone: '...', country: '...' }`.\r\n * @param  {string} format\r\n * @param  {object} [options]\r\n * @param  {object} metadata\r\n * @return {string}\r\n */\r\nexport default function formatNumber(input, format, options, metadata) {\r\n\t// Apply default options.\r\n\tif (options) {\r\n\t\t// Using ES6 \"rest spread\" syntax here didn't work with `babel`/`istanbul`\r\n\t\t// for some weird reason: this line of code would cause the code coverage\r\n\t\t// to show as not 100%. That's because `babel`/`istanbul`, for some weird reason,\r\n\t\t// apparently doesn't know how to properly exclude Babel polyfills from code coverage.\r\n\t\t//\r\n\t\t// options = { ...DEFAULT_OPTIONS, ...options }\r\n\t\t//\r\n\t\toptions = merge({}, DEFAULT_OPTIONS, options)\r\n\t} else {\r\n\t\toptions = DEFAULT_OPTIONS\r\n\t}\r\n\r\n\tmetadata = new Metadata(metadata)\r\n\r\n\tif (input.country && input.country !== '001') {\r\n\t\t// Validate `input.country`.\r\n\t\tif (!metadata.hasCountry(input.country)) {\r\n\t\t\tthrow new Error(`Unknown country: ${input.country}`)\r\n\t\t}\r\n\t\tmetadata.selectNumberingPlan(input.country)\r\n\t}\r\n\telse if (input.countryCallingCode) {\r\n\t\tmetadata.selectNumberingPlan(input.countryCallingCode)\r\n\t}\r\n\telse return input.phone || ''\r\n\r\n\tconst countryCallingCode = metadata.countryCallingCode()\r\n\r\n\tconst nationalNumber = options.v2 ? input.nationalNumber : input.phone\r\n\r\n\t// This variable should have been declared inside `case`s\r\n\t// but Babel has a bug and it says \"duplicate variable declaration\".\r\n\tlet number\r\n\r\n\tswitch (format) {\r\n\t\tcase 'NATIONAL':\r\n\t\t\t// Legacy argument support.\r\n\t\t\t// (`{ country: ..., phone: '' }`)\r\n\t\t\tif (!nationalNumber) {\r\n\t\t\t\treturn ''\r\n\t\t\t}\r\n\t\t\tnumber = formatNationalNumber(nationalNumber, input.carrierCode, 'NATIONAL', metadata, options)\r\n\t\t\treturn addExtension(number, input.ext, metadata, options.formatExtension)\r\n\r\n\t\tcase 'INTERNATIONAL':\r\n\t\t\t// Legacy argument support.\r\n\t\t\t// (`{ country: ..., phone: '' }`)\r\n\t\t\tif (!nationalNumber) {\r\n\t\t\t\treturn `+${countryCallingCode}`\r\n\t\t\t}\r\n\t\t\tnumber = formatNationalNumber(nationalNumber, null, 'INTERNATIONAL', metadata, options)\r\n\t\t\tnumber = `+${countryCallingCode} ${number}`\r\n\t\t\treturn addExtension(number, input.ext, metadata, options.formatExtension)\r\n\r\n\t\tcase 'E.164':\r\n\t\t\t// `E.164` doesn't define \"phone number extensions\".\r\n\t\t\treturn `+${countryCallingCode}${nationalNumber}`\r\n\r\n\t\tcase 'RFC3966':\r\n\t\t\treturn formatRFC3966({\r\n\t\t\t\tnumber: `+${countryCallingCode}${nationalNumber}`,\r\n\t\t\t\text: input.ext\r\n\t\t\t})\r\n\r\n\t\t// For reference, here's Google's IDD formatter:\r\n\t\t// https://github.com/google/libphonenumber/blob/32719cf74e68796788d1ca45abc85dcdc63ba5b9/java/libphonenumber/src/com/google/i18n/phonenumbers/PhoneNumberUtil.java#L1546\r\n\t\t// Not saying that this IDD formatter replicates it 1:1, but it seems to work.\r\n\t\t// Who would even need to format phone numbers in IDD format anyway?\r\n\t\tcase 'IDD':\r\n\t\t\tif (!options.fromCountry) {\r\n\t\t\t\treturn\r\n\t\t\t\t// throw new Error('`fromCountry` option not passed for IDD-prefixed formatting.')\r\n\t\t\t}\r\n\t\t\tconst formattedNumber = formatIDD(\r\n\t\t\t\tnationalNumber,\r\n\t\t\t\tinput.carrierCode,\r\n\t\t\t\tcountryCallingCode,\r\n\t\t\t\toptions.fromCountry,\r\n\t\t\t\tmetadata\r\n\t\t\t)\r\n\t\t\treturn addExtension(formattedNumber, input.ext, metadata, options.formatExtension)\r\n\r\n\t\tdefault:\r\n\t\t\tthrow new Error(`Unknown \"format\" argument passed to \"formatNumber()\": \"${format}\"`)\r\n\t}\r\n}\r\n\r\nfunction formatNationalNumber(number, carrierCode, formatAs, metadata, options) {\r\n\tconst format = chooseFormatForNumber(metadata.formats(), number)\r\n\tif (!format) {\r\n\t\treturn number\r\n\t}\r\n\treturn formatNationalNumberUsingFormat(\r\n\t\tnumber,\r\n\t\tformat,\r\n\t\t{\r\n\t\t\tuseInternationalFormat: formatAs === 'INTERNATIONAL',\r\n\t\t\twithNationalPrefix: format.nationalPrefixIsOptionalWhenFormattingInNationalFormat() && (options && options.nationalPrefix === false) ? false : true,\r\n\t\t\tcarrierCode,\r\n\t\t\tmetadata\r\n\t\t}\r\n\t)\r\n}\r\n\r\nexport function chooseFormatForNumber(availableFormats, nationalNumber) {\r\n\t// Using a `for ... of` loop here didn't work with `babel`/`istanbul`:\r\n\t// for some weird reason, it showed code coverage less than 100%.\r\n\t// That's because `babel`/`istanbul`, for some weird reason,\r\n\t// apparently doesn't know how to properly exclude Babel polyfills from code coverage.\r\n\t//\r\n\t// for (const format of availableFormats) { ... }\r\n\t//\r\n\treturn pickFirstMatchingElement(availableFormats, (format) => {\r\n\t\t// Validate leading digits.\r\n\t\t// The test case for \"else path\" could be found by searching for\r\n\t\t// \"format.leadingDigitsPatterns().length === 0\".\r\n\t\tif (format.leadingDigitsPatterns().length > 0) {\r\n\t\t\t// The last leading_digits_pattern is used here, as it is the most detailed\r\n\t\t\tconst lastLeadingDigitsPattern = format.leadingDigitsPatterns()[format.leadingDigitsPatterns().length - 1]\r\n\t\t\t// If leading digits don't match then move on to the next phone number format\r\n\t\t\tif (nationalNumber.search(lastLeadingDigitsPattern) !== 0) {\r\n\t\t\t\treturn false\r\n\t\t\t}\r\n\t\t}\r\n\t\t// Check that the national number matches the phone number format regular expression\r\n\t\treturn matchesEntirely(nationalNumber, format.pattern())\r\n\t})\r\n}\r\n\r\nfunction addExtension(formattedNumber, ext, metadata, formatExtension) {\r\n\treturn ext ? formatExtension(formattedNumber, ext, metadata) : formattedNumber\r\n}\r\n\r\nfunction formatIDD(\r\n\tnationalNumber,\r\n\tcarrierCode,\r\n\tcountryCallingCode,\r\n\tfromCountry,\r\n\tmetadata\r\n) {\r\n\tconst fromCountryCallingCode = getCountryCallingCode(fromCountry, metadata.metadata)\r\n\t// When calling within the same country calling code.\r\n\tif (fromCountryCallingCode === countryCallingCode) {\r\n\t\tconst formattedNumber = formatNationalNumber(nationalNumber, carrierCode, 'NATIONAL', metadata)\r\n\t\t// For NANPA regions, return the national format for these regions\r\n\t\t// but prefix it with the country calling code.\r\n\t\tif (countryCallingCode === '1') {\r\n\t\t\treturn countryCallingCode + ' ' + formattedNumber\r\n\t\t}\r\n\t\t// If regions share a country calling code, the country calling code need\r\n\t\t// not be dialled. This also applies when dialling within a region, so this\r\n\t\t// if clause covers both these cases. Technically this is the case for\r\n\t\t// dialling from La Reunion to other overseas departments of France (French\r\n\t\t// Guiana, Martinique, Guadeloupe), but not vice versa - so we don't cover\r\n\t\t// this edge case for now and for those cases return the version including\r\n\t\t// country calling code. Details here:\r\n\t\t// http://www.petitfute.com/voyage/225-info-pratiques-reunion\r\n\t\t//\r\n\t\treturn formattedNumber\r\n\t}\r\n\tconst iddPrefix = getIddPrefix(fromCountry, undefined, metadata.metadata)\r\n\tif (iddPrefix) {\r\n\t\treturn `${iddPrefix} ${countryCallingCode} ${formatNationalNumber(nationalNumber, null, 'INTERNATIONAL', metadata)}`\r\n\t}\r\n}\r\n\r\nfunction merge(...objects) {\r\n\tlet i = 1\r\n\twhile (i < objects.length) {\r\n\t\tif (objects[i]) {\r\n\t\t\tfor (const key in objects[i]) {\r\n\t\t\t\tobjects[0][key] = objects[i][key]\r\n\t\t\t}\r\n\t\t}\r\n\t\ti++\r\n\t}\r\n\treturn objects[0]\r\n}\r\n\r\nfunction pickFirstMatchingElement(elements, testFunction) {\r\n\tlet i = 0\r\n\twhile (i < elements.length) {\r\n\t\tif (testFunction(elements[i])) {\r\n\t\t\treturn elements[i]\r\n\t\t}\r\n\t\ti++\r\n\t}\r\n}","import compare from './tools/semver-compare.js'\r\nimport isObject from './helpers/isObject.js'\r\n\r\n// Added \"possibleLengths\" and renamed\r\n// \"country_phone_code_to_countries\" to \"country_calling_codes\".\r\nconst V2 = '1.0.18'\r\n\r\n// Added \"idd_prefix\" and \"default_idd_prefix\".\r\nconst V3 = '1.2.0'\r\n\r\n// Moved `001` country code to \"nonGeographic\" section of metadata.\r\nconst V4 = '1.7.35'\r\n\r\nconst DEFAULT_EXT_PREFIX = ' ext. '\r\n\r\nconst CALLING_CODE_REG_EXP = /^\\d+$/\r\n\r\n/**\r\n * See: https://gitlab.com/catamphetamine/libphonenumber-js/blob/master/METADATA.md\r\n */\r\nexport default class Metadata {\r\n\tconstructor(metadata) {\r\n\t\tvalidateMetadata(metadata)\r\n\t\tthis.metadata = metadata\r\n\t\tsetVersion.call(this, metadata)\r\n\t}\r\n\r\n\tgetCountries() {\r\n\t\treturn Object.keys(this.metadata.countries).filter(_ => _ !== '001')\r\n\t}\r\n\r\n\tgetCountryMetadata(countryCode) {\r\n\t\treturn this.metadata.countries[countryCode]\r\n\t}\r\n\r\n\tnonGeographic() {\r\n\t\tif (this.v1 || this.v2 || this.v3) return\r\n\t\t// `nonGeographical` was a typo.\r\n\t\t// It's present in metadata generated from `1.7.35` to `1.7.37`.\r\n\t\t// The test case could be found by searching for \"nonGeographical\".\r\n\t\treturn this.metadata.nonGeographic || this.metadata.nonGeographical\r\n\t}\r\n\r\n\thasCountry(country) {\r\n\t\treturn this.getCountryMetadata(country) !== undefined\r\n\t}\r\n\r\n\thasCallingCode(callingCode) {\r\n\t\tif (this.getCountryCodesForCallingCode(callingCode)) {\r\n\t\t\treturn true\r\n\t\t}\r\n\t\tif (this.nonGeographic()) {\r\n\t\t\tif (this.nonGeographic()[callingCode]) {\r\n\t\t\t\treturn true\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\t// A hacky workaround for old custom metadata (generated before V4).\r\n\t\t\tconst countryCodes = this.countryCallingCodes()[callingCode]\r\n\t\t\tif (countryCodes && countryCodes.length === 1 && countryCodes[0] === '001') {\r\n\t\t\t\treturn true\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tisNonGeographicCallingCode(callingCode) {\r\n\t\tif (this.nonGeographic()) {\r\n\t\t\treturn this.nonGeographic()[callingCode] ? true : false\r\n\t\t} else {\r\n\t\t\treturn this.getCountryCodesForCallingCode(callingCode) ? false : true\r\n\t\t}\r\n\t}\r\n\r\n\t// Deprecated.\r\n\tcountry(countryCode) {\r\n\t\treturn this.selectNumberingPlan(countryCode)\r\n\t}\r\n\r\n\tselectNumberingPlan(countryCode, callingCode) {\r\n\t\t// Supports just passing `callingCode` as the first argument.\r\n\t\tif (countryCode && CALLING_CODE_REG_EXP.test(countryCode)) {\r\n\t\t\tcallingCode = countryCode\r\n\t\t\tcountryCode = null\r\n\t\t}\r\n\t\tif (countryCode && countryCode !== '001') {\r\n\t\t\tif (!this.hasCountry(countryCode)) {\r\n\t\t\t\tthrow new Error(`Unknown country: ${countryCode}`)\r\n\t\t\t}\r\n\t\t\tthis.numberingPlan = new NumberingPlan(this.getCountryMetadata(countryCode), this)\r\n\t\t} else if (callingCode) {\r\n\t\t\tif (!this.hasCallingCode(callingCode)) {\r\n\t\t\t\tthrow new Error(`Unknown calling code: ${callingCode}`)\r\n\t\t\t}\r\n\t\t\tthis.numberingPlan = new NumberingPlan(this.getNumberingPlanMetadata(callingCode), this)\r\n\t\t} else {\r\n\t\t\tthis.numberingPlan = undefined\r\n\t\t}\r\n\t\treturn this\r\n\t}\r\n\r\n\tgetCountryCodesForCallingCode(callingCode) {\r\n\t\tconst countryCodes = this.countryCallingCodes()[callingCode]\r\n\t\tif (countryCodes) {\r\n\t\t\t// Metadata before V4 included \"non-geographic entity\" calling codes\r\n\t\t\t// inside `country_calling_codes` (for example, `\"881\":[\"001\"]`).\r\n\t\t\t// Now the semantics of `country_calling_codes` has changed:\r\n\t\t\t// it's specifically for \"countries\" now.\r\n\t\t\t// Older versions of custom metadata will simply skip parsing\r\n\t\t\t// \"non-geographic entity\" phone numbers with new versions\r\n\t\t\t// of this library: it's not considered a bug,\r\n\t\t\t// because such numbers are extremely rare,\r\n\t\t\t// and developers extremely rarely use custom metadata.\r\n\t\t\tif (countryCodes.length === 1 && countryCodes[0].length === 3) {\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\treturn countryCodes\r\n\t\t}\r\n\t}\r\n\r\n\tgetCountryCodeForCallingCode(callingCode) {\r\n\t\tconst countryCodes = this.getCountryCodesForCallingCode(callingCode)\r\n\t\tif (countryCodes) {\r\n\t\t\treturn countryCodes[0]\r\n\t\t}\r\n\t}\r\n\r\n\tgetNumberingPlanMetadata(callingCode) {\r\n\t\tconst countryCode = this.getCountryCodeForCallingCode(callingCode)\r\n\t\tif (countryCode) {\r\n\t\t\treturn this.getCountryMetadata(countryCode)\r\n\t\t}\r\n\t\tif (this.nonGeographic()) {\r\n\t\t\tconst metadata = this.nonGeographic()[callingCode]\r\n\t\t\tif (metadata) {\r\n\t\t\t\treturn metadata\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\t// A hacky workaround for old custom metadata (generated before V4).\r\n\t\t\t// In that metadata, there was no concept of \"non-geographic\" metadata\r\n\t\t\t// so metadata for `001` country code was stored along with other countries.\r\n\t\t\t// The test case can be found by searching for:\r\n\t\t\t// \"should work around `nonGeographic` metadata not existing\".\r\n\t\t\tconst countryCodes = this.countryCallingCodes()[callingCode]\r\n\t\t\tif (countryCodes && countryCodes.length === 1 && countryCodes[0] === '001') {\r\n\t\t\t\treturn this.metadata.countries['001']\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// Deprecated.\r\n\tcountryCallingCode() {\r\n\t\treturn this.numberingPlan.callingCode()\r\n\t}\r\n\r\n\t// Deprecated.\r\n\tIDDPrefix() {\r\n\t\treturn this.numberingPlan.IDDPrefix()\r\n\t}\r\n\r\n\t// Deprecated.\r\n\tdefaultIDDPrefix() {\r\n\t\treturn this.numberingPlan.defaultIDDPrefix()\r\n\t}\r\n\r\n\t// Deprecated.\r\n\tnationalNumberPattern() {\r\n\t\treturn this.numberingPlan.nationalNumberPattern()\r\n\t}\r\n\r\n\t// Deprecated.\r\n\tpossibleLengths() {\r\n\t\treturn this.numberingPlan.possibleLengths()\r\n\t}\r\n\r\n\t// Deprecated.\r\n\tformats() {\r\n\t\treturn this.numberingPlan.formats()\r\n\t}\r\n\r\n\t// Deprecated.\r\n\tnationalPrefixForParsing() {\r\n\t\treturn this.numberingPlan.nationalPrefixForParsing()\r\n\t}\r\n\r\n\t// Deprecated.\r\n\tnationalPrefixTransformRule() {\r\n\t\treturn this.numberingPlan.nationalPrefixTransformRule()\r\n\t}\r\n\r\n\t// Deprecated.\r\n\tleadingDigits() {\r\n\t\treturn this.numberingPlan.leadingDigits()\r\n\t}\r\n\r\n\t// Deprecated.\r\n\thasTypes() {\r\n\t\treturn this.numberingPlan.hasTypes()\r\n\t}\r\n\r\n\t// Deprecated.\r\n\ttype(type) {\r\n\t\treturn this.numberingPlan.type(type)\r\n\t}\r\n\r\n\t// Deprecated.\r\n\text() {\r\n\t\treturn this.numberingPlan.ext()\r\n\t}\r\n\r\n\tcountryCallingCodes() {\r\n\t\tif (this.v1) return this.metadata.country_phone_code_to_countries\r\n\t\treturn this.metadata.country_calling_codes\r\n\t}\r\n\r\n\t// Deprecated.\r\n\tchooseCountryByCountryCallingCode(callingCode) {\r\n\t\treturn this.selectNumberingPlan(callingCode)\r\n\t}\r\n\r\n\thasSelectedNumberingPlan() {\r\n\t\treturn this.numberingPlan !== undefined\r\n\t}\r\n}\r\n\r\nclass NumberingPlan {\r\n\tconstructor(metadata, globalMetadataObject) {\r\n\t\tthis.globalMetadataObject = globalMetadataObject\r\n\t\tthis.metadata = metadata\r\n\t\tsetVersion.call(this, globalMetadataObject.metadata)\r\n\t}\r\n\r\n\tcallingCode() {\r\n\t\treturn this.metadata[0]\r\n\t}\r\n\r\n\t// Formatting information for regions which share\r\n\t// a country calling code is contained by only one region\r\n\t// for performance reasons. For example, for NANPA region\r\n\t// (\"North American Numbering Plan Administration\",\r\n\t//  which includes USA, Canada, Cayman Islands, Bahamas, etc)\r\n\t// it will be contained in the metadata for `US`.\r\n\tgetDefaultCountryMetadataForRegion() {\r\n\t\treturn this.globalMetadataObject.getNumberingPlanMetadata(this.callingCode())\r\n\t}\r\n\r\n\t// Is always present.\r\n\tIDDPrefix() {\r\n\t\tif (this.v1 || this.v2) return\r\n\t\treturn this.metadata[1]\r\n\t}\r\n\r\n\t// Is only present when a country supports multiple IDD prefixes.\r\n\tdefaultIDDPrefix() {\r\n\t\tif (this.v1 || this.v2) return\r\n\t\treturn this.metadata[12]\r\n\t}\r\n\r\n\tnationalNumberPattern() {\r\n\t\tif (this.v1 || this.v2) return this.metadata[1]\r\n\t\treturn this.metadata[2]\r\n\t}\r\n\r\n\t// \"possible length\" data is always present in Google's metadata.\r\n\tpossibleLengths() {\r\n\t\tif (this.v1) return\r\n\t\treturn this.metadata[this.v2 ? 2 : 3]\r\n\t}\r\n\r\n\t_getFormats(metadata) {\r\n\t\treturn metadata[this.v1 ? 2 : this.v2 ? 3 : 4]\r\n\t}\r\n\r\n\t// For countries of the same region (e.g. NANPA)\r\n\t// formats are all stored in the \"main\" country for that region.\r\n\t// E.g. \"RU\" and \"KZ\", \"US\" and \"CA\".\r\n\tformats() {\r\n\t\tconst formats = this._getFormats(this.metadata) || this._getFormats(this.getDefaultCountryMetadataForRegion()) || []\r\n\t\treturn formats.map(_ => new Format(_, this))\r\n\t}\r\n\r\n\tnationalPrefix() {\r\n\t\treturn this.metadata[this.v1 ? 3 : this.v2 ? 4 : 5]\r\n\t}\r\n\r\n\t_getNationalPrefixFormattingRule(metadata) {\r\n\t\treturn metadata[this.v1 ? 4 : this.v2 ? 5 : 6]\r\n\t}\r\n\r\n\t// For countries of the same region (e.g. NANPA)\r\n\t// national prefix formatting rule is stored in the \"main\" country for that region.\r\n\t// E.g. \"RU\" and \"KZ\", \"US\" and \"CA\".\r\n\tnationalPrefixFormattingRule() {\r\n\t\treturn this._getNationalPrefixFormattingRule(this.metadata) || this._getNationalPrefixFormattingRule(this.getDefaultCountryMetadataForRegion())\r\n\t}\r\n\r\n\t_nationalPrefixForParsing() {\r\n\t\treturn this.metadata[this.v1 ? 5 : this.v2 ? 6 : 7]\r\n\t}\r\n\r\n\tnationalPrefixForParsing() {\r\n\t\t// If `national_prefix_for_parsing` is not set explicitly,\r\n\t\t// then infer it from `national_prefix` (if any)\r\n\t\treturn this._nationalPrefixForParsing() || this.nationalPrefix()\r\n\t}\r\n\r\n\tnationalPrefixTransformRule() {\r\n\t\treturn this.metadata[this.v1 ? 6 : this.v2 ? 7 : 8]\r\n\t}\r\n\r\n\t_getNationalPrefixIsOptionalWhenFormatting() {\r\n\t\treturn !!this.metadata[this.v1 ? 7 : this.v2 ? 8 : 9]\r\n\t}\r\n\r\n\t// For countries of the same region (e.g. NANPA)\r\n\t// \"national prefix is optional when formatting\" flag is\r\n\t// stored in the \"main\" country for that region.\r\n\t// E.g. \"RU\" and \"KZ\", \"US\" and \"CA\".\r\n\tnationalPrefixIsOptionalWhenFormattingInNationalFormat() {\r\n\t\treturn this._getNationalPrefixIsOptionalWhenFormatting(this.metadata) ||\r\n\t\t\tthis._getNationalPrefixIsOptionalWhenFormatting(this.getDefaultCountryMetadataForRegion())\r\n\t}\r\n\r\n\tleadingDigits() {\r\n\t\treturn this.metadata[this.v1 ? 8 : this.v2 ? 9 : 10]\r\n\t}\r\n\r\n\ttypes() {\r\n\t\treturn this.metadata[this.v1 ? 9 : this.v2 ? 10 : 11]\r\n\t}\r\n\r\n\thasTypes() {\r\n\t\t// Versions 1.2.0 - 1.2.4: can be `[]`.\r\n\t\t/* istanbul ignore next */\r\n\t\tif (this.types() && this.types().length === 0) {\r\n\t\t\treturn false\r\n\t\t}\r\n\t\t// Versions <= 1.2.4: can be `undefined`.\r\n\t\t// Version >= 1.2.5: can be `0`.\r\n\t\treturn !!this.types()\r\n\t}\r\n\r\n\ttype(type) {\r\n\t\tif (this.hasTypes() && getType(this.types(), type)) {\r\n\t\t\treturn new Type(getType(this.types(), type), this)\r\n\t\t}\r\n\t}\r\n\r\n\text() {\r\n\t\tif (this.v1 || this.v2) return DEFAULT_EXT_PREFIX\r\n\t\treturn this.metadata[13] || DEFAULT_EXT_PREFIX\r\n\t}\r\n}\r\n\r\nclass Format {\r\n\tconstructor(format, metadata) {\r\n\t\tthis._format = format\r\n\t\tthis.metadata = metadata\r\n\t}\r\n\r\n\tpattern() {\r\n\t\treturn this._format[0]\r\n\t}\r\n\r\n\tformat() {\r\n\t\treturn this._format[1]\r\n\t}\r\n\r\n\tleadingDigitsPatterns() {\r\n\t\treturn this._format[2] || []\r\n\t}\r\n\r\n\tnationalPrefixFormattingRule() {\r\n\t\treturn this._format[3] || this.metadata.nationalPrefixFormattingRule()\r\n\t}\r\n\r\n\tnationalPrefixIsOptionalWhenFormattingInNationalFormat() {\r\n\t\treturn !!this._format[4] || this.metadata.nationalPrefixIsOptionalWhenFormattingInNationalFormat()\r\n\t}\r\n\r\n\tnationalPrefixIsMandatoryWhenFormattingInNationalFormat() {\r\n\t\t// National prefix is omitted if there's no national prefix formatting rule\r\n\t\t// set for this country, or when the national prefix formatting rule\r\n\t\t// contains no national prefix itself, or when this rule is set but\r\n\t\t// national prefix is optional for this phone number format\r\n\t\t// (and it is not enforced explicitly)\r\n\t\treturn this.usesNationalPrefix() && !this.nationalPrefixIsOptionalWhenFormattingInNationalFormat()\r\n\t}\r\n\r\n\t// Checks whether national prefix formatting rule contains national prefix.\r\n\tusesNationalPrefix() {\r\n\t\treturn this.nationalPrefixFormattingRule() &&\r\n\t\t\t// Check that national prefix formatting rule is not a \"dummy\" one.\r\n\t\t\t!FIRST_GROUP_ONLY_PREFIX_PATTERN.test(this.nationalPrefixFormattingRule())\r\n\t\t\t// In compressed metadata, `this.nationalPrefixFormattingRule()` is `0`\r\n\t\t\t// when `national_prefix_formatting_rule` is not present.\r\n\t\t\t// So, `true` or `false` are returned explicitly here, so that\r\n\t\t\t// `0` number isn't returned.\r\n\t\t\t? true\r\n\t\t\t: false\r\n\t}\r\n\r\n\tinternationalFormat() {\r\n\t\treturn this._format[5] || this.format()\r\n\t}\r\n}\r\n\r\n/**\r\n * A pattern that is used to determine if the national prefix formatting rule\r\n * has the first group only, i.e., does not start with the national prefix.\r\n * Note that the pattern explicitly allows for unbalanced parentheses.\r\n */\r\nconst FIRST_GROUP_ONLY_PREFIX_PATTERN = /^\\(?\\$1\\)?$/\r\n\r\nclass Type {\r\n\tconstructor(type, metadata) {\r\n\t\tthis.type = type\r\n\t\tthis.metadata = metadata\r\n\t}\r\n\r\n\tpattern() {\r\n\t\tif (this.metadata.v1) return this.type\r\n\t\treturn this.type[0]\r\n\t}\r\n\r\n\tpossibleLengths() {\r\n\t\tif (this.metadata.v1) return\r\n\t\treturn this.type[1] || this.metadata.possibleLengths()\r\n\t}\r\n}\r\n\r\nfunction getType(types, type) {\r\n\tswitch (type) {\r\n\t\tcase 'FIXED_LINE':\r\n\t\t\treturn types[0]\r\n\t\tcase 'MOBILE':\r\n\t\t\treturn types[1]\r\n\t\tcase 'TOLL_FREE':\r\n\t\t\treturn types[2]\r\n\t\tcase 'PREMIUM_RATE':\r\n\t\t\treturn types[3]\r\n\t\tcase 'PERSONAL_NUMBER':\r\n\t\t\treturn types[4]\r\n\t\tcase 'VOICEMAIL':\r\n\t\t\treturn types[5]\r\n\t\tcase 'UAN':\r\n\t\t\treturn types[6]\r\n\t\tcase 'PAGER':\r\n\t\t\treturn types[7]\r\n\t\tcase 'VOIP':\r\n\t\t\treturn types[8]\r\n\t\tcase 'SHARED_COST':\r\n\t\t\treturn types[9]\r\n\t}\r\n}\r\n\r\nexport function validateMetadata(metadata) {\r\n\tif (!metadata) {\r\n\t\tthrow new Error('[libphonenumber-js] `metadata` argument not passed. Check your arguments.')\r\n\t}\r\n\r\n\t// `country_phone_code_to_countries` was renamed to `country_calling_codes` in `1.0.18`.\r\n\t// For that reason, it's not used in this detection algorithm.\r\n\t// Instead, it detects by `countries: {}` property existence.\r\n\tif (!isObject(metadata) || !isObject(metadata.countries)) {\r\n\t\tthrow new Error(`[libphonenumber-js] \\`metadata\\` argument was passed but it's not a valid metadata. Must be an object having \\`.countries\\` child object property. Got ${isObject(metadata) ? 'an object of shape: { ' + Object.keys(metadata).join(', ') + ' }' : 'a ' + typeOf(metadata) + ': ' + metadata}.`)\r\n\t}\r\n}\r\n\r\n// Babel transforms `typeof` into some \"branches\"\r\n// so istanbul will show this as \"branch not covered\".\r\n/* istanbul ignore next */\r\nconst typeOf = _ => typeof _\r\n\r\n/**\r\n * Returns extension prefix for a country.\r\n * @param  {string} country\r\n * @param  {object} metadata\r\n * @return {string?}\r\n * @example\r\n * // Returns \" ext. \"\r\n * getExtPrefix(\"US\")\r\n */\r\nexport function getExtPrefix(country, metadata) {\r\n\tmetadata = new Metadata(metadata)\r\n\tif (metadata.hasCountry(country)) {\r\n\t\treturn metadata.selectNumberingPlan(country).ext()\r\n\t}\r\n\treturn DEFAULT_EXT_PREFIX\r\n}\r\n\r\n/**\r\n * Returns \"country calling code\" for a country.\r\n * Throws an error if the country doesn't exist or isn't supported by this library.\r\n * @param  {string} country\r\n * @param  {object} metadata\r\n * @return {string}\r\n * @example\r\n * // Returns \"44\"\r\n * getCountryCallingCode(\"GB\")\r\n */\r\nexport function getCountryCallingCode(country, metadata) {\r\n\tmetadata = new Metadata(metadata)\r\n\tif (metadata.hasCountry(country)) {\r\n\t\treturn metadata.selectNumberingPlan(country).countryCallingCode()\r\n\t}\r\n\tthrow new Error(`Unknown country: ${country}`)\r\n}\r\n\r\nexport function isSupportedCountry(country, metadata) {\r\n\t// metadata = new Metadata(metadata)\r\n\t// return metadata.hasCountry(country)\r\n\treturn metadata.countries.hasOwnProperty(country)\r\n}\r\n\r\nfunction setVersion(metadata) {\r\n\tconst { version } = metadata\r\n\tif (typeof version === 'number') {\r\n\t\tthis.v1 = version === 1\r\n\t\tthis.v2 = version === 2\r\n\t\tthis.v3 = version === 3\r\n\t\tthis.v4 = version === 4\r\n\t} else {\r\n\t\tif (!version) {\r\n\t\t\tthis.v1 = true\r\n\t\t} else if (compare(version, V3) === -1) {\r\n\t\t\tthis.v2 = true\r\n\t\t} else if (compare(version, V4) === -1) {\r\n\t\t\tthis.v3 = true\r\n\t\t} else {\r\n\t\t\tthis.v4 = true\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// const ISO_COUNTRY_CODE = /^[A-Z]{2}$/\r\n// function isCountryCode(countryCode) {\r\n// \treturn ISO_COUNTRY_CODE.test(countryCodeOrCountryCallingCode)\r\n// }","// Copy-pasted from:\r\n// https://github.com/substack/semver-compare/blob/master/index.js\r\n//\r\n// Inlining this function because some users reported issues with\r\n// importing from `semver-compare` in a browser with ES6 \"native\" modules.\r\n//\r\n// Fixes `semver-compare` not being able to compare versions with alpha/beta/etc \"tags\".\r\n// https://github.com/catamphetamine/libphonenumber-js/issues/381\r\nexport default function(a, b) {\r\n    a = a.split('-')\r\n    b = b.split('-')\r\n    var pa = a[0].split('.')\r\n    var pb = b[0].split('.')\r\n    for (var i = 0; i < 3; i++) {\r\n        var na = Number(pa[i])\r\n        var nb = Number(pb[i])\r\n        if (na > nb) return 1\r\n        if (nb > na) return -1\r\n        if (!isNaN(na) && isNaN(nb)) return 1\r\n        if (isNaN(na) && !isNaN(nb)) return -1\r\n    }\r\n    if (a[1] && b[1]) {\r\n        return a[1] > b[1] ? 1 : (a[1] < b[1] ? -1 : 0)\r\n    }\r\n    return !a[1] && b[1] ? 1 : (a[1] && !b[1] ? -1 : 0)\r\n}","// These mappings map a character (key) to a specific digit that should\r\n// replace it for normalization purposes. Non-European digits that\r\n// may be used in phone numbers are mapped to a European equivalent.\r\n//\r\n// E.g. in Iraq they don't write `+442323234` but rather `+٤٤٢٣٢٣٢٣٤`.\r\n//\r\nexport const DIGITS = {\r\n\t'0': '0',\r\n\t'1': '1',\r\n\t'2': '2',\r\n\t'3': '3',\r\n\t'4': '4',\r\n\t'5': '5',\r\n\t'6': '6',\r\n\t'7': '7',\r\n\t'8': '8',\r\n\t'9': '9',\r\n\t'\\uFF10': '0', // Fullwidth digit 0\r\n\t'\\uFF11': '1', // Fullwidth digit 1\r\n\t'\\uFF12': '2', // Fullwidth digit 2\r\n\t'\\uFF13': '3', // Fullwidth digit 3\r\n\t'\\uFF14': '4', // Fullwidth digit 4\r\n\t'\\uFF15': '5', // Fullwidth digit 5\r\n\t'\\uFF16': '6', // Fullwidth digit 6\r\n\t'\\uFF17': '7', // Fullwidth digit 7\r\n\t'\\uFF18': '8', // Fullwidth digit 8\r\n\t'\\uFF19': '9', // Fullwidth digit 9\r\n\t'\\u0660': '0', // Arabic-indic digit 0\r\n\t'\\u0661': '1', // Arabic-indic digit 1\r\n\t'\\u0662': '2', // Arabic-indic digit 2\r\n\t'\\u0663': '3', // Arabic-indic digit 3\r\n\t'\\u0664': '4', // Arabic-indic digit 4\r\n\t'\\u0665': '5', // Arabic-indic digit 5\r\n\t'\\u0666': '6', // Arabic-indic digit 6\r\n\t'\\u0667': '7', // Arabic-indic digit 7\r\n\t'\\u0668': '8', // Arabic-indic digit 8\r\n\t'\\u0669': '9', // Arabic-indic digit 9\r\n\t'\\u06F0': '0', // Eastern-Arabic digit 0\r\n\t'\\u06F1': '1', // Eastern-Arabic digit 1\r\n\t'\\u06F2': '2', // Eastern-Arabic digit 2\r\n\t'\\u06F3': '3', // Eastern-Arabic digit 3\r\n\t'\\u06F4': '4', // Eastern-Arabic digit 4\r\n\t'\\u06F5': '5', // Eastern-Arabic digit 5\r\n\t'\\u06F6': '6', // Eastern-Arabic digit 6\r\n\t'\\u06F7': '7', // Eastern-Arabic digit 7\r\n\t'\\u06F8': '8', // Eastern-Arabic digit 8\r\n\t'\\u06F9': '9'  // Eastern-Arabic digit 9\r\n}\r\n\r\nexport function parseDigit(character) {\r\n\treturn DIGITS[character]\r\n}\r\n\r\n/**\r\n * Parses phone number digits from a string.\r\n * Drops all punctuation leaving only digits.\r\n * Also converts wide-ascii and arabic-indic numerals to conventional numerals.\r\n * E.g. in Iraq they don't write `+442323234` but rather `+٤٤٢٣٢٣٢٣٤`.\r\n * @param  {string} string\r\n * @return {string}\r\n * @example\r\n * ```js\r\n * parseDigits('8 (800) 555')\r\n * // Outputs '8800555'.\r\n * ```\r\n */\r\nexport default function parseDigits(string) {\r\n\tlet result = ''\r\n\t// Using `.split('')` here instead of normal `for ... of`\r\n\t// because the importing application doesn't neccessarily include an ES6 polyfill.\r\n\t// The `.split('')` approach discards \"exotic\" UTF-8 characters\r\n\t// (the ones consisting of four bytes) but digits\r\n\t// (including non-European ones) don't fall into that range\r\n\t// so such \"exotic\" characters would be discarded anyway.\r\n\tfor (const character of string.split('')) {\r\n\t\tconst digit = parseDigit(character)\r\n\t\tif (digit) {\r\n\t\t\tresult += digit\r\n\t\t}\r\n\t}\r\n\treturn result\r\n}","/**\r\n * Merges two arrays.\r\n * @param  {*} a\r\n * @param  {*} b\r\n * @return {*}\r\n */\r\nexport default function mergeArrays(a, b) {\r\n\tconst merged = a.slice()\r\n\r\n\tfor (const element of b) {\r\n\t\tif (a.indexOf(element) < 0) {\r\n\t\t\tmerged.push(element)\r\n\t\t}\r\n\t}\r\n\r\n\treturn merged.sort((a, b) => a - b)\r\n\r\n\t// ES6 version, requires Set polyfill.\r\n\t// let merged = new Set(a)\r\n\t// for (const element of b) {\r\n\t// \tmerged.add(i)\r\n\t// }\r\n\t// return Array.from(merged).sort((a, b) => a - b)\r\n}","import Metadata, { validateMetadata } from './metadata.js'\r\nimport isPossibleNumber from './isPossible.js'\r\nimport isValidNumber from './isValid.js'\r\nimport getNumberType from './helpers/getNumberType.js'\r\nimport getPossibleCountriesForNumber from './helpers/getPossibleCountriesForNumber.js'\r\nimport extractCountryCallingCode from './helpers/extractCountryCallingCode.js'\r\nimport isObject from './helpers/isObject.js'\r\nimport formatNumber from './format.js'\r\n\r\nconst USE_NON_GEOGRAPHIC_COUNTRY_CODE = false\r\n\r\nexport default class PhoneNumber {\r\n\t/**\r\n\t * @param  {string} countryOrCountryCallingCode\r\n\t * @param  {string} nationalNumber\r\n\t * @param  {object} metadata — Metadata JSON\r\n\t * @return {PhoneNumber}\r\n\t */\r\n\tconstructor(countryOrCountryCallingCode, nationalNumber, metadata) {\r\n\t\t// Validate `countryOrCountryCallingCode` argument.\r\n\t\tif (!countryOrCountryCallingCode) {\r\n\t\t\tthrow new TypeError('First argument is required')\r\n\t\t}\r\n\t\tif (typeof countryOrCountryCallingCode !== 'string') {\r\n\t\t\tthrow new TypeError('First argument must be a string')\r\n\t\t}\r\n\r\n\t\t// In case of public API use: `constructor(number, metadata)`.\r\n\t\t// Transform the arguments from `constructor(number, metadata)` to\r\n\t\t// `constructor(countryOrCountryCallingCode, nationalNumber, metadata)`.\r\n\t\tif (countryOrCountryCallingCode[0] === '+' && !nationalNumber) {\r\n\t\t\tthrow new TypeError('`metadata` argument not passed')\r\n\t\t}\r\n\t\tif (isObject(nationalNumber) && isObject(nationalNumber.countries)) {\r\n\t\t\tmetadata = nationalNumber\r\n\t\t\tconst e164Number = countryOrCountryCallingCode\r\n\t\t\tif (!E164_NUMBER_REGEXP.test(e164Number)) {\r\n\t\t\t\tthrow new Error('Invalid `number` argument passed: must consist of a \"+\" followed by digits')\r\n\t\t\t}\r\n\t\t\tconst { countryCallingCode, number } = extractCountryCallingCode(e164Number, undefined, undefined, undefined, metadata)\r\n\t\t\tnationalNumber = number\r\n\t\t\tcountryOrCountryCallingCode = countryCallingCode\r\n\t\t\tif (!nationalNumber) {\r\n\t\t\t\tthrow new Error('Invalid `number` argument passed: too short')\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Validate `nationalNumber` argument.\r\n\t\tif (!nationalNumber) {\r\n\t\t\tthrow new TypeError('`nationalNumber` argument is required')\r\n\t\t}\r\n\t\tif (typeof nationalNumber !== 'string') {\r\n\t\t\tthrow new TypeError('`nationalNumber` argument must be a string')\r\n\t\t}\r\n\r\n\t\t// Validate `metadata` argument.\r\n\t\tvalidateMetadata(metadata)\r\n\r\n\t\t// Initialize properties.\r\n\t\tconst { country, countryCallingCode } = getCountryAndCountryCallingCode(\r\n\t\t\tcountryOrCountryCallingCode,\r\n\t\t\tmetadata\r\n\t\t)\r\n\t\tthis.country = country\r\n\t\tthis.countryCallingCode = countryCallingCode\r\n\t\tthis.nationalNumber = nationalNumber\r\n\t\tthis.number = '+' + this.countryCallingCode + this.nationalNumber\r\n\t\t// Exclude `metadata` property output from `PhoneNumber.toString()`\r\n\t\t// so that it doesn't clutter the console output of Node.js.\r\n\t\t// Previously, when Node.js did `console.log(new PhoneNumber(...))`,\r\n\t\t// it would output the whole internal structure of the `metadata` object.\r\n\t\tthis.getMetadata = () => metadata\r\n\t}\r\n\r\n\tsetExt(ext) {\r\n\t\tthis.ext = ext\r\n\t}\r\n\r\n\tgetPossibleCountries() {\r\n\t\tif (this.country) {\r\n\t\t\treturn [this.country]\r\n\t\t}\r\n\t\treturn getPossibleCountriesForNumber(\r\n\t\t\tthis.countryCallingCode,\r\n\t\t\tthis.nationalNumber,\r\n\t\t\tthis.getMetadata()\r\n\t\t)\r\n\t}\r\n\r\n\tisPossible() {\r\n\t\treturn isPossibleNumber(this, { v2: true }, this.getMetadata())\r\n\t}\r\n\r\n\tisValid() {\r\n\t\treturn isValidNumber(this, { v2: true }, this.getMetadata())\r\n\t}\r\n\r\n\tisNonGeographic() {\r\n\t\tconst metadata = new Metadata(this.getMetadata())\r\n\t\treturn metadata.isNonGeographicCallingCode(this.countryCallingCode)\r\n\t}\r\n\r\n\tisEqual(phoneNumber) {\r\n\t\treturn this.number === phoneNumber.number && this.ext === phoneNumber.ext\r\n\t}\r\n\r\n\t// This function was originally meant to be an equivalent for `validatePhoneNumberLength()`,\r\n\t// but later it was found out that it doesn't include the possible `TOO_SHORT` result\r\n\t// returned from `parsePhoneNumberWithError()` in the original `validatePhoneNumberLength()`,\r\n\t// so eventually I simply commented out this method from the `PhoneNumber` class\r\n\t// and just left the `validatePhoneNumberLength()` function, even though that one would require\r\n\t// and additional step to also validate the actual country / calling code of the phone number.\r\n\t// validateLength() {\r\n\t// \tconst metadata = new Metadata(this.getMetadata())\r\n\t// \tmetadata.selectNumberingPlan(this.countryCallingCode)\r\n\t// \tconst result = checkNumberLength(this.nationalNumber, metadata)\r\n\t// \tif (result !== 'IS_POSSIBLE') {\r\n\t// \t\treturn result\r\n\t// \t}\r\n\t// }\r\n\r\n\tgetType() {\r\n\t\treturn getNumberType(this, { v2: true }, this.getMetadata())\r\n\t}\r\n\r\n\tformat(format, options) {\r\n\t\treturn formatNumber(\r\n\t\t\tthis,\r\n\t\t\tformat,\r\n\t\t\toptions ? { ...options, v2: true } : { v2: true },\r\n\t\t\tthis.getMetadata()\r\n\t\t)\r\n\t}\r\n\r\n\tformatNational(options) {\r\n\t\treturn this.format('NATIONAL', options)\r\n\t}\r\n\r\n\tformatInternational(options) {\r\n\t\treturn this.format('INTERNATIONAL', options)\r\n\t}\r\n\r\n\tgetURI(options) {\r\n\t\treturn this.format('RFC3966', options)\r\n\t}\r\n}\r\n\r\nconst isCountryCode = (value) => /^[A-Z]{2}$/.test(value)\r\n\r\nfunction getCountryAndCountryCallingCode(countryOrCountryCallingCode, metadataJson) {\r\n\tlet country\r\n\tlet countryCallingCode\r\n\r\n\tconst metadata = new Metadata(metadataJson)\r\n\t// If country code is passed then derive `countryCallingCode` from it.\r\n\t// Also store the country code as `.country`.\r\n\tif (isCountryCode(countryOrCountryCallingCode)) {\r\n\t\tcountry = countryOrCountryCallingCode\r\n\t\tmetadata.selectNumberingPlan(country)\r\n\t\tcountryCallingCode = metadata.countryCallingCode()\r\n\t} else {\r\n\t\tcountryCallingCode = countryOrCountryCallingCode\r\n\t\t/* istanbul ignore if */\r\n\t\tif (USE_NON_GEOGRAPHIC_COUNTRY_CODE) {\r\n\t\t\tif (metadata.isNonGeographicCallingCode(countryCallingCode)) {\r\n\t\t\t\tcountry = '001'\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn {\r\n\t\tcountry,\r\n\t\tcountryCallingCode\r\n\t}\r\n}\r\n\r\nconst E164_NUMBER_REGEXP = /^\\+\\d+$/","import {\r\n\tDIGIT_PLACEHOLDER,\r\n\tcountOccurences,\r\n\trepeat,\r\n\tcutAndStripNonPairedParens,\r\n\tcloseNonPairedParens,\r\n\tstripNonPairedParens,\r\n\tpopulateTemplateWithDigits\r\n} from './AsYouTypeFormatter.util.js'\r\n\r\nimport formatCompleteNumber, {\r\n\tcanFormatCompleteNumber\r\n} from './AsYouTypeFormatter.complete.js'\r\n\r\nimport PatternMatcher from './AsYouTypeFormatter.PatternMatcher.js'\r\n\r\nimport parseDigits from './helpers/parseDigits.js'\r\nexport { DIGIT_PLACEHOLDER } from './AsYouTypeFormatter.util.js'\r\nimport { FIRST_GROUP_PATTERN } from './helpers/formatNationalNumberUsingFormat.js'\r\nimport { VALID_PUNCTUATION } from './constants.js'\r\nimport applyInternationalSeparatorStyle from './helpers/applyInternationalSeparatorStyle.js'\r\n\r\n// Used in phone number format template creation.\r\n// Could be any digit, I guess.\r\nconst DUMMY_DIGIT = '9'\r\n// I don't know why is it exactly `15`\r\nconst LONGEST_NATIONAL_PHONE_NUMBER_LENGTH = 15\r\n// Create a phone number consisting only of the digit 9 that matches the\r\n// `number_pattern` by applying the pattern to the \"longest phone number\" string.\r\nconst LONGEST_DUMMY_PHONE_NUMBER = repeat(DUMMY_DIGIT, LONGEST_NATIONAL_PHONE_NUMBER_LENGTH)\r\n\r\n// A set of characters that, if found in a national prefix formatting rules, are an indicator to\r\n// us that we should separate the national prefix from the number when formatting.\r\nconst NATIONAL_PREFIX_SEPARATORS_PATTERN = /[- ]/\r\n\r\n// Deprecated: Google has removed some formatting pattern related code from their repo.\r\n// https://github.com/googlei18n/libphonenumber/commit/a395b4fef3caf57c4bc5f082e1152a4d2bd0ba4c\r\n// \"We no longer have numbers in formatting matching patterns, only \\d.\"\r\n// Because this library supports generating custom metadata\r\n// some users may still be using old metadata so the relevant\r\n// code seems to stay until some next major version update.\r\nconst SUPPORT_LEGACY_FORMATTING_PATTERNS = true\r\n\r\n// A pattern that is used to match character classes in regular expressions.\r\n// An example of a character class is \"[1-4]\".\r\nconst CREATE_CHARACTER_CLASS_PATTERN = SUPPORT_LEGACY_FORMATTING_PATTERNS && (() => /\\[([^\\[\\]])*\\]/g)\r\n\r\n// Any digit in a regular expression that actually denotes a digit. For\r\n// example, in the regular expression \"80[0-2]\\d{6,10}\", the first 2 digits\r\n// (8 and 0) are standalone digits, but the rest are not.\r\n// Two look-aheads are needed because the number following \\\\d could be a\r\n// two-digit number, since the phone number can be as long as 15 digits.\r\nconst CREATE_STANDALONE_DIGIT_PATTERN = SUPPORT_LEGACY_FORMATTING_PATTERNS && (() => /\\d(?=[^,}][^,}])/g)\r\n\r\n// A regular expression that is used to determine if a `format` is\r\n// suitable to be used in the \"as you type formatter\".\r\n// A `format` is suitable when the resulting formatted number has\r\n// the same digits as the user has entered.\r\n//\r\n// In the simplest case, that would mean that the format\r\n// doesn't add any additional digits when formatting a number.\r\n// Google says that it also shouldn't add \"star\" (`*`) characters,\r\n// like it does in some Israeli formats.\r\n// Such basic format would only contain \"valid punctuation\"\r\n// and \"captured group\" identifiers ($1, $2, etc).\r\n//\r\n// An example of a format that adds additional digits:\r\n//\r\n// Country: `AR` (Argentina).\r\n// Format:\r\n// {\r\n//    \"pattern\": \"(\\\\d)(\\\\d{2})(\\\\d{4})(\\\\d{4})\",\r\n//    \"leading_digits_patterns\": [\"91\"],\r\n//    \"national_prefix_formatting_rule\": \"0$1\",\r\n//    \"format\": \"$2 15-$3-$4\",\r\n//    \"international_format\": \"$1 $2 $3-$4\"\r\n// }\r\n//\r\n// In the format above, the `format` adds `15` to the digits when formatting a number.\r\n// A sidenote: this format actually is suitable because `national_prefix_for_parsing`\r\n// has previously removed `15` from a national number, so re-adding `15` in `format`\r\n// doesn't actually result in any extra digits added to user's input.\r\n// But verifying that would be a complex procedure, so the code chooses a simpler path:\r\n// it simply filters out all `format`s that contain anything but \"captured group\" ids.\r\n//\r\n// This regular expression is called `ELIGIBLE_FORMAT_PATTERN` in Google's\r\n// `libphonenumber` code.\r\n//\r\nconst NON_ALTERING_FORMAT_REG_EXP = new RegExp(\r\n\t'[' + VALID_PUNCTUATION + ']*' +\r\n\t// Google developers say:\r\n\t// \"We require that the first matching group is present in the\r\n\t//  output pattern to ensure no data is lost while formatting.\"\r\n\t'\\\\$1' +\r\n\t'[' + VALID_PUNCTUATION + ']*' +\r\n\t'(\\\\$\\\\d[' + VALID_PUNCTUATION + ']*)*' +\r\n\t'$'\r\n)\r\n\r\n// This is the minimum length of the leading digits of a phone number\r\n// to guarantee the first \"leading digits pattern\" for a phone number format\r\n// to be preemptive.\r\nconst MIN_LEADING_DIGITS_LENGTH = 3\r\n\r\nexport default class AsYouTypeFormatter {\r\n\tconstructor({\r\n\t\tstate,\r\n\t\tmetadata\r\n\t}) {\r\n\t\tthis.metadata = metadata\r\n\t\tthis.resetFormat()\r\n\t}\r\n\r\n\tresetFormat() {\r\n\t\tthis.chosenFormat = undefined\r\n\t\tthis.template = undefined\r\n\t\tthis.nationalNumberTemplate = undefined\r\n\t\tthis.populatedNationalNumberTemplate = undefined\r\n\t\tthis.populatedNationalNumberTemplatePosition = -1\r\n\t}\r\n\r\n\treset(numberingPlan, state) {\r\n\t\tthis.resetFormat()\r\n\t\tif (numberingPlan) {\r\n\t\t\tthis.isNANP = numberingPlan.callingCode() === '1'\r\n\t\t\tthis.matchingFormats = numberingPlan.formats()\r\n\t\t\tif (state.nationalSignificantNumber) {\r\n\t\t\t\tthis.narrowDownMatchingFormats(state)\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tthis.isNANP = undefined\r\n\t\t\tthis.matchingFormats = []\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Formats an updated phone number.\r\n\t * @param  {string} nextDigits — Additional phone number digits.\r\n\t * @param  {object} state — `AsYouType` state.\r\n\t * @return {[string]} Returns undefined if the updated phone number can't be formatted using any of the available formats.\r\n\t */\r\n\tformat(nextDigits, state) {\r\n\t\t// See if the phone number digits can be formatted as a complete phone number.\r\n\t\t// If not, use the results from `formatNationalNumberWithNextDigits()`,\r\n\t\t// which formats based on the chosen formatting pattern.\r\n\t\t//\r\n\t\t// Attempting to format complete phone number first is how it's done\r\n\t\t// in Google's `libphonenumber`, so this library just follows it.\r\n\t\t// Google's `libphonenumber` code doesn't explain in detail why does it\r\n\t\t// attempt to format digits as a complete phone number\r\n\t\t// instead of just going with a previoulsy (or newly) chosen `format`:\r\n\t\t//\r\n\t\t// \"Checks to see if there is an exact pattern match for these digits.\r\n\t\t//  If so, we should use this instead of any other formatting template\r\n\t\t//  whose leadingDigitsPattern also matches the input.\"\r\n\t\t//\r\n\t\tif (canFormatCompleteNumber(state.nationalSignificantNumber, state.country, this.metadata)) {\r\n\t\t\tfor (const format of this.matchingFormats) {\r\n\t\t\t\tconst formattedCompleteNumber = formatCompleteNumber(\r\n\t\t\t\t\tstate,\r\n\t\t\t\t\tformat,\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tmetadata: this.metadata,\r\n\t\t\t\t\t\tshouldTryNationalPrefixFormattingRule: (format) => this.shouldTryNationalPrefixFormattingRule(format, {\r\n\t\t\t\t\t\t\tinternational: state.international,\r\n\t\t\t\t\t\t\tnationalPrefix: state.nationalPrefix\r\n\t\t\t\t\t\t}),\r\n\t\t\t\t\t\tgetSeparatorAfterNationalPrefix: (format) => this.getSeparatorAfterNationalPrefix(format)\r\n\t\t\t\t\t}\r\n\t\t\t\t)\r\n\t\t\t\tif (formattedCompleteNumber) {\r\n\t\t\t\t\tthis.resetFormat()\r\n\t\t\t\t\tthis.chosenFormat = format\r\n\t\t\t\t\tthis.setNationalNumberTemplate(formattedCompleteNumber.replace(/\\d/g, DIGIT_PLACEHOLDER), state)\r\n\t\t\t\t\tthis.populatedNationalNumberTemplate = formattedCompleteNumber\r\n\t\t\t\t\t// With a new formatting template, the matched position\r\n\t\t\t\t\t// using the old template needs to be reset.\r\n\t\t\t\t\tthis.populatedNationalNumberTemplatePosition = this.template.lastIndexOf(DIGIT_PLACEHOLDER)\r\n\t\t\t\t\treturn formattedCompleteNumber\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t}\r\n\t\t// Format the digits as a partial (incomplete) phone number\r\n\t\t// using the previously chosen formatting pattern (or a newly chosen one).\r\n\t\treturn this.formatNationalNumberWithNextDigits(nextDigits, state)\r\n\t}\r\n\r\n\t// Formats the next phone number digits.\r\n\tformatNationalNumberWithNextDigits(nextDigits, state) {\r\n\t\tconst previouslyChosenFormat = this.chosenFormat\r\n\r\n\t\t// Choose a format from the list of matching ones.\r\n\t\tconst newlyChosenFormat = this.chooseFormat(state)\r\n\r\n\t\tif (newlyChosenFormat) {\r\n\t\t\tif (newlyChosenFormat === previouslyChosenFormat) {\r\n\t\t\t\t// If it can format the next (current) digits\r\n\t\t\t\t// using the previously chosen phone number format\r\n\t\t\t\t// then return the updated formatted number.\r\n\t\t\t\treturn this.formatNextNationalNumberDigits(nextDigits)\r\n\t\t\t} else {\r\n\t\t\t\t// If a more appropriate phone number format\r\n\t\t\t\t// has been chosen for these \"leading digits\",\r\n\t\t\t\t// then re-format the national phone number part\r\n\t\t\t\t// using the newly selected format.\r\n\t\t\t\treturn this.formatNextNationalNumberDigits(state.getNationalDigits())\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tnarrowDownMatchingFormats({\r\n\t\tnationalSignificantNumber,\r\n\t\tnationalPrefix,\r\n\t\tinternational\r\n\t}) {\r\n\t\tconst leadingDigits = nationalSignificantNumber\r\n\r\n\t\t// \"leading digits\" pattern list starts with a\r\n\t\t// \"leading digits\" pattern fitting a maximum of 3 leading digits.\r\n\t\t// So, after a user inputs 3 digits of a national (significant) phone number\r\n\t\t// this national (significant) number can already be formatted.\r\n\t\t// The next \"leading digits\" pattern is for 4 leading digits max,\r\n\t\t// and the \"leading digits\" pattern after it is for 5 leading digits max, etc.\r\n\r\n\t\t// This implementation is different from Google's\r\n\t\t// in that it searches for a fitting format\r\n\t\t// even if the user has entered less than\r\n\t\t// `MIN_LEADING_DIGITS_LENGTH` digits of a national number.\r\n\t\t// Because some leading digit patterns already match for a single first digit.\r\n\t\tlet leadingDigitsPatternIndex = leadingDigits.length - MIN_LEADING_DIGITS_LENGTH\r\n\t\tif (leadingDigitsPatternIndex < 0) {\r\n\t\t\tleadingDigitsPatternIndex = 0\r\n\t\t}\r\n\r\n\t\tthis.matchingFormats = this.matchingFormats.filter(\r\n\t\t\tformat => this.formatSuits(format, international, nationalPrefix)\r\n\t\t\t\t&& this.formatMatches(format, leadingDigits, leadingDigitsPatternIndex)\r\n\t\t)\r\n\r\n\t\t// If there was a phone number format chosen\r\n\t\t// and it no longer holds given the new leading digits then reset it.\r\n\t\t// The test for this `if` condition is marked as:\r\n\t\t// \"Reset a chosen format when it no longer holds given the new leading digits\".\r\n\t\t// To construct a valid test case for this one can find a country\r\n\t\t// in `PhoneNumberMetadata.xml` yielding one format for 3 `<leadingDigits>`\r\n\t\t// and yielding another format for 4 `<leadingDigits>` (Australia in this case).\r\n\t\tif (this.chosenFormat && this.matchingFormats.indexOf(this.chosenFormat) === -1) {\r\n\t\t\tthis.resetFormat()\r\n\t\t}\r\n\t}\r\n\r\n\tformatSuits(format, international, nationalPrefix) {\r\n\t\t// When a prefix before a national (significant) number is\r\n\t\t// simply a national prefix, then it's parsed as `this.nationalPrefix`.\r\n\t\t// In more complex cases, a prefix before national (significant) number\r\n\t\t// could include a national prefix as well as some \"capturing groups\",\r\n\t\t// and in that case there's no info whether a national prefix has been parsed.\r\n\t\t// If national prefix is not used when formatting a phone number\r\n\t\t// using this format, but a national prefix has been entered by the user,\r\n\t\t// and was extracted, then discard such phone number format.\r\n\t\t// In Google's \"AsYouType\" formatter code, the equivalent would be this part:\r\n\t\t// https://github.com/google/libphonenumber/blob/0a45cfd96e71cad8edb0e162a70fcc8bd9728933/java/libphonenumber/src/com/google/i18n/phonenumbers/AsYouTypeFormatter.java#L175-L184\r\n\t\tif (nationalPrefix &&\r\n\t\t\t!format.usesNationalPrefix() &&\r\n\t\t\t// !format.domesticCarrierCodeFormattingRule() &&\r\n\t\t\t!format.nationalPrefixIsOptionalWhenFormattingInNationalFormat()) {\r\n\t\t\treturn false\r\n\t\t}\r\n\t\t// If national prefix is mandatory for this phone number format\r\n\t\t// and there're no guarantees that a national prefix is present in user input\r\n\t\t// then discard this phone number format as not suitable.\r\n\t\t// In Google's \"AsYouType\" formatter code, the equivalent would be this part:\r\n\t\t// https://github.com/google/libphonenumber/blob/0a45cfd96e71cad8edb0e162a70fcc8bd9728933/java/libphonenumber/src/com/google/i18n/phonenumbers/AsYouTypeFormatter.java#L185-L193\r\n\t\tif (!international &&\r\n\t\t\t!nationalPrefix &&\r\n\t\t\tformat.nationalPrefixIsMandatoryWhenFormattingInNationalFormat()) {\r\n\t\t\treturn false\r\n\t\t}\r\n\t\treturn true\r\n\t}\r\n\r\n\tformatMatches(format, leadingDigits, leadingDigitsPatternIndex) {\r\n\t\tconst leadingDigitsPatternsCount = format.leadingDigitsPatterns().length\r\n\r\n\t\t// If this format is not restricted to a certain\r\n\t\t// leading digits pattern then it fits.\r\n\t\t// The test case could be found by searching for \"leadingDigitsPatternsCount === 0\".\r\n\t\tif (leadingDigitsPatternsCount === 0) {\r\n\t\t\treturn true\r\n\t\t}\r\n\r\n\t\t// Start narrowing down the list of possible formats based on the leading digits.\r\n\t\t// (only previously matched formats take part in the narrowing down process)\r\n\r\n\t\t// `leading_digits_patterns` start with 3 digits min\r\n\t\t// and then go up from there one digit at a time.\r\n\t\tleadingDigitsPatternIndex = Math.min(leadingDigitsPatternIndex, leadingDigitsPatternsCount - 1)\r\n\t\tconst leadingDigitsPattern = format.leadingDigitsPatterns()[leadingDigitsPatternIndex]\r\n\r\n\t\t// Google imposes a requirement on the leading digits\r\n\t\t// to be minimum 3 digits long in order to be eligible\r\n\t\t// for checking those with a leading digits pattern.\r\n\t\t//\r\n\t\t// Since `leading_digits_patterns` start with 3 digits min,\r\n\t\t// Google's original `libphonenumber` library only starts\r\n\t\t// excluding any non-matching formats only when the\r\n\t\t// national number entered so far is at least 3 digits long,\r\n\t\t// otherwise format matching would give false negatives.\r\n\t\t//\r\n\t\t// For example, when the digits entered so far are `2`\r\n\t\t// and the leading digits pattern is `21` –\r\n\t\t// it's quite obvious in this case that the format could be the one\r\n\t\t// but due to the absence of further digits it would give false negative.\r\n\t\t//\r\n\t\t// Also, `leading_digits_patterns` doesn't always correspond to a single\r\n\t\t// digits count. For example, `60|8` pattern would already match `8`\r\n\t\t// but the `60` part would require having at least two leading digits,\r\n\t\t// so the whole pattern would require inputting two digits first in order to\r\n\t\t// decide on whether it matches the input, even when the input is \"80\".\r\n\t\t//\r\n\t\t// This library — `libphonenumber-js` — allows filtering by `leading_digits_patterns`\r\n\t\t// even when there's only 1 or 2 digits of the national (significant) number.\r\n\t\t// To do that, it uses a non-strict pattern matcher written specifically for that.\r\n\t\t//\r\n\t\tif (leadingDigits.length < MIN_LEADING_DIGITS_LENGTH) {\r\n\t\t\t// Before leading digits < 3 matching was implemented:\r\n\t\t\t// return true\r\n\t\t\t//\r\n\t\t\t// After leading digits < 3 matching was implemented:\r\n\t\t\ttry {\r\n\t\t\t\treturn new PatternMatcher(leadingDigitsPattern).match(leadingDigits, { allowOverflow: true }) !== undefined\r\n\t\t\t} catch (error) /* istanbul ignore next */ {\r\n\t\t\t\t// There's a slight possibility that there could be some undiscovered bug\r\n\t\t\t\t// in the pattern matcher code. Since the \"leading digits < 3 matching\"\r\n\t\t\t\t// feature is not \"essential\" for operation, it can fall back to the old way\r\n\t\t\t\t// in case of any issues rather than halting the application's execution.\r\n\t\t\t\tconsole.error(error)\r\n\t\t\t\treturn true\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// If at least `MIN_LEADING_DIGITS_LENGTH` digits of a national number are\r\n\t\t// available then use the usual regular expression matching.\r\n\t\t//\r\n\t\t// The whole pattern is wrapped in round brackets (`()`) because\r\n\t\t// the pattern can use \"or\" operator (`|`) at the top level of the pattern.\r\n\t\t//\r\n\t\treturn new RegExp(`^(${leadingDigitsPattern})`).test(leadingDigits)\r\n\t}\r\n\r\n\tgetFormatFormat(format, international) {\r\n\t\treturn international ? format.internationalFormat() : format.format()\r\n\t}\r\n\r\n\tchooseFormat(state) {\r\n\t\t// When there are multiple available formats, the formatter uses the first\r\n\t\t// format where a formatting template could be created.\r\n\t\t//\r\n\t\t// For some weird reason, `istanbul` says \"else path not taken\"\r\n\t\t// for the `for of` line below. Supposedly that means that\r\n\t\t// the loop doesn't ever go over the last element in the list.\r\n\t\t// That's true because there always is `this.chosenFormat`\r\n\t\t// when `this.matchingFormats` is non-empty.\r\n\t\t// And, for some weird reason, it doesn't think that the case\r\n\t\t// with empty `this.matchingFormats` qualifies for a valid \"else\" path.\r\n\t\t// So simply muting this `istanbul` warning.\r\n\t\t// It doesn't skip the contents of the `for of` loop,\r\n\t\t// it just skips the `for of` line.\r\n\t\t//\r\n\t\t/* istanbul ignore next */\r\n\t\tfor (const format of this.matchingFormats.slice()) {\r\n\t\t\t// If this format is currently being used\r\n\t\t\t// and is still suitable, then stick to it.\r\n\t\t\tif (this.chosenFormat === format) {\r\n\t\t\t\tbreak\r\n\t\t\t}\r\n\t\t\t// Sometimes, a formatting rule inserts additional digits in a phone number,\r\n\t\t\t// and \"as you type\" formatter can't do that: it should only use the digits\r\n\t\t\t// that the user has input.\r\n\t\t\t//\r\n\t\t\t// For example, in Argentina, there's a format for mobile phone numbers:\r\n\t\t\t//\r\n\t\t\t// {\r\n\t\t\t//    \"pattern\": \"(\\\\d)(\\\\d{2})(\\\\d{4})(\\\\d{4})\",\r\n\t\t\t//    \"leading_digits_patterns\": [\"91\"],\r\n\t\t\t//    \"national_prefix_formatting_rule\": \"0$1\",\r\n\t\t\t//    \"format\": \"$2 15-$3-$4\",\r\n\t\t\t//    \"international_format\": \"$1 $2 $3-$4\"\r\n\t\t\t// }\r\n\t\t\t//\r\n\t\t\t// In that format, `international_format` is used instead of `format`\r\n\t\t\t// because `format` inserts `15` in the formatted number,\r\n\t\t\t// and `AsYouType` formatter should only use the digits\r\n\t\t\t// the user has actually input, without adding any extra digits.\r\n\t\t\t// In this case, it wouldn't make a difference, because the `15`\r\n\t\t\t// is first stripped when applying `national_prefix_for_parsing`\r\n\t\t\t// and then re-added when using `format`, so in reality it doesn't\r\n\t\t\t// add any new digits to the number, but to detect that, the code\r\n\t\t\t// would have to be more complex: it would have to try formatting\r\n\t\t\t// the digits using the format and then see if any digits have\r\n\t\t\t// actually been added or removed, and then, every time a new digit\r\n\t\t\t// is input, it should re-check whether the chosen format doesn't\r\n\t\t\t// alter the digits.\r\n\t\t\t//\r\n\t\t\t// Google's code doesn't go that far, and so does this library:\r\n\t\t\t// it simply requires that a `format` doesn't add any additonal\r\n\t\t\t// digits to user's input.\r\n\t\t\t//\r\n\t\t\t// Also, people in general should move from inputting phone numbers\r\n\t\t\t// in national format (possibly with national prefixes)\r\n\t\t\t// and use international phone number format instead:\r\n\t\t\t// it's a logical thing in the modern age of mobile phones,\r\n\t\t\t// globalization and the internet.\r\n\t\t\t//\r\n\t\t\t/* istanbul ignore if */\r\n\t\t\tif (!NON_ALTERING_FORMAT_REG_EXP.test(this.getFormatFormat(format, state.international))) {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\t\t\tif (!this.createTemplateForFormat(format, state)) {\r\n\t\t\t\t// Remove the format if it can't generate a template.\r\n\t\t\t\tthis.matchingFormats = this.matchingFormats.filter(_ => _ !== format)\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\t\t\tthis.chosenFormat = format\r\n\t\t\tbreak\r\n\t\t}\r\n\t\tif (!this.chosenFormat) {\r\n\t\t\t// No format matches the national (significant) phone number.\r\n\t\t\tthis.resetFormat()\r\n\t\t}\r\n\t\treturn this.chosenFormat\r\n\t}\r\n\r\n\tcreateTemplateForFormat(format, state) {\r\n\t\t// The formatter doesn't format numbers when numberPattern contains '|', e.g.\r\n\t\t// (20|3)\\d{4}. In those cases we quickly return.\r\n\t\t// (Though there's no such format in current metadata)\r\n\t\t/* istanbul ignore if */\r\n\t\tif (SUPPORT_LEGACY_FORMATTING_PATTERNS && format.pattern().indexOf('|') >= 0) {\r\n\t\t\treturn\r\n\t\t}\r\n\t\t// Get formatting template for this phone number format\r\n\t\tconst template = this.getTemplateForFormat(format, state)\r\n\t\t// If the national number entered is too long\r\n\t\t// for any phone number format, then abort.\r\n\t\tif (template) {\r\n\t\t\tthis.setNationalNumberTemplate(template, state)\r\n\t\t\treturn true\r\n\t\t}\r\n\t}\r\n\r\n\tgetSeparatorAfterNationalPrefix(format) {\r\n\t\t// `US` metadata doesn't have a `national_prefix_formatting_rule`,\r\n\t\t// so the `if` condition below doesn't apply to `US`,\r\n\t\t// but in reality there shoudl be a separator\r\n\t\t// between a national prefix and a national (significant) number.\r\n\t\t// So `US` national prefix separator is a \"special\" \"hardcoded\" case.\r\n\t\tif (this.isNANP) {\r\n\t\t\treturn ' '\r\n\t\t}\r\n\t\t// If a `format` has a `national_prefix_formatting_rule`\r\n\t\t// and that rule has a separator after a national prefix,\r\n\t\t// then it means that there should be a separator\r\n\t\t// between a national prefix and a national (significant) number.\r\n\t\tif (format &&\r\n\t\t\tformat.nationalPrefixFormattingRule() &&\r\n\t\t\tNATIONAL_PREFIX_SEPARATORS_PATTERN.test(format.nationalPrefixFormattingRule())) {\r\n\t\t\treturn ' '\r\n\t\t}\r\n\t\t// At this point, there seems to be no clear evidence that\r\n\t\t// there should be a separator between a national prefix\r\n\t\t// and a national (significant) number. So don't insert one.\r\n\t\treturn ''\r\n\t}\r\n\r\n\tgetInternationalPrefixBeforeCountryCallingCode({ IDDPrefix, missingPlus }, options) {\r\n\t\tif (IDDPrefix) {\r\n\t\t\treturn options && options.spacing === false ? IDDPrefix : IDDPrefix + ' '\r\n\t\t}\r\n\t\tif (missingPlus) {\r\n\t\t\treturn ''\r\n\t\t}\r\n\t\treturn '+'\r\n\t}\r\n\r\n\tgetTemplate(state) {\r\n\t\tif (!this.template) {\r\n\t\t\treturn\r\n\t\t}\r\n\t\t// `this.template` holds the template for a \"complete\" phone number.\r\n\t\t// The currently entered phone number is most likely not \"complete\",\r\n\t\t// so trim all non-populated digits.\r\n\t\tlet index = -1\r\n\t\tlet i = 0\r\n\t\tconst internationalPrefix = state.international ? this.getInternationalPrefixBeforeCountryCallingCode(state, { spacing: false }) : ''\r\n\t\twhile (i < internationalPrefix.length + state.getDigitsWithoutInternationalPrefix().length) {\r\n\t\t\tindex = this.template.indexOf(DIGIT_PLACEHOLDER, index + 1)\r\n\t\t\ti++\r\n\t\t}\r\n\t\treturn cutAndStripNonPairedParens(this.template, index + 1)\r\n\t}\r\n\r\n\tsetNationalNumberTemplate(template, state) {\r\n\t\tthis.nationalNumberTemplate = template\r\n\t\tthis.populatedNationalNumberTemplate = template\r\n\t\t// With a new formatting template, the matched position\r\n\t\t// using the old template needs to be reset.\r\n\t\tthis.populatedNationalNumberTemplatePosition = -1\r\n\t\t// For convenience, the public `.template` property\r\n\t\t// contains the whole international number\r\n\t\t// if the phone number being input is international:\r\n\t\t// 'x' for the '+' sign, 'x'es for the country phone code,\r\n\t\t// a spacebar and then the template for the formatted national number.\r\n\t\tif (state.international) {\r\n\t\t\tthis.template =\r\n\t\t\t\tthis.getInternationalPrefixBeforeCountryCallingCode(state).replace(/[\\d\\+]/g, DIGIT_PLACEHOLDER) +\r\n\t\t\t\trepeat(DIGIT_PLACEHOLDER, state.callingCode.length) +\r\n\t\t\t\t' ' +\r\n\t\t\t\ttemplate\r\n\t\t} else {\r\n\t\t\tthis.template = template\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Generates formatting template for a national phone number,\r\n\t * optionally containing a national prefix, for a format.\r\n\t * @param  {Format} format\r\n\t * @param  {string} nationalPrefix\r\n\t * @return {string}\r\n\t */\r\n\tgetTemplateForFormat(format, {\r\n\t\tnationalSignificantNumber,\r\n\t\tinternational,\r\n\t\tnationalPrefix,\r\n\t\tprefixBeforeNationalSignificantNumberThatIsNotNationalPrefix\r\n\t}) {\r\n\t\tlet pattern = format.pattern()\r\n\r\n\t\t/* istanbul ignore else */\r\n\t\tif (SUPPORT_LEGACY_FORMATTING_PATTERNS) {\r\n\t\t\tpattern = pattern\r\n\t\t\t\t// Replace anything in the form of [..] with \\d\r\n\t\t\t\t.replace(CREATE_CHARACTER_CLASS_PATTERN(), '\\\\d')\r\n\t\t\t\t// Replace any standalone digit (not the one in `{}`) with \\d\r\n\t\t\t\t.replace(CREATE_STANDALONE_DIGIT_PATTERN(), '\\\\d')\r\n\t\t}\r\n\r\n\t\t// Generate a dummy national number (consisting of `9`s)\r\n\t\t// that fits this format's `pattern`.\r\n\t\t//\r\n\t\t// This match will always succeed,\r\n\t\t// because the \"longest dummy phone number\"\r\n\t\t// has enough length to accomodate any possible\r\n\t\t// national phone number format pattern.\r\n\t\t//\r\n\t\tlet digits = LONGEST_DUMMY_PHONE_NUMBER.match(pattern)[0]\r\n\r\n\t\t// If the national number entered is too long\r\n\t\t// for any phone number format, then abort.\r\n\t\tif (nationalSignificantNumber.length > digits.length) {\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\t// Get a formatting template which can be used to efficiently format\r\n\t\t// a partial number where digits are added one by one.\r\n\r\n\t\t// Below `strictPattern` is used for the\r\n\t\t// regular expression (with `^` and `$`).\r\n\t\t// This wasn't originally in Google's `libphonenumber`\r\n\t\t// and I guess they don't really need it\r\n\t\t// because they're not using \"templates\" to format phone numbers\r\n\t\t// but I added `strictPattern` after encountering\r\n\t\t// South Korean phone number formatting bug.\r\n\t\t//\r\n\t\t// Non-strict regular expression bug demonstration:\r\n\t\t//\r\n\t\t// this.nationalSignificantNumber : `111111111` (9 digits)\r\n\t\t//\r\n\t\t// pattern : (\\d{2})(\\d{3,4})(\\d{4})\r\n\t\t// format : `$1 $2 $3`\r\n\t\t// digits : `9999999999` (10 digits)\r\n\t\t//\r\n\t\t// '9999999999'.replace(new RegExp(/(\\d{2})(\\d{3,4})(\\d{4})/g), '$1 $2 $3') = \"99 9999 9999\"\r\n\t\t//\r\n\t\t// template : xx xxxx xxxx\r\n\t\t//\r\n\t\t// But the correct template in this case is `xx xxx xxxx`.\r\n\t\t// The template was generated incorrectly because of the\r\n\t\t// `{3,4}` variability in the `pattern`.\r\n\t\t//\r\n\t\t// The fix is, if `this.nationalSignificantNumber` has already sufficient length\r\n\t\t// to satisfy the `pattern` completely then `this.nationalSignificantNumber`\r\n\t\t// is used instead of `digits`.\r\n\r\n\t\tconst strictPattern = new RegExp('^' + pattern + '$')\r\n\t\tconst nationalNumberDummyDigits = nationalSignificantNumber.replace(/\\d/g, DUMMY_DIGIT)\r\n\r\n\t\t// If `this.nationalSignificantNumber` has already sufficient length\r\n\t\t// to satisfy the `pattern` completely then use it\r\n\t\t// instead of `digits`.\r\n\t\tif (strictPattern.test(nationalNumberDummyDigits)) {\r\n\t\t\tdigits = nationalNumberDummyDigits\r\n\t\t}\r\n\r\n\t\tlet numberFormat = this.getFormatFormat(format, international)\r\n\t\tlet nationalPrefixIncludedInTemplate\r\n\r\n\t\t// If a user did input a national prefix (and that's guaranteed),\r\n\t\t// and if a `format` does have a national prefix formatting rule,\r\n\t\t// then see if that national prefix formatting rule\r\n\t\t// prepends exactly the same national prefix the user has input.\r\n\t\t// If that's the case, then use the `format` with the national prefix formatting rule.\r\n\t\t// Otherwise, use  the `format` without the national prefix formatting rule,\r\n\t\t// and prepend a national prefix manually to it.\r\n\t\tif (this.shouldTryNationalPrefixFormattingRule(format, { international, nationalPrefix })) {\r\n\t\t\tconst numberFormatWithNationalPrefix = numberFormat.replace(\r\n\t\t\t\tFIRST_GROUP_PATTERN,\r\n\t\t\t\tformat.nationalPrefixFormattingRule()\r\n\t\t\t)\r\n\t\t\t// If `national_prefix_formatting_rule` of a `format` simply prepends\r\n\t\t\t// national prefix at the start of a national (significant) number,\r\n\t\t\t// then such formatting can be used with `AsYouType` formatter.\r\n\t\t\t// There seems to be no `else` case: everywhere in metadata,\r\n\t\t\t// national prefix formatting rule is national prefix + $1,\r\n\t\t\t// or `($1)`, in which case such format isn't even considered\r\n\t\t\t// when the user has input a national prefix.\r\n\t\t\t/* istanbul ignore else */\r\n\t\t\tif (parseDigits(format.nationalPrefixFormattingRule()) === (nationalPrefix || '') + parseDigits('$1')) {\r\n\t\t\t\tnumberFormat = numberFormatWithNationalPrefix\r\n\t\t\t\tnationalPrefixIncludedInTemplate = true\r\n\t\t\t\t// Replace all digits of the national prefix in the formatting template\r\n\t\t\t\t// with `DIGIT_PLACEHOLDER`s.\r\n\t\t\t\tif (nationalPrefix) {\r\n\t\t\t\t\tlet i = nationalPrefix.length\r\n\t\t\t\t\twhile (i > 0) {\r\n\t\t\t\t\t\tnumberFormat = numberFormat.replace(/\\d/, DIGIT_PLACEHOLDER)\r\n\t\t\t\t\t\ti--\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Generate formatting template for this phone number format.\r\n\t\tlet template = digits\r\n\t\t\t// Format the dummy phone number according to the format.\r\n\t\t\t.replace(new RegExp(pattern), numberFormat)\r\n\t\t\t// Replace each dummy digit with a DIGIT_PLACEHOLDER.\r\n\t\t\t.replace(new RegExp(DUMMY_DIGIT, 'g'), DIGIT_PLACEHOLDER)\r\n\r\n\t\t// If a prefix of a national (significant) number is not as simple\r\n\t\t// as just a basic national prefix, then just prepend such prefix\r\n\t\t// before the national (significant) number, optionally spacing\r\n\t\t// the two with a whitespace.\r\n\t\tif (!nationalPrefixIncludedInTemplate) {\r\n\t\t\tif (prefixBeforeNationalSignificantNumberThatIsNotNationalPrefix) {\r\n\t\t\t\t// Prepend the prefix to the template manually.\r\n\t\t\t\ttemplate = repeat(DIGIT_PLACEHOLDER, prefixBeforeNationalSignificantNumberThatIsNotNationalPrefix.length) +\r\n\t\t\t\t\t' ' +\r\n\t\t\t\t\ttemplate\r\n\t\t\t} else if (nationalPrefix) {\r\n\t\t\t\t// Prepend national prefix to the template manually.\r\n\t\t\t\ttemplate = repeat(DIGIT_PLACEHOLDER, nationalPrefix.length) +\r\n\t\t\t\t\tthis.getSeparatorAfterNationalPrefix(format) +\r\n\t\t\t\t\ttemplate\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (international) {\r\n\t\t\ttemplate = applyInternationalSeparatorStyle(template)\r\n\t\t}\r\n\r\n\t\treturn template\r\n\t}\r\n\r\n\tformatNextNationalNumberDigits(digits) {\r\n\t\tconst result = populateTemplateWithDigits(\r\n\t\t\tthis.populatedNationalNumberTemplate,\r\n\t\t\tthis.populatedNationalNumberTemplatePosition,\r\n\t\t\tdigits\r\n\t\t)\r\n\r\n\t\tif (!result) {\r\n\t\t\t// Reset the format.\r\n\t\t\tthis.resetFormat()\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tthis.populatedNationalNumberTemplate = result[0]\r\n\t\tthis.populatedNationalNumberTemplatePosition = result[1]\r\n\r\n\t\t// Return the formatted phone number so far.\r\n\t\treturn cutAndStripNonPairedParens(this.populatedNationalNumberTemplate, this.populatedNationalNumberTemplatePosition + 1)\r\n\r\n\t\t// The old way which was good for `input-format` but is not so good\r\n\t\t// for `react-phone-number-input`'s default input (`InputBasic`).\r\n\t\t// return closeNonPairedParens(this.populatedNationalNumberTemplate, this.populatedNationalNumberTemplatePosition + 1)\r\n\t\t// \t.replace(new RegExp(DIGIT_PLACEHOLDER, 'g'), ' ')\r\n\t}\r\n\r\n\tshouldTryNationalPrefixFormattingRule(format, { international, nationalPrefix }) {\r\n\t\tif (format.nationalPrefixFormattingRule()) {\r\n\t\t\t// In some countries, `national_prefix_formatting_rule` is `($1)`,\r\n\t\t\t// so it applies even if the user hasn't input a national prefix.\r\n\t\t\t// `format.usesNationalPrefix()` detects such cases.\r\n\t\t\tconst usesNationalPrefix = format.usesNationalPrefix()\r\n\t\t\tif ((usesNationalPrefix && nationalPrefix) ||\r\n\t\t\t\t(!usesNationalPrefix && !international)) {\r\n\t\t\t\treturn true\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}","import PatternParser from './AsYouTypeFormatter.PatternParser.js'\r\n\r\nexport default class PatternMatcher {\r\n\tconstructor(pattern) {\r\n\t\tthis.matchTree = new PatternParser().parse(pattern)\r\n\t}\r\n\r\n\tmatch(string, { allowOverflow } = {}) {\r\n\t\tif (!string) {\r\n\t\t\tthrow new Error('String is required')\r\n\t\t}\r\n\t\tconst result = match(string.split(''), this.matchTree, true)\r\n\t\tif (result && result.match) {\r\n\t\t\tdelete result.matchedChars\r\n\t\t}\r\n\t\tif (result && result.overflow) {\r\n\t\t\tif (!allowOverflow) {\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result\r\n\t}\r\n}\r\n\r\n/**\r\n * Matches `characters` against a pattern compiled into a `tree`.\r\n * @param  {string[]} characters\r\n * @param  {Tree} tree — A pattern compiled into a `tree`. See the `*.d.ts` file for the description of the `tree` structure.\r\n * @param  {boolean} last — Whether it's the last (rightmost) subtree on its level of the match tree.\r\n * @return {object} See the `*.d.ts` file for the description of the result object.\r\n */\r\nfunction match(characters, tree, last) {\r\n\t// If `tree` is a string, then `tree` is a single character.\r\n\t// That's because when a pattern is parsed, multi-character-string parts\r\n\t// of a pattern are compiled into arrays of single characters.\r\n\t// I still wrote this piece of code for a \"general\" hypothetical case\r\n\t// when `tree` could be a string of several characters, even though\r\n\t// such case is not possible with the current implementation.\r\n\tif (typeof tree === 'string') {\r\n\t\tconst characterString = characters.join('')\r\n\t\tif (tree.indexOf(characterString) === 0) {\r\n\t\t\t// `tree` is always a single character.\r\n\t\t\t// If `tree.indexOf(characterString) === 0`\r\n\t\t\t// then `characters.length === tree.length`.\r\n\t\t\t/* istanbul ignore else */\r\n\t\t\tif (characters.length === tree.length) {\r\n\t\t\t\treturn {\r\n\t\t\t\t\tmatch: true,\r\n\t\t\t\t\tmatchedChars: characters\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// `tree` is always a single character.\r\n\t\t\t// If `tree.indexOf(characterString) === 0`\r\n\t\t\t// then `characters.length === tree.length`.\r\n\t\t\t/* istanbul ignore next */\r\n\t\t\treturn {\r\n\t\t\t\tpartialMatch: true,\r\n\t\t\t\t// matchedChars: characters\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (characterString.indexOf(tree) === 0) {\r\n\t\t\tif (last) {\r\n\t\t\t\t// The `else` path is not possible because `tree` is always a single character.\r\n\t\t\t\t// The `else` case for `characters.length > tree.length` would be\r\n\t\t\t\t// `characters.length <= tree.length` which means `characters.length <= 1`.\r\n\t\t\t\t// `characters` array can't be empty, so that means `characters === [tree]`,\r\n\t\t\t\t// which would also mean `tree.indexOf(characterString) === 0` and that'd mean\r\n\t\t\t\t// that the `if (tree.indexOf(characterString) === 0)` condition before this\r\n\t\t\t\t// `if` condition would be entered, and returned from there, not reaching this code.\r\n\t\t\t\t/* istanbul ignore else */\r\n\t\t\t\tif (characters.length > tree.length) {\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\toverflow: true\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn {\r\n\t\t\t\tmatch: true,\r\n\t\t\t\tmatchedChars: characters.slice(0, tree.length)\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn\r\n\t}\r\n\r\n\tif (Array.isArray(tree)) {\r\n\t\tlet restCharacters = characters.slice()\r\n\t\tlet i = 0\r\n\t\twhile (i < tree.length) {\r\n\t\t\tconst subtree = tree[i]\r\n\t\t\tconst result = match(restCharacters, subtree, last && (i === tree.length - 1))\r\n\t\t\tif (!result) {\r\n\t\t\t\treturn\r\n\t\t\t} else if (result.overflow) {\r\n\t\t\t\treturn result\r\n\t\t\t} else if (result.match) {\r\n\t\t\t\t// Continue with the next subtree with the rest of the characters.\r\n\t\t\t\trestCharacters = restCharacters.slice(result.matchedChars.length)\r\n\t\t\t\tif (restCharacters.length === 0) {\r\n\t\t\t\t\tif (i === tree.length - 1) {\r\n\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\tmatch: true,\r\n\t\t\t\t\t\t\tmatchedChars: characters\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\tpartialMatch: true,\r\n\t\t\t\t\t\t\t// matchedChars: characters\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\t/* istanbul ignore else */\r\n\t\t\t\tif (result.partialMatch) {\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\tpartialMatch: true,\r\n\t\t\t\t\t\t// matchedChars: characters\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthrow new Error(`Unsupported match result:\\n${JSON.stringify(result, null, 2)}`)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\ti++\r\n\t\t}\r\n\t\t// If `last` then overflow has already been checked\r\n\t\t// by the last element of the `tree` array.\r\n\t\t/* istanbul ignore if */\r\n\t\tif (last) {\r\n\t\t\treturn {\r\n\t\t\t\toverflow: true\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn {\r\n\t\t\tmatch: true,\r\n\t\t\tmatchedChars: characters.slice(0, characters.length - restCharacters.length)\r\n\t\t}\r\n\t}\r\n\r\n\tswitch (tree.op) {\r\n\t\tcase '|':\r\n\t\t\tlet partialMatch\r\n\t\t\tfor (const branch of tree.args) {\r\n\t\t\t\tconst result = match(characters, branch, last)\r\n\t\t\t\tif (result) {\r\n\t\t\t\t\tif (result.overflow) {\r\n\t\t\t\t\t\treturn result\r\n\t\t\t\t\t} else if (result.match) {\r\n\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\tmatch: true,\r\n\t\t\t\t\t\t\tmatchedChars: result.matchedChars\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t/* istanbul ignore else */\r\n\t\t\t\t\t\tif (result.partialMatch) {\r\n\t\t\t\t\t\t\tpartialMatch = true\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tthrow new Error(`Unsupported match result:\\n${JSON.stringify(result, null, 2)}`)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (partialMatch) {\r\n\t\t\t\treturn {\r\n\t\t\t\t\tpartialMatch: true,\r\n\t\t\t\t\t// matchedChars: ...\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// Not even a partial match.\r\n\t\t\treturn\r\n\r\n\t\tcase '[]':\r\n\t\t\tfor (const char of tree.args) {\r\n\t\t\t\tif (characters[0] === char) {\r\n\t\t\t\t\tif (characters.length === 1) {\r\n\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\tmatch: true,\r\n\t\t\t\t\t\t\tmatchedChars: characters\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (last) {\r\n\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\toverflow: true\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\tmatch: true,\r\n\t\t\t\t\t\tmatchedChars: [char]\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// No character matches.\r\n\t\t\treturn\r\n\r\n\t\t/* istanbul ignore next */\r\n\t\tdefault:\r\n\t\t\tthrow new Error(`Unsupported instruction tree: ${tree}`)\r\n\t}\r\n}","import Metadata from './metadata.js'\r\nimport PhoneNumber from './PhoneNumber.js'\r\nimport AsYouTypeState from './AsYouTypeState.js'\r\nimport AsYouTypeFormatter, { DIGIT_PLACEHOLDER } from './AsYouTypeFormatter.js'\r\nimport AsYouTypeParser, { extractFormattedDigitsAndPlus } from './AsYouTypeParser.js'\r\nimport getCountryByCallingCode from './helpers/getCountryByCallingCode.js'\r\nimport getCountryByNationalNumber from './helpers/getCountryByNationalNumber.js'\r\nimport isObject from './helpers/isObject.js'\r\n\r\nconst USE_NON_GEOGRAPHIC_COUNTRY_CODE = false\r\n\r\nexport default class AsYouType {\r\n\t/**\r\n\t * @param {(string|object)?} [optionsOrDefaultCountry] - The default country used for parsing non-international phone numbers. Can also be an `options` object.\r\n\t * @param {Object} metadata\r\n\t */\r\n\tconstructor(optionsOrDefaultCountry, metadata) {\r\n\t\tthis.metadata = new Metadata(metadata)\r\n\t\tconst [defaultCountry, defaultCallingCode] = this.getCountryAndCallingCode(optionsOrDefaultCountry)\r\n\t\t// `this.defaultCountry` and `this.defaultCallingCode` aren't required to be in sync.\r\n\t\t// For example, `this.defaultCountry` could be `\"AR\"` and `this.defaultCallingCode` could be `undefined`.\r\n\t\t// So `this.defaultCountry` and `this.defaultCallingCode` are totally independent.\r\n\t\tthis.defaultCountry = defaultCountry\r\n\t\tthis.defaultCallingCode = defaultCallingCode\r\n\t\tthis.reset()\r\n\t}\r\n\r\n\tgetCountryAndCallingCode(optionsOrDefaultCountry) {\r\n\t\t// Set `defaultCountry` and `defaultCallingCode` options.\r\n\t\tlet defaultCountry\r\n\t\tlet defaultCallingCode\r\n\t\t// Turns out `null` also has type \"object\". Weird.\r\n\t\tif (optionsOrDefaultCountry) {\r\n\t\t\tif (isObject(optionsOrDefaultCountry)) {\r\n\t\t\t\tdefaultCountry = optionsOrDefaultCountry.defaultCountry\r\n\t\t\t\tdefaultCallingCode = optionsOrDefaultCountry.defaultCallingCode\r\n\t\t\t} else {\r\n\t\t\t\tdefaultCountry = optionsOrDefaultCountry\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (defaultCountry && !this.metadata.hasCountry(defaultCountry)) {\r\n\t\t\tdefaultCountry = undefined\r\n\t\t}\r\n\t\tif (defaultCallingCode) {\r\n\t\t\t/* istanbul ignore if */\r\n\t\t\tif (USE_NON_GEOGRAPHIC_COUNTRY_CODE) {\r\n\t\t\t\tif (this.metadata.isNonGeographicCallingCode(defaultCallingCode)) {\r\n\t\t\t\t\tdefaultCountry = '001'\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn [defaultCountry, defaultCallingCode]\r\n\t}\r\n\r\n\t/**\r\n\t * Inputs \"next\" phone number characters.\r\n\t * @param  {string} text\r\n\t * @return {string} Formatted phone number characters that have been input so far.\r\n\t */\r\n\tinput(text) {\r\n\t\tconst {\r\n\t\t\tdigits,\r\n\t\t\tjustLeadingPlus\r\n\t\t} = this.parser.input(text, this.state)\r\n\t\tif (justLeadingPlus) {\r\n\t\t\tthis.formattedOutput = '+'\r\n\t\t} else if (digits) {\r\n\t\t\tthis.determineTheCountryIfNeeded()\r\n\t\t\t// Match the available formats by the currently available leading digits.\r\n\t\t\tif (this.state.nationalSignificantNumber) {\r\n\t\t\t\tthis.formatter.narrowDownMatchingFormats(this.state)\r\n\t\t\t}\r\n\t\t\tlet formattedNationalNumber\r\n\t\t\tif (this.metadata.hasSelectedNumberingPlan()) {\r\n\t\t\t\tformattedNationalNumber = this.formatter.format(digits, this.state)\r\n\t\t\t}\r\n\t\t\tif (formattedNationalNumber === undefined) {\r\n\t\t\t\t// See if another national (significant) number could be re-extracted.\r\n\t\t\t\tif (this.parser.reExtractNationalSignificantNumber(this.state)) {\r\n\t\t\t\t\tthis.determineTheCountryIfNeeded()\r\n\t\t\t\t\t// If it could, then re-try formatting the new national (significant) number.\r\n\t\t\t\t\tconst nationalDigits = this.state.getNationalDigits()\r\n\t\t\t\t\tif (nationalDigits) {\r\n\t\t\t\t\t\tformattedNationalNumber = this.formatter.format(nationalDigits, this.state)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthis.formattedOutput = formattedNationalNumber\r\n\t\t\t\t? this.getFullNumber(formattedNationalNumber)\r\n\t\t\t\t: this.getNonFormattedNumber()\r\n\t\t}\r\n\t\treturn this.formattedOutput\r\n\t}\r\n\r\n\treset() {\r\n\t\tthis.state = new AsYouTypeState({\r\n\t\t\tonCountryChange: (country) => {\r\n\t\t\t\t// Before version `1.6.0`, the official `AsYouType` formatter API\r\n\t\t\t\t// included a `.country` property on an `AsYouType` instance.\r\n\t\t\t\t// Since that property (along with the others) have been moved to\r\n\t\t\t\t// `this.state`, `this.country` property is emulated for compatibility\r\n\t\t\t\t// with the old versions.\r\n\t\t\t\tthis.country = country\r\n\t\t\t},\r\n\t\t\tonCallingCodeChange: (callingCode, country) => {\r\n\t\t\t\tthis.metadata.selectNumberingPlan(country, callingCode)\r\n\t\t\t\tthis.formatter.reset(this.metadata.numberingPlan, this.state)\r\n\t\t\t\tthis.parser.reset(this.metadata.numberingPlan)\r\n\t\t\t}\r\n\t\t})\r\n\t\tthis.formatter = new AsYouTypeFormatter({\r\n\t\t\tstate: this.state,\r\n\t\t\tmetadata: this.metadata\r\n\t\t})\r\n\t\tthis.parser = new AsYouTypeParser({\r\n\t\t\tdefaultCountry: this.defaultCountry,\r\n\t\t\tdefaultCallingCode: this.defaultCallingCode,\r\n\t\t\tmetadata: this.metadata,\r\n\t\t\tstate: this.state,\r\n\t\t\tonNationalSignificantNumberChange: () => {\r\n\t\t\t\tthis.determineTheCountryIfNeeded()\r\n\t\t\t\tthis.formatter.reset(this.metadata.numberingPlan, this.state)\r\n\t\t\t}\r\n\t\t})\r\n\t\tthis.state.reset({\r\n\t\t\tcountry: this.defaultCountry,\r\n\t\t\tcallingCode: this.defaultCallingCode\r\n\t\t})\r\n\t\tthis.formattedOutput = ''\r\n\t\treturn this\r\n\t}\r\n\r\n\t/**\r\n\t * Returns `true` if the phone number is being input in international format.\r\n\t * In other words, returns `true` if and only if the parsed phone number starts with a `\"+\"`.\r\n\t * @return {boolean}\r\n\t */\r\n\tisInternational() {\r\n\t\treturn this.state.international\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the \"calling code\" part of the phone number when it's being input\r\n\t * in an international format.\r\n\t * If no valid calling code has been entered so far, returns `undefined`.\r\n\t * @return {string} [callingCode]\r\n\t */\r\n\tgetCallingCode() {\r\n\t\t // If the number is being input in national format and some \"default calling code\"\r\n\t\t // has been passed to `AsYouType` constructor, then `this.state.callingCode`\r\n\t\t // is equal to that \"default calling code\".\r\n\t\t //\r\n\t\t // If the number is being input in national format and no \"default calling code\"\r\n\t\t // has been passed to `AsYouType` constructor, then returns `undefined`,\r\n\t\t // even if a \"default country\" has been passed to `AsYouType` constructor.\r\n\t\t //\r\n\t\tif (this.isInternational()) {\r\n\t\t\treturn this.state.callingCode\r\n\t\t}\r\n\t}\r\n\r\n\t// A legacy alias.\r\n\tgetCountryCallingCode() {\r\n\t\treturn this.getCallingCode()\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a two-letter country code of the phone number.\r\n\t * Returns `undefined` for \"non-geographic\" phone numbering plans.\r\n\t * Returns `undefined` if no phone number has been input yet.\r\n\t * @return {string} [country]\r\n\t */\r\n\tgetCountry() {\r\n\t\tconst { digits } = this.state\r\n\t\t// Return `undefined` if no digits have been input yet.\r\n\t\tif (digits) {\r\n\t\t\treturn this._getCountry()\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a two-letter country code of the phone number.\r\n\t * Returns `undefined` for \"non-geographic\" phone numbering plans.\r\n\t * @return {string} [country]\r\n\t */\r\n\t_getCountry() {\r\n\t\tconst { country } = this.state\r\n\t\t/* istanbul ignore if */\r\n\t\tif (USE_NON_GEOGRAPHIC_COUNTRY_CODE) {\r\n\t\t\t// `AsYouType.getCountry()` returns `undefined`\r\n\t\t\t// for \"non-geographic\" phone numbering plans.\r\n\t\t\tif (country === '001') {\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn country\r\n\t}\r\n\r\n\tdetermineTheCountryIfNeeded() {\r\n\t\t// Suppose a user enters a phone number in international format,\r\n\t\t// and there're several countries corresponding to that country calling code,\r\n\t\t// and a country has been derived from the number, and then\r\n\t\t// a user enters one more digit and the number is no longer\r\n\t\t// valid for the derived country, so the country should be re-derived\r\n\t\t// on every new digit in those cases.\r\n\t\t//\r\n\t\t// If the phone number is being input in national format,\r\n\t\t// then it could be a case when `defaultCountry` wasn't specified\r\n\t\t// when creating `AsYouType` instance, and just `defaultCallingCode` was specified,\r\n\t\t// and that \"calling code\" could correspond to a \"non-geographic entity\",\r\n\t\t// or there could be several countries corresponding to that country calling code.\r\n\t\t// In those cases, `this.country` is `undefined` and should be derived\r\n\t\t// from the number. Again, if country calling code is ambiguous, then\r\n\t\t// `this.country` should be re-derived with each new digit.\r\n\t\t//\r\n\t\tif (!this.state.country || this.isCountryCallingCodeAmbiguous()) {\r\n\t\t\tthis.determineTheCountry()\r\n\t\t}\r\n\t}\r\n\r\n\t// Prepends `+CountryCode ` in case of an international phone number\r\n\tgetFullNumber(formattedNationalNumber) {\r\n\t\tif (this.isInternational()) {\r\n\t\t\tconst prefix = (text) => this.formatter.getInternationalPrefixBeforeCountryCallingCode(this.state, {\r\n\t\t\t\tspacing: text ? true : false\r\n\t\t\t}) + text\r\n\t\t\tconst { callingCode } = this.state\r\n\t\t\tif (!callingCode) {\r\n\t\t\t\treturn prefix(`${this.state.getDigitsWithoutInternationalPrefix()}`)\r\n\t\t\t}\r\n\t\t\tif (!formattedNationalNumber) {\r\n\t\t\t\treturn prefix(callingCode)\r\n\t\t\t}\r\n\t\t\treturn prefix(`${callingCode} ${formattedNationalNumber}`)\r\n\t\t}\r\n\t\treturn formattedNationalNumber\r\n\t}\r\n\r\n\tgetNonFormattedNationalNumberWithPrefix() {\r\n\t\tconst {\r\n\t\t\tnationalSignificantNumber,\r\n\t\t\tprefixBeforeNationalSignificantNumberThatIsNotNationalPrefix,\r\n\t\t\tnationalPrefix\r\n\t\t} = this.state\r\n\t\tlet number = nationalSignificantNumber\r\n\t\tconst prefix = prefixBeforeNationalSignificantNumberThatIsNotNationalPrefix || nationalPrefix\r\n\t\tif (prefix) {\r\n\t\t\tnumber = prefix + number\r\n\t\t}\r\n\t\treturn number\r\n\t}\r\n\r\n\tgetNonFormattedNumber() {\r\n\t\tconst { nationalSignificantNumberIsModified } = this.state\r\n\t\treturn this.getFullNumber(\r\n\t\t\tnationalSignificantNumberIsModified\r\n\t\t\t\t? this.state.getNationalDigits()\r\n\t\t\t\t: this.getNonFormattedNationalNumberWithPrefix()\r\n\t\t)\r\n\t}\r\n\r\n\tgetNonFormattedTemplate() {\r\n\t\tconst number = this.getNonFormattedNumber()\r\n\t\tif (number) {\r\n\t\t\treturn number.replace(/[\\+\\d]/g, DIGIT_PLACEHOLDER)\r\n\t\t}\r\n\t}\r\n\r\n\tisCountryCallingCodeAmbiguous() {\r\n\t\tconst { callingCode } = this.state\r\n\t\tconst countryCodes = this.metadata.getCountryCodesForCallingCode(callingCode)\r\n\t\treturn countryCodes && countryCodes.length > 1\r\n\t}\r\n\r\n\t// Determines the exact country of the phone number\r\n\t// entered so far based on the country phone code\r\n\t// and the national phone number.\r\n\tdetermineTheCountry() {\r\n\t\tthis.state.setCountry(getCountryByCallingCode(\r\n\t\t\tthis.isInternational() ? this.state.callingCode : this.defaultCallingCode,\r\n\t\t\t{\r\n\t\t\t\tnationalNumber: this.state.nationalSignificantNumber,\r\n\t\t\t\tmetadata: this.metadata\r\n\t\t\t}\r\n\t\t))\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a E.164 phone number value for the user's input.\r\n\t *\r\n\t * For example, for country `\"US\"` and input `\"(222) 333-4444\"`\r\n\t * it will return `\"+12223334444\"`.\r\n\t *\r\n\t * For international phone number input, it will also auto-correct\r\n\t * some minor errors such as using a national prefix when writing\r\n\t * an international phone number. For example, if the user inputs\r\n\t * `\"+44 0 7400 000000\"` then it will return an auto-corrected\r\n\t * `\"+447400000000\"` phone number value.\r\n\t *\r\n\t * Will return `undefined` if no digits have been input,\r\n\t * or when inputting a phone number in national format and no\r\n\t * default country or default \"country calling code\" have been set.\r\n\t *\r\n\t * @return {string} [value]\r\n\t */\r\n\tgetNumberValue() {\r\n\t\tconst {\r\n\t\t\tdigits,\r\n\t\t\tcallingCode,\r\n\t\t\tcountry,\r\n\t\t\tnationalSignificantNumber\r\n\t\t} = this.state\r\n\r\n\t \t// Will return `undefined` if no digits have been input.\r\n\t\tif (!digits) {\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tif (this.isInternational()) {\r\n\t\t\tif (callingCode) {\r\n\t\t\t\treturn '+' + callingCode + nationalSignificantNumber\r\n\t\t\t} else {\r\n\t\t\t\treturn '+' + digits\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tif (country || callingCode) {\r\n\t\t\t\tconst callingCode_ = country ? this.metadata.countryCallingCode() : callingCode\r\n\t\t\t\treturn '+' + callingCode_ + nationalSignificantNumber\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an instance of `PhoneNumber` class.\r\n\t * Will return `undefined` if no national (significant) number\r\n\t * digits have been entered so far, or if no `defaultCountry` has been\r\n\t * set and the user enters a phone number not in international format.\r\n\t */\r\n\tgetNumber() {\r\n\t\tconst {\r\n\t\t\tnationalSignificantNumber,\r\n\t\t\tcarrierCode,\r\n\t\t\tcallingCode\r\n\t\t} = this.state\r\n\r\n\t\t// `this._getCountry()` is basically same as `this.state.country`\r\n\t\t// with the only change that it return `undefined` in case of a\r\n\t\t// \"non-geographic\" numbering plan instead of `\"001\"` \"internal use\" value.\r\n\t\tlet country = this._getCountry()\r\n\r\n\t\tif (!nationalSignificantNumber) {\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\t// `state.country` and `state.callingCode` aren't required to be in sync.\r\n\t\t// For example, `country` could be `\"AR\"` and `callingCode` could be `undefined`.\r\n\t\t// So `country` and `callingCode` are totally independent.\r\n\r\n\t\tif (!country && !callingCode) {\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\t// By default, if `defaultCountry` parameter was passed when\r\n\t\t// creating `AsYouType` instance, `state.country` is gonna be\r\n\t\t// that `defaultCountry`, which doesn't entirely conform with\r\n\t\t// `parsePhoneNumber()`'s behavior where it attempts to determine\r\n\t\t// the country more precisely in cases when multiple countries\r\n\t\t// could correspond to the same `countryCallingCode`.\r\n\t\t// https://gitlab.com/catamphetamine/libphonenumber-js/-/issues/103#note_1417192969\r\n\t\t//\r\n\t\t// Because `AsYouType.getNumber()` method is supposed to be a 1:1\r\n\t\t// equivalent for `parsePhoneNumber(AsYouType.getNumberValue())`,\r\n\t\t// then it should also behave accordingly in cases of `country` ambiguity.\r\n\t\t// That's how users of this library would expect it to behave anyway.\r\n\t\t//\r\n\t\tif (country) {\r\n\t\t\tif (country === this.defaultCountry) {\r\n\t\t\t\t// `state.country` and `state.callingCode` aren't required to be in sync.\r\n\t\t\t\t// For example, `state.country` could be `\"AR\"` and `state.callingCode` could be `undefined`.\r\n\t\t\t\t// So `state.country` and `state.callingCode` are totally independent.\r\n\t\t\t\tconst metadata = new Metadata(this.metadata.metadata)\r\n\t\t\t\tmetadata.selectNumberingPlan(country)\r\n\t\t\t\tconst callingCode = metadata.numberingPlan.callingCode()\r\n\t\t\t\tconst ambiguousCountries = this.metadata.getCountryCodesForCallingCode(callingCode)\r\n\t\t\t\tif (ambiguousCountries.length > 1) {\r\n\t\t\t\t\tconst exactCountry = getCountryByNationalNumber(nationalSignificantNumber, {\r\n\t\t\t\t\t\tcountries: ambiguousCountries,\r\n\t\t\t\t\t\tmetadata: this.metadata.metadata\r\n\t\t\t\t\t})\r\n\t\t\t\t\tif (exactCountry) {\r\n\t\t\t\t\t\tcountry = exactCountry\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tconst phoneNumber = new PhoneNumber(\r\n\t\t\tcountry || callingCode,\r\n\t\t\tnationalSignificantNumber,\r\n\t\t\tthis.metadata.metadata\r\n\t\t)\r\n\t\tif (carrierCode) {\r\n\t\t\tphoneNumber.carrierCode = carrierCode\r\n\t\t}\r\n\t\t// Phone number extensions are not supported by \"As You Type\" formatter.\r\n\t\treturn phoneNumber\r\n\t}\r\n\r\n\t/**\r\n\t * Returns `true` if the phone number is \"possible\".\r\n\t * Is just a shortcut for `PhoneNumber.isPossible()`.\r\n\t * @return {boolean}\r\n\t */\r\n\tisPossible() {\r\n\t\tconst phoneNumber = this.getNumber()\r\n\t\tif (!phoneNumber) {\r\n\t\t\treturn false\r\n\t\t}\r\n\t\treturn phoneNumber.isPossible()\r\n\t}\r\n\r\n\t/**\r\n\t * Returns `true` if the phone number is \"valid\".\r\n\t * Is just a shortcut for `PhoneNumber.isValid()`.\r\n\t * @return {boolean}\r\n\t */\r\n\tisValid() {\r\n\t\tconst phoneNumber = this.getNumber()\r\n\t\tif (!phoneNumber) {\r\n\t\t\treturn false\r\n\t\t}\r\n\t\treturn phoneNumber.isValid()\r\n\t}\r\n\r\n\t/**\r\n\t * @deprecated\r\n\t * This method is used in `react-phone-number-input/source/input-control.js`\r\n\t * in versions before `3.0.16`.\r\n\t */\r\n\tgetNationalNumber() {\r\n\t\treturn this.state.nationalSignificantNumber\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the phone number characters entered by the user.\r\n\t * @return {string}\r\n\t */\r\n\tgetChars() {\r\n\t\treturn (this.state.international ? '+' : '') + this.state.digits\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the template for the formatted phone number.\r\n\t * @return {string}\r\n\t */\r\n\tgetTemplate() {\r\n\t\treturn this.formatter.getTemplate(this.state) || this.getNonFormattedTemplate() || ''\r\n\t}\r\n}","import extractCountryCallingCode from './helpers/extractCountryCallingCode.js'\r\nimport extractCountryCallingCodeFromInternationalNumberWithoutPlusSign from './helpers/extractCountryCallingCodeFromInternationalNumberWithoutPlusSign.js'\r\nimport extractNationalNumberFromPossiblyIncompleteNumber from './helpers/extractNationalNumberFromPossiblyIncompleteNumber.js'\r\nimport stripIddPrefix from './helpers/stripIddPrefix.js'\r\nimport parseDigits from './helpers/parseDigits.js'\r\n\r\nimport {\r\n\tVALID_DIGITS,\r\n\tVALID_PUNCTUATION,\r\n\tPLUS_CHARS\r\n} from './constants.js'\r\n\r\nconst VALID_FORMATTED_PHONE_NUMBER_DIGITS_PART =\r\n\t'[' +\r\n\t\tVALID_PUNCTUATION +\r\n\t\tVALID_DIGITS +\r\n\t']+'\r\n\r\nconst VALID_FORMATTED_PHONE_NUMBER_DIGITS_PART_PATTERN = new RegExp('^' + VALID_FORMATTED_PHONE_NUMBER_DIGITS_PART + '$', 'i')\r\n\r\nconst VALID_FORMATTED_PHONE_NUMBER_PART =\r\n\t'(?:' +\r\n\t\t'[' + PLUS_CHARS + ']' +\r\n\t\t'[' +\r\n\t\t\tVALID_PUNCTUATION +\r\n\t\t\tVALID_DIGITS +\r\n\t\t']*' +\r\n\t\t'|' +\r\n\t\t'[' +\r\n\t\t\tVALID_PUNCTUATION +\r\n\t\t\tVALID_DIGITS +\r\n\t\t']+' +\r\n\t')'\r\n\r\nconst AFTER_PHONE_NUMBER_DIGITS_END_PATTERN = new RegExp(\r\n\t'[^' +\r\n\t\tVALID_PUNCTUATION +\r\n\t\tVALID_DIGITS +\r\n\t']+' +\r\n\t'.*' +\r\n\t'$'\r\n)\r\n\r\n// Tests whether `national_prefix_for_parsing` could match\r\n// different national prefixes.\r\n// Matches anything that's not a digit or a square bracket.\r\nconst COMPLEX_NATIONAL_PREFIX = /[^\\d\\[\\]]/\r\n\r\nexport default class AsYouTypeParser {\r\n\tconstructor({\r\n\t\tdefaultCountry,\r\n\t\tdefaultCallingCode,\r\n\t\tmetadata,\r\n\t\tonNationalSignificantNumberChange\r\n\t}) {\r\n\t\tthis.defaultCountry = defaultCountry\r\n\t\tthis.defaultCallingCode = defaultCallingCode\r\n\t\tthis.metadata = metadata\r\n\t\tthis.onNationalSignificantNumberChange = onNationalSignificantNumberChange\r\n\t}\r\n\r\n\tinput(text, state) {\r\n\t\tconst [formattedDigits, hasPlus] = extractFormattedDigitsAndPlus(text)\r\n\t\tconst digits = parseDigits(formattedDigits)\r\n\t\t// Checks for a special case: just a leading `+` has been entered.\r\n\t\tlet justLeadingPlus\r\n\t\tif (hasPlus) {\r\n\t\t\tif (!state.digits) {\r\n\t\t\t\tstate.startInternationalNumber(undefined, undefined)\r\n\t\t\t\tif (!digits) {\r\n\t\t\t\t\tjustLeadingPlus = true\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (digits) {\r\n\t\t\tthis.inputDigits(digits, state)\r\n\t\t}\r\n\t\treturn {\r\n\t\t\tdigits,\r\n\t\t\tjustLeadingPlus\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Inputs \"next\" phone number digits.\r\n\t * @param  {string} digits\r\n\t * @return {string} [formattedNumber] Formatted national phone number (if it can be formatted at this stage). Returning `undefined` means \"don't format the national phone number at this stage\".\r\n\t */\r\n\tinputDigits(nextDigits, state) {\r\n\t\tconst { digits } = state\r\n\t\tconst hasReceivedThreeLeadingDigits = digits.length < 3 && digits.length + nextDigits.length >= 3\r\n\r\n\t\t// Append phone number digits.\r\n\t\tstate.appendDigits(nextDigits)\r\n\r\n\t\t// Attempt to extract IDD prefix:\r\n\t\t// Some users input their phone number in international format,\r\n\t\t// but in an \"out-of-country\" dialing format instead of using the leading `+`.\r\n\t\t// https://github.com/catamphetamine/libphonenumber-js/issues/185\r\n\t\t// Detect such numbers as soon as there're at least 3 digits.\r\n\t\t// Google's library attempts to extract IDD prefix at 3 digits,\r\n\t\t// so this library just copies that behavior.\r\n\t\t// I guess that's because the most commot IDD prefixes are\r\n\t\t// `00` (Europe) and `011` (US).\r\n\t\t// There exist really long IDD prefixes too:\r\n\t\t// for example, in Australia the default IDD prefix is `0011`,\r\n\t\t// and it could even be as long as `14880011`.\r\n\t\t// An IDD prefix is extracted here, and then every time when\r\n\t\t// there's a new digit and the number couldn't be formatted.\r\n\t\tif (hasReceivedThreeLeadingDigits) {\r\n\t\t\tthis.extractIddPrefix(state)\r\n\t\t}\r\n\r\n\t\tif (this.isWaitingForCountryCallingCode(state)) {\r\n\t\t\tif (!this.extractCountryCallingCode(state)) {\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tstate.appendNationalSignificantNumberDigits(nextDigits)\r\n\t\t}\r\n\r\n\t\t// If a phone number is being input in international format,\r\n\t\t// then it's not valid for it to have a national prefix.\r\n\t\t// Still, some people incorrectly input such numbers with a national prefix.\r\n\t\t// In such cases, only attempt to strip a national prefix if the number becomes too long.\r\n\t\t// (but that is done later, not here)\r\n\t\tif (!state.international) {\r\n\t\t\tif (!this.hasExtractedNationalSignificantNumber) {\r\n\t\t\t\tthis.extractNationalSignificantNumber(\r\n\t\t\t\t\tstate.getNationalDigits(),\r\n\t\t\t\t\t(stateUpdate) => state.update(stateUpdate)\r\n\t\t\t\t)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tisWaitingForCountryCallingCode({ international, callingCode }) {\r\n\t\treturn international && !callingCode\r\n\t}\r\n\r\n\t// Extracts a country calling code from a number\r\n\t// being entered in internatonal format.\r\n\textractCountryCallingCode(state) {\r\n\t\tconst { countryCallingCode, number } = extractCountryCallingCode(\r\n\t\t\t'+' + state.getDigitsWithoutInternationalPrefix(),\r\n\t\t\tstate.country,\r\n\t\t\tthis.defaultCountry,\r\n\t\t\tthis.defaultCallingCode,\r\n\t\t\tthis.metadata.metadata\r\n\t\t)\r\n\t\tif (countryCallingCode) {\r\n\t\t\tstate.setCallingCode(countryCallingCode)\r\n\t\t\tstate.update({\r\n\t\t\t\tnationalSignificantNumber: number\r\n\t\t\t})\r\n\t\t\treturn true\r\n\t\t}\r\n\t}\r\n\r\n\treset(numberingPlan) {\r\n\t\tif (numberingPlan) {\r\n\t\t\tthis.hasSelectedNumberingPlan = true\r\n\t\t\tconst nationalPrefixForParsing = numberingPlan._nationalPrefixForParsing()\r\n\t\t\tthis.couldPossiblyExtractAnotherNationalSignificantNumber = nationalPrefixForParsing && COMPLEX_NATIONAL_PREFIX.test(nationalPrefixForParsing)\r\n\t\t} else {\r\n\t\t\tthis.hasSelectedNumberingPlan = undefined\r\n\t\t\tthis.couldPossiblyExtractAnotherNationalSignificantNumber = undefined\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Extracts a national (significant) number from user input.\r\n\t * Google's library is different in that it only applies `national_prefix_for_parsing`\r\n\t * and doesn't apply `national_prefix_transform_rule` after that.\r\n\t * https://github.com/google/libphonenumber/blob/a3d70b0487875475e6ad659af404943211d26456/java/libphonenumber/src/com/google/i18n/phonenumbers/AsYouTypeFormatter.java#L539\r\n\t * @return {boolean} [extracted]\r\n\t */\r\n\textractNationalSignificantNumber(nationalDigits, setState) {\r\n\t\tif (!this.hasSelectedNumberingPlan) {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tconst {\r\n\t\t\tnationalPrefix,\r\n\t\t\tnationalNumber,\r\n\t\t\tcarrierCode\r\n\t\t} = extractNationalNumberFromPossiblyIncompleteNumber(\r\n\t\t\tnationalDigits,\r\n\t\t\tthis.metadata\r\n\t\t)\r\n\t\tif (nationalNumber === nationalDigits) {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tthis.onExtractedNationalNumber(\r\n\t\t\tnationalPrefix,\r\n\t\t\tcarrierCode,\r\n\t\t\tnationalNumber,\r\n\t\t\tnationalDigits,\r\n\t\t\tsetState\r\n\t\t)\r\n\t\treturn true\r\n\t}\r\n\r\n\t/**\r\n\t * In Google's code this function is called \"attempt to extract longer NDD\".\r\n\t * \"Some national prefixes are a substring of others\", they say.\r\n\t * @return {boolean} [result] — Returns `true` if extracting a national prefix produced different results from what they were.\r\n\t */\r\n\textractAnotherNationalSignificantNumber(nationalDigits, prevNationalSignificantNumber, setState) {\r\n\t\tif (!this.hasExtractedNationalSignificantNumber) {\r\n\t\t\treturn this.extractNationalSignificantNumber(nationalDigits, setState)\r\n\t\t}\r\n\t\tif (!this.couldPossiblyExtractAnotherNationalSignificantNumber) {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tconst {\r\n\t\t\tnationalPrefix,\r\n\t\t\tnationalNumber,\r\n\t\t\tcarrierCode\r\n\t\t} = extractNationalNumberFromPossiblyIncompleteNumber(\r\n\t\t\tnationalDigits,\r\n\t\t\tthis.metadata\r\n\t\t)\r\n\t\t// If a national prefix has been extracted previously,\r\n\t\t// then it's always extracted as additional digits are added.\r\n\t\t// That's assuming `extractNationalNumberFromPossiblyIncompleteNumber()`\r\n\t\t// doesn't do anything different from what it currently does.\r\n\t\t// So, just in case, here's this check, though it doesn't occur.\r\n\t\t/* istanbul ignore if */\r\n\t\tif (nationalNumber === prevNationalSignificantNumber) {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tthis.onExtractedNationalNumber(\r\n\t\t\tnationalPrefix,\r\n\t\t\tcarrierCode,\r\n\t\t\tnationalNumber,\r\n\t\t\tnationalDigits,\r\n\t\t\tsetState\r\n\t\t)\r\n\t\treturn true\r\n\t}\r\n\r\n\tonExtractedNationalNumber(\r\n\t\tnationalPrefix,\r\n\t\tcarrierCode,\r\n\t\tnationalSignificantNumber,\r\n\t\tnationalDigits,\r\n\t\tsetState\r\n\t) {\r\n\t\t// Tells if the parsed national (significant) number is present as-is in the input string.\r\n\t\t// For example, when inputting \"0343515551212999\" Argentinian mobile number,\r\n\t\t// the parsed national (significant) number is \"93435551212999\".\r\n\t\t// There, one can see how it stripped \"0\" national prefix and prepended a \"9\",\r\n\t\t// because that's how it is instructed to do in Argentina's metadata.\r\n\t\t// So in the described example, the parsed national (significant) number is not present\r\n\t\t// as-is in the input string. Instead, it's \"modified\" in the input string.\r\n\t\t// https://gitlab.com/catamphetamine/libphonenumber-js/-/blob/master/METADATA.md#national_prefix_for_parsing--national_prefix_transform_rule\r\n\t\tlet nationalSignificantNumberIsModified = false\r\n\r\n\t\t// In some countries, a phone number could have a prefix that is not a \"national prefix\"\r\n\t\t// but rather some other type of \"utility\" prefix.\r\n\t\t// For example, when calling within Australia, one could prepend `1831` prefix to hide\r\n\t\t// caller's phone number.\r\n\t\t// https://gitlab.com/catamphetamine/libphonenumber-js/-/blob/master/METADATA.md#national_prefix_for_parsing--national_prefix_transform_rule\r\n\t\tlet prefixBeforeNationalSignificantNumberThatIsNotNationalPrefix\r\n\r\n\t\t// `nationalSignificantNumber` could be empty. In that case, `.lastIndexOf()` still works correctly.\r\n\t\tconst nationalSignificantNumberIndex = nationalDigits.lastIndexOf(nationalSignificantNumber)\r\n\r\n\t\t// If the parsed national (significant) number is the last substring of the `nationalDigits`,\r\n\t\t// then it means that it's present as-is in the input string.\r\n\t\t// In any other case, the parsed national (significant) number is \"modified\" in the input string.\r\n\t\tif (\r\n\t\t\tnationalSignificantNumberIndex < 0 ||\r\n\t\t\tnationalSignificantNumberIndex !== nationalDigits.length - nationalSignificantNumber.length\r\n\t\t) {\r\n\t\t\tnationalSignificantNumberIsModified = true\r\n\t\t} else {\r\n\t\t\tconst prefixBeforeNationalNumber = nationalDigits.slice(0, nationalSignificantNumberIndex)\r\n\t\t\t// When national (significant) number is equal to the `nationalDigits`,\r\n\t\t\t// this `onExtractedNationalNumber()` function simply doesn't get called.\r\n\t\t\t// This means that at this point, `prefixBeforeNationalNumber` is always non-empty.\r\n\t\t\t// Still, added this `if` check just to prevent potential silly bugs.\r\n\t\t\t// The `!prefixBeforeNationalNumber` case is not really testable\r\n\t\t\t// so this line is exluded from the code coverage.\r\n\t\t\t/* istanbul ignore if */\r\n\t\t\tif (prefixBeforeNationalNumber) {\r\n\t\t\t\tif (prefixBeforeNationalNumber !== nationalPrefix) {\r\n\t\t\t\t\tprefixBeforeNationalSignificantNumberThatIsNotNationalPrefix = prefixBeforeNationalNumber\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tsetState({\r\n\t\t\tnationalPrefix,\r\n\t\t\tcarrierCode,\r\n\t\t\tnationalSignificantNumber,\r\n\t\t\tnationalSignificantNumberIsModified,\r\n\t\t\tprefixBeforeNationalSignificantNumberThatIsNotNationalPrefix\r\n\t\t})\r\n\t\t// `onExtractedNationalNumber()` is only called when\r\n\t\t// the national (significant) number actually did change.\r\n\t\tthis.hasExtractedNationalSignificantNumber = true\r\n\t\tthis.onNationalSignificantNumberChange()\r\n\t}\r\n\r\n\treExtractNationalSignificantNumber(state) {\r\n\t\t// Attempt to extract a national prefix.\r\n\t\t//\r\n\t\t// Some people incorrectly input national prefix\r\n\t\t// in an international phone number.\r\n\t\t// For example, some people write British phone numbers as `+44(0)...`.\r\n\t\t//\r\n\t\t// Also, in some rare cases, it is valid for a national prefix\r\n\t\t// to be a part of an international phone number.\r\n\t\t// For example, mobile phone numbers in Mexico are supposed to be\r\n\t\t// dialled internationally using a `1` national prefix,\r\n\t\t// so the national prefix will be part of an international number.\r\n\t\t//\r\n\t\t// Quote from:\r\n\t\t// https://www.mexperience.com/dialing-cell-phones-in-mexico/\r\n\t\t//\r\n\t\t// \"Dialing a Mexican cell phone from abroad\r\n\t\t// When you are calling a cell phone number in Mexico from outside Mexico,\r\n\t\t// it’s necessary to dial an additional “1” after Mexico’s country code\r\n\t\t// (which is “52”) and before the area code.\r\n\t\t// You also ignore the 045, and simply dial the area code and the\r\n\t\t// cell phone’s number.\r\n\t\t//\r\n\t\t// If you don’t add the “1”, you’ll receive a recorded announcement\r\n\t\t// asking you to redial using it.\r\n\t\t//\r\n\t\t// For example, if you are calling from the USA to a cell phone\r\n\t\t// in Mexico City, you would dial +52 – 1 – 55 – 1234 5678.\r\n\t\t// (Note that this is different to calling a land line in Mexico City\r\n\t\t// from abroad, where the number dialed would be +52 – 55 – 1234 5678)\".\r\n\t\t//\r\n\t\t// Google's demo output:\r\n\t\t// https://libphonenumber.appspot.com/phonenumberparser?number=%2b5215512345678&country=MX\r\n\t\t//\r\n\t\tif (this.extractAnotherNationalSignificantNumber(\r\n\t\t\tstate.getNationalDigits(),\r\n\t\t\tstate.nationalSignificantNumber,\r\n\t\t\t(stateUpdate) => state.update(stateUpdate)\r\n\t\t)) {\r\n\t\t\treturn true\r\n\t\t}\r\n\t\t// If no format matches the phone number, then it could be\r\n\t\t// \"a really long IDD\" (quote from a comment in Google's library).\r\n\t\t// An IDD prefix is first extracted when the user has entered at least 3 digits,\r\n\t\t// and then here — every time when there's a new digit and the number\r\n\t\t// couldn't be formatted.\r\n\t\t// For example, in Australia the default IDD prefix is `0011`,\r\n\t\t// and it could even be as long as `14880011`.\r\n\t\t//\r\n\t\t// Could also check `!hasReceivedThreeLeadingDigits` here\r\n\t\t// to filter out the case when this check duplicates the one\r\n\t\t// already performed when there're 3 leading digits,\r\n\t\t// but it's not a big deal, and in most cases there\r\n\t\t// will be a suitable `format` when there're 3 leading digits.\r\n\t\t//\r\n\t\tif (this.extractIddPrefix(state)) {\r\n\t\t\tthis.extractCallingCodeAndNationalSignificantNumber(state)\r\n\t\t\treturn true\r\n\t\t}\r\n\t\t// Google's AsYouType formatter supports sort of an \"autocorrection\" feature\r\n\t\t// when it \"autocorrects\" numbers that have been input for a country\r\n\t\t// with that country's calling code.\r\n\t\t// Such \"autocorrection\" feature looks weird, but different people have been requesting it:\r\n\t\t// https://github.com/catamphetamine/libphonenumber-js/issues/376\r\n\t\t// https://github.com/catamphetamine/libphonenumber-js/issues/375\r\n\t\t// https://github.com/catamphetamine/libphonenumber-js/issues/316\r\n\t\tif (this.fixMissingPlus(state)) {\r\n\t\t\tthis.extractCallingCodeAndNationalSignificantNumber(state)\r\n\t\t\treturn true\r\n\t\t}\r\n\t}\r\n\r\n\textractIddPrefix(state) {\r\n\t\t// An IDD prefix can't be present in a number written with a `+`.\r\n\t\t// Also, don't re-extract an IDD prefix if has already been extracted.\r\n\t\tconst {\r\n\t\t\tinternational,\r\n\t\t\tIDDPrefix,\r\n\t\t\tdigits,\r\n\t\t\tnationalSignificantNumber\r\n\t\t} = state\r\n\t\tif (international || IDDPrefix) {\r\n\t\t\treturn\r\n\t\t}\r\n\t\t// Some users input their phone number in \"out-of-country\"\r\n\t\t// dialing format instead of using the leading `+`.\r\n\t\t// https://github.com/catamphetamine/libphonenumber-js/issues/185\r\n\t\t// Detect such numbers.\r\n\t\tconst numberWithoutIDD = stripIddPrefix(\r\n\t\t\tdigits,\r\n\t\t\tthis.defaultCountry,\r\n\t\t\tthis.defaultCallingCode,\r\n\t\t\tthis.metadata.metadata\r\n\t\t)\r\n\t\tif (numberWithoutIDD !== undefined && numberWithoutIDD !== digits) {\r\n\t\t\t// If an IDD prefix was stripped then convert the IDD-prefixed number\r\n\t\t\t// to international number for subsequent parsing.\r\n\t\t\tstate.update({\r\n\t\t\t\tIDDPrefix: digits.slice(0, digits.length - numberWithoutIDD.length)\r\n\t\t\t})\r\n\t\t\tthis.startInternationalNumber(state, {\r\n\t\t\t\tcountry: undefined,\r\n\t\t\t\tcallingCode: undefined\r\n\t\t\t})\r\n\t\t\treturn true\r\n\t\t}\r\n\t}\r\n\r\n\tfixMissingPlus(state) {\r\n\t\tif (!state.international) {\r\n\t\t\tconst {\r\n\t\t\t\tcountryCallingCode: newCallingCode\r\n\t\t\t} = extractCountryCallingCodeFromInternationalNumberWithoutPlusSign(\r\n\t\t\t\tstate.digits,\r\n\t\t\t\tstate.country,\r\n\t\t\t\tthis.defaultCountry,\r\n\t\t\t\tthis.defaultCallingCode,\r\n\t\t\t\tthis.metadata.metadata\r\n\t\t\t)\r\n\t\t\tif (newCallingCode) {\r\n\t\t\t\tstate.update({\r\n\t\t\t\t\tmissingPlus: true\r\n\t\t\t\t})\r\n\t\t\t\tthis.startInternationalNumber(state, {\r\n\t\t\t\t\tcountry: state.country,\r\n\t\t\t\t\tcallingCode: newCallingCode\r\n\t\t\t\t})\r\n\t\t\t\treturn true\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tstartInternationalNumber(state, { country, callingCode }) {\r\n\t\tstate.startInternationalNumber(country, callingCode)\r\n\t\t// If a national (significant) number has been extracted before, reset it.\r\n\t\tif (state.nationalSignificantNumber) {\r\n\t\t\tstate.resetNationalSignificantNumber()\r\n\t\t\tthis.onNationalSignificantNumberChange()\r\n\t\t\tthis.hasExtractedNationalSignificantNumber = undefined\r\n\t\t}\r\n\t}\r\n\r\n\textractCallingCodeAndNationalSignificantNumber(state) {\r\n\t\tif (this.extractCountryCallingCode(state)) {\r\n\t\t\t// `this.extractCallingCode()` is currently called when the number\r\n\t\t\t// couldn't be formatted during the standard procedure.\r\n\t\t\t// Normally, the national prefix would be re-extracted\r\n\t\t\t// for an international number if such number couldn't be formatted,\r\n\t\t\t// but since it's already not able to be formatted,\r\n\t\t\t// there won't be yet another retry, so also extract national prefix here.\r\n\t\t\tthis.extractNationalSignificantNumber(\r\n\t\t\t\tstate.getNationalDigits(),\r\n\t\t\t\t(stateUpdate) => state.update(stateUpdate)\r\n\t\t\t)\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/**\r\n * Extracts formatted phone number from text (if there's any).\r\n * @param  {string} text\r\n * @return {string} [formattedPhoneNumber]\r\n */\r\nfunction extractFormattedPhoneNumber(text) {\r\n\t// Attempt to extract a possible number from the string passed in.\r\n\tconst startsAt = text.search(VALID_FORMATTED_PHONE_NUMBER_PART)\r\n\tif (startsAt < 0) {\r\n\t\treturn\r\n\t}\r\n\t// Trim everything to the left of the phone number.\r\n\ttext = text.slice(startsAt)\r\n\t// Trim the `+`.\r\n\tlet hasPlus\r\n\tif (text[0] === '+') {\r\n\t\thasPlus = true\r\n\t\ttext = text.slice('+'.length)\r\n\t}\r\n\t// Trim everything to the right of the phone number.\r\n\ttext = text.replace(AFTER_PHONE_NUMBER_DIGITS_END_PATTERN, '')\r\n\t// Re-add the previously trimmed `+`.\r\n\tif (hasPlus) {\r\n\t\ttext = '+' + text\r\n\t}\r\n\treturn text\r\n}\r\n\r\n/**\r\n * Extracts formatted phone number digits (and a `+`) from text (if there're any).\r\n * @param  {string} text\r\n * @return {any[]}\r\n */\r\nfunction _extractFormattedDigitsAndPlus(text) {\r\n\t// Extract a formatted phone number part from text.\r\n\tconst extractedNumber = extractFormattedPhoneNumber(text) || ''\r\n\t// Trim a `+`.\r\n\tif (extractedNumber[0] === '+') {\r\n\t\treturn [extractedNumber.slice('+'.length), true]\r\n\t}\r\n\treturn [extractedNumber]\r\n}\r\n\r\n/**\r\n * Extracts formatted phone number digits (and a `+`) from text (if there're any).\r\n * @param  {string} text\r\n * @return {any[]}\r\n */\r\nexport function extractFormattedDigitsAndPlus(text) {\r\n\tlet [formattedDigits, hasPlus] = _extractFormattedDigitsAndPlus(text)\r\n\t// If the extracted phone number part\r\n\t// can possibly be a part of some valid phone number\r\n\t// then parse phone number characters from a formatted phone number.\r\n\tif (!VALID_FORMATTED_PHONE_NUMBER_DIGITS_PART_PATTERN.test(formattedDigits)) {\r\n\t\tformattedDigits = ''\r\n\t}\r\n\treturn [formattedDigits, hasPlus]\r\n}","/**\r\n * Strips any national prefix (such as 0, 1) present in a\r\n * (possibly incomplete) number provided.\r\n * \"Carrier codes\" are only used  in Colombia and Brazil,\r\n * and only when dialing within those countries from a mobile phone to a fixed line number.\r\n * Sometimes it won't actually strip national prefix\r\n * and will instead prepend some digits to the `number`:\r\n * for example, when number `2345678` is passed with `VI` country selected,\r\n * it will return `{ number: \"3402345678\" }`, because `340` area code is prepended.\r\n * @param {string} number — National number digits.\r\n * @param {object} metadata — Metadata with country selected.\r\n * @return {object} `{ nationalNumber: string, nationalPrefix: string? carrierCode: string? }`. Even if a national prefix was extracted, it's not necessarily present in the returned object, so don't rely on its presence in the returned object in order to find out whether a national prefix has been extracted or not.\r\n */\r\nexport default function extractNationalNumberFromPossiblyIncompleteNumber(number, metadata) {\r\n\tif (number && metadata.numberingPlan.nationalPrefixForParsing()) {\r\n\t\t// See METADATA.md for the description of\r\n\t\t// `national_prefix_for_parsing` and `national_prefix_transform_rule`.\r\n\t\t// Attempt to parse the first digits as a national prefix.\r\n\t\tconst prefixPattern = new RegExp('^(?:' + metadata.numberingPlan.nationalPrefixForParsing() + ')')\r\n\t\tconst prefixMatch = prefixPattern.exec(number)\r\n\t\tif (prefixMatch) {\r\n\t\t\tlet nationalNumber\r\n\t\t\tlet carrierCode\r\n\t\t\t// https://gitlab.com/catamphetamine/libphonenumber-js/-/blob/master/METADATA.md#national_prefix_for_parsing--national_prefix_transform_rule\r\n\t\t\t// If a `national_prefix_for_parsing` has any \"capturing groups\"\r\n\t\t\t// then it means that the national (significant) number is equal to\r\n\t\t\t// those \"capturing groups\" transformed via `national_prefix_transform_rule`,\r\n\t\t\t// and nothing could be said about the actual national prefix:\r\n\t\t\t// what is it and was it even there.\r\n\t\t\t// If a `national_prefix_for_parsing` doesn't have any \"capturing groups\",\r\n\t\t\t// then everything it matches is a national prefix.\r\n\t\t\t// To determine whether `national_prefix_for_parsing` matched any\r\n\t\t\t// \"capturing groups\", the value of the result of calling `.exec()`\r\n\t\t\t// is looked at, and if it has non-undefined values where there're\r\n\t\t\t// \"capturing groups\" in the regular expression, then it means\r\n\t\t\t// that \"capturing groups\" have been matched.\r\n\t\t\t// It's not possible to tell whether there'll be any \"capturing gropus\"\r\n\t\t\t// before the matching process, because a `national_prefix_for_parsing`\r\n\t\t\t// could exhibit both behaviors.\r\n\t\t\tconst capturedGroupsCount = prefixMatch.length - 1\r\n\t\t\tconst hasCapturedGroups = capturedGroupsCount > 0 && prefixMatch[capturedGroupsCount]\r\n\t\t\tif (metadata.nationalPrefixTransformRule() && hasCapturedGroups) {\r\n\t\t\t\tnationalNumber = number.replace(\r\n\t\t\t\t\tprefixPattern,\r\n\t\t\t\t\tmetadata.nationalPrefixTransformRule()\r\n\t\t\t\t)\r\n\t\t\t\t// If there's more than one captured group,\r\n\t\t\t\t// then carrier code is the second one.\r\n\t\t\t\tif (capturedGroupsCount > 1) {\r\n\t\t\t\t\tcarrierCode = prefixMatch[1]\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// If there're no \"capturing groups\",\r\n\t\t\t// or if there're \"capturing groups\" but no\r\n\t\t\t// `national_prefix_transform_rule`,\r\n\t\t\t// then just strip the national prefix from the number,\r\n\t\t\t// and possibly a carrier code.\r\n\t\t\t// Seems like there could be more.\r\n\t\t\telse {\r\n\t\t\t\t// `prefixBeforeNationalNumber` is the whole substring matched by\r\n\t\t\t\t// the `national_prefix_for_parsing` regular expression.\r\n\t\t\t\t// There seem to be no guarantees that it's just a national prefix.\r\n\t\t\t\t// For example, if there's a carrier code, it's gonna be a\r\n\t\t\t\t// part of `prefixBeforeNationalNumber` too.\r\n\t\t\t\tconst prefixBeforeNationalNumber = prefixMatch[0]\r\n\t\t\t\tnationalNumber = number.slice(prefixBeforeNationalNumber.length)\r\n\t\t\t\t// If there's at least one captured group,\r\n\t\t\t\t// then carrier code is the first one.\r\n\t\t\t\tif (hasCapturedGroups) {\r\n\t\t\t\t\tcarrierCode = prefixMatch[1]\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// Tries to guess whether a national prefix was present in the input.\r\n\t\t\t// This is not something copy-pasted from Google's library:\r\n\t\t\t// they don't seem to have an equivalent for that.\r\n\t\t\t// So this isn't an \"officially approved\" way of doing something like that.\r\n\t\t\t// But since there seems no other existing method, this library uses it.\r\n\t\t\tlet nationalPrefix\r\n\t\t\tif (hasCapturedGroups) {\r\n\t\t\t\tconst possiblePositionOfTheFirstCapturedGroup = number.indexOf(prefixMatch[1])\r\n\t\t\t\tconst possibleNationalPrefix = number.slice(0, possiblePositionOfTheFirstCapturedGroup)\r\n\t\t\t\t// Example: an Argentinian (AR) phone number `0111523456789`.\r\n\t\t\t\t// `prefixMatch[0]` is `01115`, and `$1` is `11`,\r\n\t\t\t\t// and the rest of the phone number is `23456789`.\r\n\t\t\t\t// The national number is transformed via `9$1` to `91123456789`.\r\n\t\t\t\t// National prefix `0` is detected being present at the start.\r\n\t\t\t\t// if (possibleNationalPrefix.indexOf(metadata.numberingPlan.nationalPrefix()) === 0) {\r\n\t\t\t\tif (possibleNationalPrefix === metadata.numberingPlan.nationalPrefix()) {\r\n\t\t\t\t\tnationalPrefix = metadata.numberingPlan.nationalPrefix()\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tnationalPrefix = prefixMatch[0]\r\n\t\t\t}\r\n\t\t\treturn {\r\n\t\t\t\tnationalNumber,\r\n\t\t\t\tnationalPrefix,\r\n\t\t\t\tcarrierCode\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n   return {\r\n   \tnationalNumber: number\r\n   }\r\n}","import isViablePhoneNumber from './isViablePhoneNumber.js'\r\n\r\n// https://www.ietf.org/rfc/rfc3966.txt\r\n\r\n/**\r\n * @param  {string} text - Phone URI (RFC 3966).\r\n * @return {object} `{ ?number, ?ext }`.\r\n */\r\nexport function parseRFC3966(text) {\r\n\tlet number\r\n\tlet ext\r\n\r\n\t// Replace \"tel:\" with \"tel=\" for parsing convenience.\r\n\ttext = text.replace(/^tel:/, 'tel=')\r\n\r\n\tfor (const part of text.split(';')) {\r\n\t\tconst [name, value] = part.split('=')\r\n\t\tswitch (name) {\r\n\t\t\tcase 'tel':\r\n\t\t\t\tnumber = value\r\n\t\t\t\tbreak\r\n\t\t\tcase 'ext':\r\n\t\t\t\text = value\r\n\t\t\t\tbreak\r\n\t\t\tcase 'phone-context':\r\n\t\t\t\t// Only \"country contexts\" are supported.\r\n\t\t\t\t// \"Domain contexts\" are ignored.\r\n\t\t\t\tif (value[0] === '+') {\r\n\t\t\t\t\tnumber = value + number\r\n\t\t\t\t}\r\n\t\t\t\tbreak\r\n\t\t}\r\n\t}\r\n\r\n\t// If the phone number is not viable, then abort.\r\n\tif (!isViablePhoneNumber(number)) {\r\n\t\treturn {}\r\n\t}\r\n\r\n\tconst result = { number }\r\n\tif (ext) {\r\n\t\tresult.ext = ext\r\n\t}\r\n\treturn result\r\n}\r\n\r\n/**\r\n * @param  {object} - `{ ?number, ?extension }`.\r\n * @return {string} Phone URI (RFC 3966).\r\n */\r\nexport function formatRFC3966({ number, ext }) {\r\n\tif (!number) {\r\n\t\treturn ''\r\n\t}\r\n\tif (number[0] !== '+') {\r\n\t\tthrow new Error(`\"formatRFC3966()\" expects \"number\" to be in E.164 format.`)\r\n\t}\r\n\treturn `tel:${number}${ext ? ';ext=' + ext : ''}`\r\n}","import {\r\n\tMIN_LENGTH_FOR_NSN,\r\n\tVALID_DIGITS,\r\n\tVALID_PUNCTUATION,\r\n\tPLUS_CHARS\r\n} from '../constants.js'\r\n\r\nimport createExtensionPattern from './extension/createExtensionPattern.js'\r\n\r\n//  Regular expression of viable phone numbers. This is location independent.\r\n//  Checks we have at least three leading digits, and only valid punctuation,\r\n//  alpha characters and digits in the phone number. Does not include extension\r\n//  data. The symbol 'x' is allowed here as valid punctuation since it is often\r\n//  used as a placeholder for carrier codes, for example in Brazilian phone\r\n//  numbers. We also allow multiple '+' characters at the start.\r\n//\r\n//  Corresponds to the following:\r\n//  [digits]{minLengthNsn}|\r\n//  plus_sign*\r\n//  (([punctuation]|[star])*[digits]){3,}([punctuation]|[star]|[digits]|[alpha])*\r\n//\r\n//  The first reg-ex is to allow short numbers (two digits long) to be parsed if\r\n//  they are entered as \"15\" etc, but only if there is no punctuation in them.\r\n//  The second expression restricts the number of digits to three or more, but\r\n//  then allows them to be in international form, and to have alpha-characters\r\n//  and punctuation. We split up the two reg-exes here and combine them when\r\n//  creating the reg-ex VALID_PHONE_NUMBER_PATTERN itself so we can prefix it\r\n//  with ^ and append $ to each branch.\r\n//\r\n//  \"Note VALID_PUNCTUATION starts with a -,\r\n//   so must be the first in the range\" (c) Google devs.\r\n//  (wtf did they mean by saying that; probably nothing)\r\n//\r\nconst MIN_LENGTH_PHONE_NUMBER_PATTERN = '[' + VALID_DIGITS + ']{' + MIN_LENGTH_FOR_NSN + '}'\r\n//\r\n// And this is the second reg-exp:\r\n// (see MIN_LENGTH_PHONE_NUMBER_PATTERN for a full description of this reg-exp)\r\n//\r\nexport const VALID_PHONE_NUMBER =\r\n\t'[' + PLUS_CHARS + ']{0,1}' +\r\n\t'(?:' +\r\n\t\t'[' + VALID_PUNCTUATION + ']*' +\r\n\t\t'[' + VALID_DIGITS + ']' +\r\n\t'){3,}' +\r\n\t'[' +\r\n\t\tVALID_PUNCTUATION +\r\n\t\tVALID_DIGITS +\r\n\t']*'\r\n\r\n// This regular expression isn't present in Google's `libphonenumber`\r\n// and is only used to determine whether the phone number being input\r\n// is too short for it to even consider it a \"valid\" number.\r\n// This is just a way to differentiate between a really invalid phone\r\n// number like \"abcde\" and a valid phone number that a user has just\r\n// started inputting, like \"+1\" or \"1\": both these cases would be\r\n// considered `NOT_A_NUMBER` by Google's `libphonenumber`, but this\r\n// library can provide a more detailed error message — whether it's\r\n// really \"not a number\", or is it just a start of a valid phone number.\r\nconst VALID_PHONE_NUMBER_START_REG_EXP = new RegExp(\r\n\t'^' +\r\n\t'[' + PLUS_CHARS + ']{0,1}' +\r\n\t'(?:' +\r\n\t\t'[' + VALID_PUNCTUATION + ']*' +\r\n\t\t'[' + VALID_DIGITS + ']' +\r\n\t'){1,2}' +\r\n\t'$'\r\n, 'i')\r\n\r\nexport const VALID_PHONE_NUMBER_WITH_EXTENSION =\r\n\tVALID_PHONE_NUMBER +\r\n\t// Phone number extensions\r\n\t'(?:' + createExtensionPattern() + ')?'\r\n\r\n// The combined regular expression for valid phone numbers:\r\n//\r\nconst VALID_PHONE_NUMBER_PATTERN = new RegExp(\r\n\t// Either a short two-digit-only phone number\r\n\t'^' +\r\n\t\tMIN_LENGTH_PHONE_NUMBER_PATTERN +\r\n\t'$' +\r\n\t'|' +\r\n\t// Or a longer fully parsed phone number (min 3 characters)\r\n\t'^' +\r\n\t\tVALID_PHONE_NUMBER_WITH_EXTENSION +\r\n\t'$'\r\n, 'i')\r\n\r\n// Checks to see if the string of characters could possibly be a phone number at\r\n// all. At the moment, checks to see that the string begins with at least 2\r\n// digits, ignoring any punctuation commonly found in phone numbers. This method\r\n// does not require the number to be normalized in advance - but does assume\r\n// that leading non-number symbols have been removed, such as by the method\r\n// `extract_possible_number`.\r\n//\r\nexport default function isViablePhoneNumber(number) {\r\n\treturn number.length >= MIN_LENGTH_FOR_NSN &&\r\n\t\tVALID_PHONE_NUMBER_PATTERN.test(number)\r\n}\r\n\r\n// This is just a way to differentiate between a really invalid phone\r\n// number like \"abcde\" and a valid phone number that a user has just\r\n// started inputting, like \"+1\" or \"1\": both these cases would be\r\n// considered `NOT_A_NUMBER` by Google's `libphonenumber`, but this\r\n// library can provide a more detailed error message — whether it's\r\n// really \"not a number\", or is it just a start of a valid phone number.\r\nexport function isViablePhoneNumberStart(number) {\r\n\treturn VALID_PHONE_NUMBER_START_REG_EXP.test(number)\r\n}","// This \"state\" object simply holds the state of the \"AsYouType\" parser:\r\n//\r\n// * `country?: string` — The exact country of the phone number, if it could be determined.\r\n//                        When inputting a phone number in \"international\" format, it will derive the `country` from \"country calling code\" and the phone number digits.\r\n//                        When inputting a phone number in \"national\" format, it will derive the `country` from `defaultCountry` that was specified when creating the `AsYouType` formatter.\r\n//                        Sidenote: If `USE_NON_GEOGRAPHIC_COUNTRY_CODE` flag was `true`, then for \"non-geographic phone numbers\" `state.country` would've been \"001\".\r\n// * `callingCode?: string` — \"Country calling code\" that has been extracted from the input phone number.\r\n//                        When inputting a phone number in \"international\" format, it will extract the \"country calling code\" from the digits that follow the \"+\" character.\r\n//                        When inputting a phone number in \"national\" format, `callingCode` will be `undefined`.\r\n//                        Sidenote: `state.callingCode` is therefore independent from `state.country` and there could be situations when `state.country` is defined by `state.callingCode` is not — that would be when inputting a phone number not in \"international\" format.\r\n// * `digits: string` — Phone number digits that have been input so far, including the \"+\" character, if present. In case of inputting non-arabic digits, those will be converted to arabic ones.\r\n// * `international: boolean` — Whether the phone number is being input in \"international\" format, i.e. with a \"+\" character.\r\n// * `missingPlus: boolean` — Whether it's a phone number in \"international\" format that is missing the leading \"+\" character for some reason — apparently, Google thinks that it's a common mistake when inputting a phone number.\r\n// * `IDDPrefix?: string` — An \"IDD prefix\", when the phone number is being input in an \"out-of-country dialing\" format. https://wikitravel.org/en/International_dialling_prefix\r\n// * `carrierCode?: string` — A \"carrier code\", if the phone number contains it. Normally, those can only be present in Colombia or Brazil, and only when calling from mobile phones to fixed-line numbers.\r\n// * `nationalPrefix?: string` — \"National prefix\", if present in the phone number input.\r\n// * `nationalSignificantNumber?: string` — National (significant) number digits that have been input so far.\r\n// * `nationalSignificantNumberIsModified: boolean` — Tells if the parsed national (significant) number is present as-is in the input string. For example, when inputting \"0343515551212999\" Argentinian mobile number, the parsed national (significant) number is \"93435551212999\". There, one can see how it stripped \"0\" national prefix and prepended a \"9\", because that's how it is instructed to do in Argentina's metadata. So in the described example, the parsed national (significant) number is not present as-is in the input string. Instead, it's \"modified\" in the input string. https://gitlab.com/caamphetamine/libphonenumber-js/-/blob/master/METADATA.md#national_prefix_for_parsing--national_prefix_transform_rule\r\n// * `prefixBeforeNationalSignificantNumberThatIsNotNationalPrefix?: string` — In some countries, a phone number could have a prefix that is not a \"national prefix\" but rather some other type of \"utility\" prefix.\r\n//                                                                             For example, when calling within Australia, one could prepend `1831` prefix to hide caller's phone number.\r\n//                                                                             https://gitlab.com/catamphetamine/libphonenumber-js/-/blob/master/METADATA.md#national_prefix_for_parsing--national_prefix_transform_rule\r\n//\r\nexport default class AsYouTypeState {\r\n\tconstructor({ onCountryChange, onCallingCodeChange }) {\r\n\t\tthis.onCountryChange = onCountryChange\r\n\t\tthis.onCallingCodeChange = onCallingCodeChange\r\n\t}\r\n\r\n\treset({ country, callingCode }) {\r\n\t\tthis.international = false\r\n\t\tthis.missingPlus = false\r\n\t\tthis.IDDPrefix = undefined\r\n\t\tthis.callingCode = undefined\r\n\t\tthis.digits = ''\r\n\t\tthis.resetNationalSignificantNumber()\r\n\t\tthis.initCountryAndCallingCode(country, callingCode)\r\n\t}\r\n\r\n\tresetNationalSignificantNumber() {\r\n\t\tthis.nationalSignificantNumber = this.getNationalDigits()\r\n\t\tthis.nationalSignificantNumberIsModified = false\r\n\t\tthis.nationalPrefix = undefined\r\n\t\tthis.carrierCode = undefined\r\n\t\tthis.prefixBeforeNationalSignificantNumberThatIsNotNationalPrefix = undefined\r\n\t}\r\n\r\n\tupdate(properties) {\r\n\t\tfor (const key of Object.keys(properties)) {\r\n\t\t\tthis[key] = properties[key]\r\n\t\t}\r\n\t}\r\n\r\n\tinitCountryAndCallingCode(country, callingCode) {\r\n\t\tthis.setCountry(country)\r\n\t\tthis.setCallingCode(callingCode)\r\n\t}\r\n\r\n\tsetCountry(country) {\r\n\t\tthis.country = country\r\n\t\tthis.onCountryChange(country)\r\n\t}\r\n\r\n\tsetCallingCode(callingCode) {\r\n\t\tthis.callingCode = callingCode\r\n\t\tthis.onCallingCodeChange(callingCode, this.country)\r\n\t}\r\n\r\n\tstartInternationalNumber(country, callingCode) {\r\n\t\t// Prepend the `+` to parsed input.\r\n\t\tthis.international = true\r\n\t\t// If a default country was set then reset it\r\n\t\t// because an explicitly international phone\r\n\t\t// number is being entered.\r\n\t\tthis.initCountryAndCallingCode(country, callingCode)\r\n\t}\r\n\r\n\tappendDigits(nextDigits) {\r\n\t\tthis.digits += nextDigits\r\n\t}\r\n\r\n\tappendNationalSignificantNumberDigits(nextDigits) {\r\n\t\tthis.nationalSignificantNumber += nextDigits\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the part of `this.digits` that corresponds to the national number.\r\n\t * Basically, all digits that have been input by the user, except for the\r\n\t * international prefix and the country calling code part\r\n\t * (if the number is an international one).\r\n\t * @return {string}\r\n\t */\r\n\tgetNationalDigits() {\r\n\t\tif (this.international) {\r\n\t\t\treturn this.digits.slice(\r\n\t\t\t\t(this.IDDPrefix ? this.IDDPrefix.length : 0) +\r\n\t\t\t\t(this.callingCode ? this.callingCode.length : 0)\r\n\t\t\t)\r\n\t\t}\r\n\t\treturn this.digits\r\n\t}\r\n\r\n\tgetDigitsWithoutInternationalPrefix() {\r\n\t\tif (this.international) {\r\n\t\t\tif (this.IDDPrefix) {\r\n\t\t\t\treturn this.digits.slice(this.IDDPrefix.length)\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn this.digits\r\n\t}\r\n}","import { VALID_PUNCTUATION } from '../constants.js'\r\n\r\n// Removes brackets and replaces dashes with spaces.\r\n//\r\n// E.g. \"(999) 111-22-33\" -> \"999 111 22 33\"\r\n//\r\n// For some reason Google's metadata contains `<intlFormat/>`s with brackets and dashes.\r\n// Meanwhile, there's no single opinion about using punctuation in international phone numbers.\r\n//\r\n// For example, Google's `<intlFormat/>` for USA is `+1 213-373-4253`.\r\n// And here's a quote from WikiPedia's \"North American Numbering Plan\" page:\r\n// https://en.wikipedia.org/wiki/North_American_Numbering_Plan\r\n//\r\n// \"The country calling code for all countries participating in the NANP is 1.\r\n// In international format, an NANP number should be listed as +1 301 555 01 00,\r\n// where 301 is an area code (Maryland).\"\r\n//\r\n// I personally prefer the international format without any punctuation.\r\n// For example, brackets are remnants of the old age, meaning that the\r\n// phone number part in brackets (so called \"area code\") can be omitted\r\n// if dialing within the same \"area\".\r\n// And hyphens were clearly introduced for splitting local numbers into memorizable groups.\r\n// For example, remembering \"5553535\" is difficult but \"555-35-35\" is much simpler.\r\n// Imagine a man taking a bus from home to work and seeing an ad with a phone number.\r\n// He has a couple of seconds to memorize that number until it passes by.\r\n// If it were spaces instead of hyphens the man wouldn't necessarily get it,\r\n// but with hyphens instead of spaces the grouping is more explicit.\r\n// I personally think that hyphens introduce visual clutter,\r\n// so I prefer replacing them with spaces in international numbers.\r\n// In the modern age all output is done on displays where spaces are clearly distinguishable\r\n// so hyphens can be safely replaced with spaces without losing any legibility.\r\n//\r\nexport default function applyInternationalSeparatorStyle(formattedNumber) {\r\n\treturn formattedNumber.replace(new RegExp(`[${VALID_PUNCTUATION}]+`, 'g'), ' ').trim()\r\n}"],"names":["objectConstructor","Metadata","getCountryByNationalNumber","extractNationalNumberFromPossiblyIncompleteNumber","stripIddPrefix","applyInternationalSeparatorStyle","checkNumberLength","AsYouType","USE_NON_GEOGRAPHIC_COUNTRY_CODE","MIN_LENGTH_FOR_NSN","CAPTURING_DIGIT_PATTERN","undefined","nationalNumber","object","RFC3966_EXTN_PREFIX","getCountryByCallingCode","country","callingCode","_ref","metadata","DIGIT_PLACEHOLDER","SpanKind","MAX_LENGTH_FOR_NSN","RegExp","regularExpressionText","PatternParser","nationalPhoneNumber","FIRST_GROUP_PATTERN","getSeparatorAfterNationalPrefix","matcher","getCountryCallingCode","concat","format","_classCallCheck","MAX_LENGTH_COUNTRY_CODE","test","useInternationalFormat","input","options","split","countOccurences","a","b","text","state","countryMetadata","getExtensionDigitsPattern","IDDPrefix","optionsOrDefaultCountry","maxLength","formattedNumber","_step","_iterator","done","element","number","parse","replace","ext","extension","internationalFormat","pattern","push","pa","i","getCountryCodesForCallingCode","nationalPrefixForParsing","instructions","slice","filter","match","canFormatCompleteNumber","_createForOfIteratorHelperLoose","nationalSignificantNumber","isPossiblePhoneNumber","extractCountryCallingCodeFromInternationalNumberWithoutPlusSign","defaultCountry","defaultCallingCode","na","sort","selectNumberingPlan","value","PLUS_CHARS","isNaN","indexOf","arguments","length","VALID_DIGITS","count","couldNationalNumberBelongToCountry","Error","allowOverflow","_ref2","prefixMatch","countryCallingCode","VALID_PUNCTUATION","purpose","shouldTryNationalPrefixFormattingRule","matchedGroups","carrierCode","possibleLengths","possibleShorterNumber","result","_this$context$","matchTree","extractCountryCallingCode","_part$split","PhoneNumber","_part$split2","repeat","LONGEST_NATIONAL_PHONE_NUMBER_LENGTH","leadingDigits","_extractNationalNumbe","nationalPrefixFormattingRule","MIN_LENGTH_PHONE_NUMBER_PATTERN","name","string","nationalPrefix","expandSingleElementArray","nationalNumberPattern","search","DOTS","BRACKETS","TILDES","TypeError","getCountryAndCallingCode","env","countryOrCountryCallingCode","onCallingCodeChange","formatNumber","__NEXT_RELATIVE_PROJECT_DIR","_createClass","_this$getCountryAndCa2","checkNumberLengthForType","type","onCountryChange","trim","getCountries","keys","matchesEntirely","possibleShorterNationalNumber","AsYouTypeState","onNationalSignificantNumberChange","reset","isValidNumber","AsYouTypeParser","capturedGroupsCount","numberingPlan","merge","cutAndStripNonPairedParens","nationalPrefixTransformRule","getCountryMetadata","isObject","countryCode","cutBeforeIndex","countries","DEFAULT_OPTIONS","context","_slicedToArray","_extractFormattedDigi","VALID_PHONE_NUMBER_WITH_EXTENSION","tree","last","e164Number","VALID_PHONE_NUMBER","isViablePhoneNumber","stripNonPairedParens","digits","closeNonPairedParens","endContext","cut_before","justLeadingPlus","pop","template","retained_template","startInternationalNumber","resetNationalSignificantNumber","opening_braces","nonGeographical","getContext","characters","join","getNationalDigits","possible_lengths","nationalSignificantNumberIsModified","characterString","v2","phone","_extractCountryCallin","prefixBeforeNationalSignificantNumberThatIsNotNationalPrefix","parsePattern","countryCallingCodeSource","inputDigits","_ref3","shorterNumber","update","properties","hasCallingCode","useNationalPrefixFormattingRule","NON_FIXED_LINE_PHONE_TYPES","_Object$keys","OPERATOR","_i","formatNationalNumberUsingFormat","prefixBeforeNationalNumber","key","isPossibleNumber","international","VALID_PHONE_NUMBER_PATTERN","nonGeographic","extLimitAfterExplicitLabel","initCountryAndCallingCode","formatExtension","explicitExtLabels","possibleCharsAfterExtLabel","optionalExtnSuffix","setCallingCode","index","rightPart","mergeArrays","countryCodes","operator","mobile_type","extLimitAfterAmbiguousChar","formattedNationalNumber","isViablePhoneNumberStart","setCountry","_dangling_braces","before","nextDigits","possibleSeparatorsNumberExtLabelNoComma","autoDiallingAndExtLabelsFound","extLimitAfterLikelyLabel","startContext","possiblePositionOfTheFirstCapturedGroup","isNonGeographicCallingCode","character","formattedOutput","shouldHaveExtractedNationalPrefix","nationalNumberBefore","possibleNationalPrefix","or","nationalNumberAfter","formatter","_iterator2","_step2","hasSelectedNumberingPlan","getPossibleCountries","explicitExtn","ambiguousExtn","americanStyleExtnWithSuffix","autoDiallingExtn","onlyCommasExtn","_this$getContext","position","DIGIT_PLACEHOLDER_MATCHER","branches","parser","reExtractNationalSignificantNumber","getPossibleCountriesForNumber","determineTheCountryIfNeeded","isNumberWithIddPrefix","getMetadata","isArray","appendDigits","fromCountry","addExtension","actual_length","nationalDigits","hasCountry","restCharacters","subtree","isPossibleIncompleteNationalNumber","formatAs","getFullNumber","getNonFormattedNumber","resetFormat","chooseFormatForNumber","overflow","NumberingPlan","isValid","matchedChars","digit","getNumberingPlanMetadata","isValidFormattedNationalNumber","hasExtractedNationalSignificantNumber","populatedNationalNumberTemplate","stateUpdate","availableFormats","partialMatch","_this","countryCallingCodes","isEqual","isWaitingForCountryCallingCode","phoneNumber","matchingFormats","formats","getDigitsWithoutInternationalPrefix","pickFirstMatchingElement","isNANP","leadingDigitsPatterns","JSON","stringify","lastLeadingDigitsPattern","oneOfSet","default","parseOneOfSet","getCountryCodeForCallingCode","getNumberType","formatIDD","_objectSpread","_nationalPrefixForParsing","couldPossiblyExtractAnotherNationalSignificantNumber","COMPLEX_NATIONAL_PREFIX","args","formatCompleteNumber","prevValue","formatInternational","charCodeAt","nextValue","iddPrefix","fromCharCode","extractNationalSignificantNumber","setState","getURI","formatNationalNumber","getCallingCode","values","_len","formattedCompleteNumber","objects","Array","_key","setNationalNumberTemplate","getCountryAndCountryCallingCode","metadataJson","lastIndexOf","isCountryCode","char","elements","testFunction","MINIMAL_MODE","formatNationalNumberWithNextDigits","defaultIDDPrefix","extractAnotherNationalSignificantNumber","prevNationalSignificantNumber","previouslyChosenFormat","chosenFormat","_extractNationalNumbe2","chooseFormat","array","formatNextNationalNumberDigits","_this2","nationalSignificantNumberIndex","leadingDigitsPatternIndex","MIN_LEADING_DIGITS_LENGTH","hasTypes","formatSuits","formatMatches","isCountryCallingCodeAmbiguous","determineTheCountry","isInternational","prefix","v1","getInternationalPrefixBeforeCountryCallingCode","country_phone_code_to_countries","spacing","country_calling_codes","chooseCountryByCountryCallingCode","nationalPrefixIsOptionalWhenFormattingInNationalFormat","getNonFormattedNationalNumberWithPrefix","_this$state","globalMetadataObject","nationalPrefixIsMandatoryWhenFormattingInNationalFormat","call","leadingDigitsPatternsCount","getNonFormattedTemplate","getDefaultCountryMetadataForRegion","Math","min","leadingDigitsPattern","extractIddPrefix","_getFormats","fixMissingPlus","extractCallingCodeAndNationalSignificantNumber","error","console","getNumberValue","map","_this$state2","Format","numberWithoutIDD","_getNationalPrefixFormattingRule","getFormatFormat","callingCode_","_this3","_loop","_extractCountryCallin2","getNumber","_this$state3","newCallingCode","missingPlus","_getCountry","_getNationalPrefixIsOptionalWhenFormatting","types","NON_ALTERING_FORMAT_REG_EXP","createTemplateForFormat","_","ambiguousCountries","_ret","extractFormattedPhoneNumber","exactCountry","getType","Type","VALID_FORMATTED_PHONE_NUMBER_PART","DEFAULT_EXT_PREFIX","hasPlus","AFTER_PHONE_NUMBER_DIGITS_END_PATTERN","_format","isPossible","_extractFormattedDigitsAndPlus","extractedNumber","SUPPORT_LEGACY_FORMATTING_PATTERNS","extractFormattedDigitsAndPlus","_extractFormattedDigi3","_extractFormattedDigi4","VALID_FORMATTED_PHONE_NUMBER_DIGITS_PART_PATTERN","getNationalNumber","formattedDigits","usesNationalPrefix","NATIONAL_PREFIX_SEPARATORS_PATTERN","FIRST_GROUP_ONLY_PREFIX_PATTERN","getChars","getTemplate","internationalPrefix","nationalNumberTemplate","populatedNationalNumberTemplatePosition","validateMetadata","getTemplateForFormat","_ref4","Object","typeOf","CREATE_CHARACTER_CLASS_PATTERN","_typeof","CREATE_STANDALONE_DIGIT_PATTERN","getExtPrefix","LONGEST_DUMMY_PHONE_NUMBER","isSupportedCountry","hasOwnProperty","setVersion","version","v3","v4","nationalNumberDummyDigits","compare","V3","DUMMY_DIGIT","V4","strictPattern","numberFormat","nationalPrefixIncludedInTemplate","numberFormatWithNationalPrefix","parseDigits","populateTemplateWithDigits","_ref5"],"mappings":"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","ignoreList":[0,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41]}