{"version":3,"sources":["turbopack:///[project]/node_modules/jotai/esm/react.mjs","turbopack:///[project]/node_modules/jotai/esm/vanilla/internals.mjs","turbopack:///[project]/node_modules/jotai/esm/vanilla.mjs"],"sourcesContent":["'use client';\nimport React, { createContext, useContext, useRef, createElement, useReducer, useEffect, useDebugValue, useCallback } from 'react';\nimport { getDefaultStore, createStore } from 'jotai/vanilla';\nimport { INTERNAL_registerAbortHandler } from 'jotai/vanilla/internals';\n\nconst StoreContext = createContext(\n  void 0\n);\nfunction useStore(options) {\n  const store = useContext(StoreContext);\n  return (options == null ? void 0 : options.store) || store || getDefaultStore();\n}\nfunction Provider({\n  children,\n  store\n}) {\n  const storeRef = useRef(null);\n  if (store) {\n    return createElement(StoreContext.Provider, { value: store }, children);\n  }\n  if (storeRef.current === null) {\n    storeRef.current = createStore();\n  }\n  return createElement(\n    StoreContext.Provider,\n    {\n      // TODO should we use useState instead?\n      // eslint-disable-next-line react-hooks/refs\n      value: storeRef.current\n    },\n    children\n  );\n}\n\nconst isPromiseLike = (x) => typeof (x == null ? void 0 : x.then) === \"function\";\nconst attachPromiseStatus = (promise) => {\n  if (!promise.status) {\n    promise.status = \"pending\";\n    promise.then(\n      (v) => {\n        promise.status = \"fulfilled\";\n        promise.value = v;\n      },\n      (e) => {\n        promise.status = \"rejected\";\n        promise.reason = e;\n      }\n    );\n  }\n};\nconst use = React.use || // A shim for older React versions\n((promise) => {\n  if (promise.status === \"pending\") {\n    throw promise;\n  } else if (promise.status === \"fulfilled\") {\n    return promise.value;\n  } else if (promise.status === \"rejected\") {\n    throw promise.reason;\n  } else {\n    attachPromiseStatus(promise);\n    throw promise;\n  }\n});\nconst continuablePromiseMap = /* @__PURE__ */ new WeakMap();\nconst createContinuablePromise = (promise, getValue) => {\n  let continuablePromise = continuablePromiseMap.get(promise);\n  if (!continuablePromise) {\n    continuablePromise = new Promise((resolve, reject) => {\n      let curr = promise;\n      const onFulfilled = (me) => (v) => {\n        if (curr === me) {\n          resolve(v);\n        }\n      };\n      const onRejected = (me) => (e) => {\n        if (curr === me) {\n          reject(e);\n        }\n      };\n      const onAbort = () => {\n        try {\n          const nextValue = getValue();\n          if (isPromiseLike(nextValue)) {\n            continuablePromiseMap.set(nextValue, continuablePromise);\n            curr = nextValue;\n            nextValue.then(onFulfilled(nextValue), onRejected(nextValue));\n            INTERNAL_registerAbortHandler(nextValue, onAbort);\n          } else {\n            resolve(nextValue);\n          }\n        } catch (e) {\n          reject(e);\n        }\n      };\n      promise.then(onFulfilled(promise), onRejected(promise));\n      INTERNAL_registerAbortHandler(promise, onAbort);\n    });\n    continuablePromiseMap.set(promise, continuablePromise);\n  }\n  return continuablePromise;\n};\nfunction useAtomValue(atom, options) {\n  const { delay, unstable_promiseStatus: promiseStatus = !React.use } = options || {};\n  const store = useStore(options);\n  const [[valueFromReducer, storeFromReducer, atomFromReducer], rerender] = useReducer(\n    (prev) => {\n      const nextValue = store.get(atom);\n      if (Object.is(prev[0], nextValue) && prev[1] === store && prev[2] === atom) {\n        return prev;\n      }\n      return [nextValue, store, atom];\n    },\n    void 0,\n    () => [store.get(atom), store, atom]\n  );\n  let value = valueFromReducer;\n  if (storeFromReducer !== store || atomFromReducer !== atom) {\n    rerender();\n    value = store.get(atom);\n  }\n  useEffect(() => {\n    const unsub = store.sub(atom, () => {\n      if (promiseStatus) {\n        try {\n          const value2 = store.get(atom);\n          if (isPromiseLike(value2)) {\n            attachPromiseStatus(\n              createContinuablePromise(value2, () => store.get(atom))\n            );\n          }\n        } catch (e) {\n        }\n      }\n      if (typeof delay === \"number\") {\n        setTimeout(rerender, delay);\n        return;\n      }\n      rerender();\n    });\n    rerender();\n    return unsub;\n  }, [store, atom, delay, promiseStatus]);\n  useDebugValue(value);\n  if (isPromiseLike(value)) {\n    const promise = createContinuablePromise(value, () => store.get(atom));\n    if (promiseStatus) {\n      attachPromiseStatus(promise);\n    }\n    return use(promise);\n  }\n  return value;\n}\n\nfunction useSetAtom(atom, options) {\n  const store = useStore(options);\n  const setAtom = useCallback(\n    (...args) => {\n      if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && !(\"write\" in atom)) {\n        throw new Error(\"not writable atom\");\n      }\n      return store.set(atom, ...args);\n    },\n    [store, atom]\n  );\n  return setAtom;\n}\n\nfunction useAtom(atom, options) {\n  return [\n    useAtomValue(atom, options),\n    // We do wrong type assertion here, which results in throwing an error.\n    useSetAtom(atom, options)\n  ];\n}\n\nexport { Provider, useAtom, useAtomValue, useSetAtom, useStore };\n","function hasInitialValue(atom) {\n  return \"init\" in atom;\n}\nfunction isActuallyWritableAtom(atom) {\n  return !!atom.write;\n}\nfunction isAtomStateInitialized(atomState) {\n  return \"v\" in atomState || \"e\" in atomState;\n}\nfunction returnAtomValue(atomState) {\n  if (\"e\" in atomState) {\n    throw atomState.e;\n  }\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && !(\"v\" in atomState)) {\n    throw new Error(\"[Bug] atom state is not initialized\");\n  }\n  return atomState.v;\n}\nconst promiseStateMap = /* @__PURE__ */ new WeakMap();\nfunction isPendingPromise(value) {\n  var _a;\n  return isPromiseLike(value) && !!((_a = promiseStateMap.get(value)) == null ? void 0 : _a[0]);\n}\nfunction abortPromise(promise) {\n  const promiseState = promiseStateMap.get(promise);\n  if (promiseState == null ? void 0 : promiseState[0]) {\n    promiseState[0] = false;\n    promiseState[1].forEach((fn) => fn());\n  }\n}\nfunction registerAbortHandler(promise, abortHandler) {\n  let promiseState = promiseStateMap.get(promise);\n  if (!promiseState) {\n    promiseState = [true, /* @__PURE__ */ new Set()];\n    promiseStateMap.set(promise, promiseState);\n    const settle = () => {\n      promiseState[0] = false;\n    };\n    promise.then(settle, settle);\n  }\n  promiseState[1].add(abortHandler);\n}\nfunction isPromiseLike(p) {\n  return typeof (p == null ? void 0 : p.then) === \"function\";\n}\nfunction addPendingPromiseToDependency(atom, promise, dependencyAtomState) {\n  if (!dependencyAtomState.p.has(atom)) {\n    dependencyAtomState.p.add(atom);\n    const cleanup = () => dependencyAtomState.p.delete(atom);\n    promise.then(cleanup, cleanup);\n  }\n}\nfunction getMountedOrPendingDependents(atom, atomState, mountedMap) {\n  var _a;\n  const dependents = /* @__PURE__ */ new Set();\n  for (const a of ((_a = mountedMap.get(atom)) == null ? void 0 : _a.t) || []) {\n    if (mountedMap.has(a)) {\n      dependents.add(a);\n    }\n  }\n  for (const atomWithPendingPromise of atomState.p) {\n    dependents.add(atomWithPendingPromise);\n  }\n  return dependents;\n}\nconst createStoreHook = () => {\n  const callbacks = /* @__PURE__ */ new Set();\n  const notify = () => callbacks.forEach((fn) => fn());\n  notify.add = (fn) => {\n    callbacks.add(fn);\n    return () => callbacks.delete(fn);\n  };\n  return notify;\n};\nconst createStoreHookForAtoms = () => {\n  const all = {};\n  const callbacks = /* @__PURE__ */ new WeakMap();\n  const notify = (atom) => {\n    var _a, _b;\n    (_a = callbacks.get(all)) == null ? void 0 : _a.forEach((fn) => fn(atom));\n    (_b = callbacks.get(atom)) == null ? void 0 : _b.forEach((fn) => fn());\n  };\n  notify.add = (atom, fn) => {\n    const key = atom || all;\n    const fns = (callbacks.has(key) ? callbacks : callbacks.set(key, /* @__PURE__ */ new Set())).get(key);\n    fns.add(fn);\n    return () => {\n      fns == null ? void 0 : fns.delete(fn);\n      if (!fns.size) {\n        callbacks.delete(key);\n      }\n    };\n  };\n  return notify;\n};\nfunction initializeStoreHooks(storeHooks) {\n  storeHooks.r || (storeHooks.r = createStoreHookForAtoms());\n  storeHooks.c || (storeHooks.c = createStoreHookForAtoms());\n  storeHooks.m || (storeHooks.m = createStoreHookForAtoms());\n  storeHooks.u || (storeHooks.u = createStoreHookForAtoms());\n  storeHooks.f || (storeHooks.f = createStoreHook());\n  return storeHooks;\n}\nconst atomRead = (_store, atom, ...params) => atom.read(...params);\nconst atomWrite = (_store, atom, ...params) => atom.write(...params);\nconst atomOnInit = (store, atom) => {\n  var _a;\n  return (_a = atom.unstable_onInit) == null ? void 0 : _a.call(atom, store);\n};\nconst atomOnMount = (_store, atom, setAtom) => {\n  var _a;\n  return (_a = atom.onMount) == null ? void 0 : _a.call(atom, setAtom);\n};\nconst ensureAtomState = (store, atom) => {\n  const buildingBlocks = getInternalBuildingBlocks(store);\n  const atomStateMap = buildingBlocks[0];\n  const atomOnInit2 = buildingBlocks[9];\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && !atom) {\n    throw new Error(\"Atom is undefined or null\");\n  }\n  let atomState = atomStateMap.get(atom);\n  if (!atomState) {\n    atomState = { d: /* @__PURE__ */ new Map(), p: /* @__PURE__ */ new Set(), n: 0 };\n    atomStateMap.set(atom, atomState);\n    atomOnInit2 == null ? void 0 : atomOnInit2(store, atom);\n  }\n  return atomState;\n};\nconst flushCallbacks = (store) => {\n  const buildingBlocks = getInternalBuildingBlocks(store);\n  const mountedMap = buildingBlocks[1];\n  const changedAtoms = buildingBlocks[3];\n  const mountCallbacks = buildingBlocks[4];\n  const unmountCallbacks = buildingBlocks[5];\n  const storeHooks = buildingBlocks[6];\n  const recomputeInvalidatedAtoms2 = buildingBlocks[13];\n  const errors = [];\n  const call = (fn) => {\n    try {\n      fn();\n    } catch (e) {\n      errors.push(e);\n    }\n  };\n  do {\n    if (storeHooks.f) {\n      call(storeHooks.f);\n    }\n    const callbacks = /* @__PURE__ */ new Set();\n    const add = callbacks.add.bind(callbacks);\n    changedAtoms.forEach((atom) => {\n      var _a;\n      return (_a = mountedMap.get(atom)) == null ? void 0 : _a.l.forEach(add);\n    });\n    changedAtoms.clear();\n    unmountCallbacks.forEach(add);\n    unmountCallbacks.clear();\n    mountCallbacks.forEach(add);\n    mountCallbacks.clear();\n    callbacks.forEach(call);\n    if (changedAtoms.size) {\n      recomputeInvalidatedAtoms2(store);\n    }\n  } while (changedAtoms.size || unmountCallbacks.size || mountCallbacks.size);\n  if (errors.length) {\n    throw new AggregateError(errors);\n  }\n};\nconst recomputeInvalidatedAtoms = (store) => {\n  const buildingBlocks = getInternalBuildingBlocks(store);\n  const mountedMap = buildingBlocks[1];\n  const invalidatedAtoms = buildingBlocks[2];\n  const changedAtoms = buildingBlocks[3];\n  const ensureAtomState2 = buildingBlocks[11];\n  const readAtomState2 = buildingBlocks[14];\n  const mountDependencies2 = buildingBlocks[17];\n  const topSortedReversed = [];\n  const visiting = /* @__PURE__ */ new WeakSet();\n  const visited = /* @__PURE__ */ new WeakSet();\n  const stack = Array.from(changedAtoms);\n  while (stack.length) {\n    const a = stack[stack.length - 1];\n    const aState = ensureAtomState2(store, a);\n    if (visited.has(a)) {\n      stack.pop();\n      continue;\n    }\n    if (visiting.has(a)) {\n      if (invalidatedAtoms.get(a) === aState.n) {\n        topSortedReversed.push([a, aState]);\n      } else if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && invalidatedAtoms.has(a)) {\n        throw new Error(\"[Bug] invalidated atom exists\");\n      }\n      visited.add(a);\n      stack.pop();\n      continue;\n    }\n    visiting.add(a);\n    for (const d of getMountedOrPendingDependents(a, aState, mountedMap)) {\n      if (!visiting.has(d)) {\n        stack.push(d);\n      }\n    }\n  }\n  for (let i = topSortedReversed.length - 1; i >= 0; --i) {\n    const [a, aState] = topSortedReversed[i];\n    let hasChangedDeps = false;\n    for (const dep of aState.d.keys()) {\n      if (dep !== a && changedAtoms.has(dep)) {\n        hasChangedDeps = true;\n        break;\n      }\n    }\n    if (hasChangedDeps) {\n      readAtomState2(store, a);\n      mountDependencies2(store, a);\n    }\n    invalidatedAtoms.delete(a);\n  }\n};\nconst readAtomState = (store, atom) => {\n  var _a, _b;\n  const buildingBlocks = getInternalBuildingBlocks(store);\n  const mountedMap = buildingBlocks[1];\n  const invalidatedAtoms = buildingBlocks[2];\n  const changedAtoms = buildingBlocks[3];\n  const storeHooks = buildingBlocks[6];\n  const atomRead2 = buildingBlocks[7];\n  const ensureAtomState2 = buildingBlocks[11];\n  const flushCallbacks2 = buildingBlocks[12];\n  const recomputeInvalidatedAtoms2 = buildingBlocks[13];\n  const readAtomState2 = buildingBlocks[14];\n  const writeAtomState2 = buildingBlocks[16];\n  const mountDependencies2 = buildingBlocks[17];\n  const atomState = ensureAtomState2(store, atom);\n  if (isAtomStateInitialized(atomState)) {\n    if (mountedMap.has(atom) && invalidatedAtoms.get(atom) !== atomState.n) {\n      return atomState;\n    }\n    if (Array.from(atomState.d).every(\n      ([a, n]) => (\n        // Recursively, read the atom state of the dependency, and\n        // check if the atom epoch number is unchanged\n        readAtomState2(store, a).n === n\n      )\n    )) {\n      return atomState;\n    }\n  }\n  atomState.d.clear();\n  let isSync = true;\n  function mountDependenciesIfAsync() {\n    if (mountedMap.has(atom)) {\n      mountDependencies2(store, atom);\n      recomputeInvalidatedAtoms2(store);\n      flushCallbacks2(store);\n    }\n  }\n  function getter(a) {\n    var _a2;\n    if (a === atom) {\n      const aState2 = ensureAtomState2(store, a);\n      if (!isAtomStateInitialized(aState2)) {\n        if (hasInitialValue(a)) {\n          setAtomStateValueOrPromise(store, a, a.init);\n        } else {\n          throw new Error(\"no atom init\");\n        }\n      }\n      return returnAtomValue(aState2);\n    }\n    const aState = readAtomState2(store, a);\n    try {\n      return returnAtomValue(aState);\n    } finally {\n      atomState.d.set(a, aState.n);\n      if (isPendingPromise(atomState.v)) {\n        addPendingPromiseToDependency(atom, atomState.v, aState);\n      }\n      (_a2 = mountedMap.get(a)) == null ? void 0 : _a2.t.add(atom);\n      if (!isSync) {\n        mountDependenciesIfAsync();\n      }\n    }\n  }\n  let controller;\n  let setSelf;\n  const options = {\n    get signal() {\n      if (!controller) {\n        controller = new AbortController();\n      }\n      return controller.signal;\n    },\n    get setSelf() {\n      if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && !isActuallyWritableAtom(atom)) {\n        console.warn(\"setSelf function cannot be used with read-only atom\");\n      }\n      if (!setSelf && isActuallyWritableAtom(atom)) {\n        setSelf = (...args) => {\n          if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && isSync) {\n            console.warn(\"setSelf function cannot be called in sync\");\n          }\n          if (!isSync) {\n            try {\n              return writeAtomState2(store, atom, ...args);\n            } finally {\n              recomputeInvalidatedAtoms2(store);\n              flushCallbacks2(store);\n            }\n          }\n        };\n      }\n      return setSelf;\n    }\n  };\n  const prevEpochNumber = atomState.n;\n  try {\n    const valueOrPromise = atomRead2(store, atom, getter, options);\n    setAtomStateValueOrPromise(store, atom, valueOrPromise);\n    if (isPromiseLike(valueOrPromise)) {\n      registerAbortHandler(valueOrPromise, () => controller == null ? void 0 : controller.abort());\n      valueOrPromise.then(mountDependenciesIfAsync, mountDependenciesIfAsync);\n    }\n    (_a = storeHooks.r) == null ? void 0 : _a.call(storeHooks, atom);\n    return atomState;\n  } catch (error) {\n    delete atomState.v;\n    atomState.e = error;\n    ++atomState.n;\n    return atomState;\n  } finally {\n    isSync = false;\n    if (prevEpochNumber !== atomState.n && invalidatedAtoms.get(atom) === prevEpochNumber) {\n      invalidatedAtoms.set(atom, atomState.n);\n      changedAtoms.add(atom);\n      (_b = storeHooks.c) == null ? void 0 : _b.call(storeHooks, atom);\n    }\n  }\n};\nconst invalidateDependents = (store, atom) => {\n  const buildingBlocks = getInternalBuildingBlocks(store);\n  const mountedMap = buildingBlocks[1];\n  const invalidatedAtoms = buildingBlocks[2];\n  const ensureAtomState2 = buildingBlocks[11];\n  const stack = [atom];\n  while (stack.length) {\n    const a = stack.pop();\n    const aState = ensureAtomState2(store, a);\n    for (const d of getMountedOrPendingDependents(a, aState, mountedMap)) {\n      const dState = ensureAtomState2(store, d);\n      invalidatedAtoms.set(d, dState.n);\n      stack.push(d);\n    }\n  }\n};\nconst writeAtomState = (store, atom, ...args) => {\n  const buildingBlocks = getInternalBuildingBlocks(store);\n  const changedAtoms = buildingBlocks[3];\n  const storeHooks = buildingBlocks[6];\n  const atomWrite2 = buildingBlocks[8];\n  const ensureAtomState2 = buildingBlocks[11];\n  const flushCallbacks2 = buildingBlocks[12];\n  const recomputeInvalidatedAtoms2 = buildingBlocks[13];\n  const readAtomState2 = buildingBlocks[14];\n  const invalidateDependents2 = buildingBlocks[15];\n  const mountDependencies2 = buildingBlocks[17];\n  let isSync = true;\n  const getter = (a) => returnAtomValue(readAtomState2(store, a));\n  const setter = (a, ...args2) => {\n    var _a;\n    const aState = ensureAtomState2(store, a);\n    try {\n      if (a === atom) {\n        if (!hasInitialValue(a)) {\n          throw new Error(\"atom not writable\");\n        }\n        const prevEpochNumber = aState.n;\n        const v = args2[0];\n        setAtomStateValueOrPromise(store, a, v);\n        mountDependencies2(store, a);\n        if (prevEpochNumber !== aState.n) {\n          changedAtoms.add(a);\n          (_a = storeHooks.c) == null ? void 0 : _a.call(storeHooks, a);\n          invalidateDependents2(store, a);\n        }\n        return void 0;\n      } else {\n        return writeAtomState(store, a, ...args2);\n      }\n    } finally {\n      if (!isSync) {\n        recomputeInvalidatedAtoms2(store);\n        flushCallbacks2(store);\n      }\n    }\n  };\n  try {\n    return atomWrite2(store, atom, getter, setter, ...args);\n  } finally {\n    isSync = false;\n  }\n};\nconst mountDependencies = (store, atom) => {\n  var _a;\n  const buildingBlocks = getInternalBuildingBlocks(store);\n  const mountedMap = buildingBlocks[1];\n  const changedAtoms = buildingBlocks[3];\n  const storeHooks = buildingBlocks[6];\n  const ensureAtomState2 = buildingBlocks[11];\n  const invalidateDependents2 = buildingBlocks[15];\n  const mountAtom2 = buildingBlocks[18];\n  const unmountAtom2 = buildingBlocks[19];\n  const atomState = ensureAtomState2(store, atom);\n  const mounted = mountedMap.get(atom);\n  if (mounted && !isPendingPromise(atomState.v)) {\n    for (const [a, n] of atomState.d) {\n      if (!mounted.d.has(a)) {\n        const aState = ensureAtomState2(store, a);\n        const aMounted = mountAtom2(store, a);\n        aMounted.t.add(atom);\n        mounted.d.add(a);\n        if (n !== aState.n) {\n          changedAtoms.add(a);\n          (_a = storeHooks.c) == null ? void 0 : _a.call(storeHooks, a);\n          invalidateDependents2(store, a);\n        }\n      }\n    }\n    for (const a of mounted.d || []) {\n      if (!atomState.d.has(a)) {\n        mounted.d.delete(a);\n        const aMounted = unmountAtom2(store, a);\n        aMounted == null ? void 0 : aMounted.t.delete(atom);\n      }\n    }\n  }\n};\nconst mountAtom = (store, atom) => {\n  var _a;\n  const buildingBlocks = getInternalBuildingBlocks(store);\n  const mountedMap = buildingBlocks[1];\n  const mountCallbacks = buildingBlocks[4];\n  const storeHooks = buildingBlocks[6];\n  const atomOnMount2 = buildingBlocks[10];\n  const ensureAtomState2 = buildingBlocks[11];\n  const flushCallbacks2 = buildingBlocks[12];\n  const recomputeInvalidatedAtoms2 = buildingBlocks[13];\n  const readAtomState2 = buildingBlocks[14];\n  const writeAtomState2 = buildingBlocks[16];\n  const atomState = ensureAtomState2(store, atom);\n  let mounted = mountedMap.get(atom);\n  if (!mounted) {\n    readAtomState2(store, atom);\n    for (const a of atomState.d.keys()) {\n      const aMounted = mountAtom(store, a);\n      aMounted.t.add(atom);\n    }\n    mounted = {\n      l: /* @__PURE__ */ new Set(),\n      d: new Set(atomState.d.keys()),\n      t: /* @__PURE__ */ new Set()\n    };\n    mountedMap.set(atom, mounted);\n    (_a = storeHooks.m) == null ? void 0 : _a.call(storeHooks, atom);\n    if (isActuallyWritableAtom(atom)) {\n      const processOnMount = () => {\n        let isSync = true;\n        const setAtom = (...args) => {\n          try {\n            return writeAtomState2(store, atom, ...args);\n          } finally {\n            if (!isSync) {\n              recomputeInvalidatedAtoms2(store);\n              flushCallbacks2(store);\n            }\n          }\n        };\n        try {\n          const onUnmount = atomOnMount2(store, atom, setAtom);\n          if (onUnmount) {\n            mounted.u = () => {\n              isSync = true;\n              try {\n                onUnmount();\n              } finally {\n                isSync = false;\n              }\n            };\n          }\n        } finally {\n          isSync = false;\n        }\n      };\n      mountCallbacks.add(processOnMount);\n    }\n  }\n  return mounted;\n};\nconst unmountAtom = (store, atom) => {\n  var _a;\n  const buildingBlocks = getInternalBuildingBlocks(store);\n  const mountedMap = buildingBlocks[1];\n  const unmountCallbacks = buildingBlocks[5];\n  const storeHooks = buildingBlocks[6];\n  const ensureAtomState2 = buildingBlocks[11];\n  const unmountAtom2 = buildingBlocks[19];\n  const atomState = ensureAtomState2(store, atom);\n  let mounted = mountedMap.get(atom);\n  if (mounted && !mounted.l.size && !Array.from(mounted.t).some((a) => {\n    var _a2;\n    return (_a2 = mountedMap.get(a)) == null ? void 0 : _a2.d.has(atom);\n  })) {\n    if (mounted.u) {\n      unmountCallbacks.add(mounted.u);\n    }\n    mounted = void 0;\n    mountedMap.delete(atom);\n    (_a = storeHooks.u) == null ? void 0 : _a.call(storeHooks, atom);\n    for (const a of atomState.d.keys()) {\n      const aMounted = unmountAtom2(store, a);\n      aMounted == null ? void 0 : aMounted.t.delete(atom);\n    }\n    return void 0;\n  }\n  return mounted;\n};\nconst setAtomStateValueOrPromise = (store, atom, valueOrPromise) => {\n  const ensureAtomState2 = getInternalBuildingBlocks(store)[11];\n  const atomState = ensureAtomState2(store, atom);\n  const hasPrevValue = \"v\" in atomState;\n  const prevValue = atomState.v;\n  if (isPromiseLike(valueOrPromise)) {\n    for (const a of atomState.d.keys()) {\n      addPendingPromiseToDependency(\n        atom,\n        valueOrPromise,\n        ensureAtomState2(store, a)\n      );\n    }\n  }\n  atomState.v = valueOrPromise;\n  delete atomState.e;\n  if (!hasPrevValue || !Object.is(prevValue, atomState.v)) {\n    ++atomState.n;\n    if (isPromiseLike(prevValue)) {\n      abortPromise(prevValue);\n    }\n  }\n};\nconst storeGet = (store, atom) => {\n  const readAtomState2 = getInternalBuildingBlocks(store)[14];\n  return returnAtomValue(readAtomState2(store, atom));\n};\nconst storeSet = (store, atom, ...args) => {\n  const buildingBlocks = getInternalBuildingBlocks(store);\n  const flushCallbacks2 = buildingBlocks[12];\n  const recomputeInvalidatedAtoms2 = buildingBlocks[13];\n  const writeAtomState2 = buildingBlocks[16];\n  try {\n    return writeAtomState2(store, atom, ...args);\n  } finally {\n    recomputeInvalidatedAtoms2(store);\n    flushCallbacks2(store);\n  }\n};\nconst storeSub = (store, atom, listener) => {\n  const buildingBlocks = getInternalBuildingBlocks(store);\n  const flushCallbacks2 = buildingBlocks[12];\n  const mountAtom2 = buildingBlocks[18];\n  const unmountAtom2 = buildingBlocks[19];\n  const mounted = mountAtom2(store, atom);\n  const listeners = mounted.l;\n  listeners.add(listener);\n  flushCallbacks2(store);\n  return () => {\n    listeners.delete(listener);\n    unmountAtom2(store, atom);\n    flushCallbacks2(store);\n  };\n};\nconst buildingBlockMap = /* @__PURE__ */ new WeakMap();\nconst getInternalBuildingBlocks = (store) => {\n  const buildingBlocks = buildingBlockMap.get(store);\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && !buildingBlocks) {\n    throw new Error(\n      \"Store must be created by buildStore to read its building blocks\"\n    );\n  }\n  return buildingBlocks;\n};\nfunction getBuildingBlocks(store) {\n  const buildingBlocks = getInternalBuildingBlocks(store);\n  const enhanceBuildingBlocks = buildingBlocks[24];\n  if (enhanceBuildingBlocks) {\n    return enhanceBuildingBlocks(buildingBlocks);\n  }\n  return buildingBlocks;\n}\nfunction buildStore(...buildArgs) {\n  const store = {\n    get(atom) {\n      const storeGet2 = getInternalBuildingBlocks(store)[21];\n      return storeGet2(store, atom);\n    },\n    set(atom, ...args) {\n      const storeSet2 = getInternalBuildingBlocks(store)[22];\n      return storeSet2(store, atom, ...args);\n    },\n    sub(atom, listener) {\n      const storeSub2 = getInternalBuildingBlocks(store)[23];\n      return storeSub2(store, atom, listener);\n    }\n  };\n  const buildingBlocks = [\n    // store state\n    /* @__PURE__ */ new WeakMap(),\n    // atomStateMap\n    /* @__PURE__ */ new WeakMap(),\n    // mountedMap\n    /* @__PURE__ */ new WeakMap(),\n    // invalidatedAtoms\n    /* @__PURE__ */ new Set(),\n    // changedAtoms\n    /* @__PURE__ */ new Set(),\n    // mountCallbacks\n    /* @__PURE__ */ new Set(),\n    // unmountCallbacks\n    {},\n    // storeHooks\n    // atom interceptors\n    atomRead,\n    atomWrite,\n    atomOnInit,\n    atomOnMount,\n    // building-block functions\n    ensureAtomState,\n    flushCallbacks,\n    recomputeInvalidatedAtoms,\n    readAtomState,\n    invalidateDependents,\n    writeAtomState,\n    mountDependencies,\n    mountAtom,\n    unmountAtom,\n    setAtomStateValueOrPromise,\n    storeGet,\n    storeSet,\n    storeSub,\n    void 0\n  ].map((fn, i) => buildArgs[i] || fn);\n  buildingBlockMap.set(store, Object.freeze(buildingBlocks));\n  return store;\n}\n\nexport { abortPromise as INTERNAL_abortPromise, addPendingPromiseToDependency as INTERNAL_addPendingPromiseToDependency, buildStore as INTERNAL_buildStoreRev2, getBuildingBlocks as INTERNAL_getBuildingBlocksRev2, getMountedOrPendingDependents as INTERNAL_getMountedOrPendingDependents, hasInitialValue as INTERNAL_hasInitialValue, initializeStoreHooks as INTERNAL_initializeStoreHooksRev2, isActuallyWritableAtom as INTERNAL_isActuallyWritableAtom, isAtomStateInitialized as INTERNAL_isAtomStateInitialized, isPendingPromise as INTERNAL_isPendingPromise, isPromiseLike as INTERNAL_isPromiseLike, promiseStateMap as INTERNAL_promiseStateMap, registerAbortHandler as INTERNAL_registerAbortHandler, returnAtomValue as INTERNAL_returnAtomValue };\n","import { INTERNAL_buildStoreRev2 } from 'jotai/vanilla/internals';\n\nlet keyCount = 0;\nfunction atom(read, write) {\n  const key = `atom${++keyCount}`;\n  const config = {\n    toString() {\n      return (import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && this.debugLabel ? key + \":\" + this.debugLabel : key;\n    }\n  };\n  if (typeof read === \"function\") {\n    config.read = read;\n  } else {\n    config.init = read;\n    config.read = defaultRead;\n    config.write = defaultWrite;\n  }\n  if (write) {\n    config.write = write;\n  }\n  return config;\n}\nfunction defaultRead(get) {\n  return get(this);\n}\nfunction defaultWrite(get, set, arg) {\n  return set(\n    this,\n    typeof arg === \"function\" ? arg(get(this)) : arg\n  );\n}\n\nlet overiddenCreateStore;\nfunction INTERNAL_overrideCreateStore(fn) {\n  overiddenCreateStore = fn(overiddenCreateStore);\n}\nfunction createStore() {\n  if (overiddenCreateStore) {\n    return overiddenCreateStore();\n  }\n  return INTERNAL_buildStoreRev2();\n}\nlet defaultStore;\nfunction getDefaultStore() {\n  if (!defaultStore) {\n    defaultStore = createStore();\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      globalThis.__JOTAI_DEFAULT_STORE__ || (globalThis.__JOTAI_DEFAULT_STORE__ = defaultStore);\n      if (globalThis.__JOTAI_DEFAULT_STORE__ !== defaultStore) {\n        console.warn(\n          \"Detected multiple Jotai instances. It may cause unexpected behavior with the default store. https://github.com/pmndrs/jotai/discussions/2044\"\n        );\n      }\n    }\n  }\n  return defaultStore;\n}\n\nexport { INTERNAL_overrideCreateStore, atom, createStore, getDefaultStore };\n"],"names":[],"mappings":"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","ignoreList":[0,1,2]}