{"version":3,"sources":["turbopack:///[project]/src/hooks/use-is-client.ts","turbopack:///[project]/node_modules/libphonenumber-js/source/helpers/isObject.js","turbopack:///[project]/node_modules/libphonenumber-js/source/helpers/getCountryByCallingCode.js","turbopack:///[project]/node_modules/libphonenumber-js/source/helpers/extractCountryCallingCode.js","turbopack:///[project]/node_modules/libphonenumber-js/source/formatIncompletePhoneNumber.js","turbopack:///[project]/node_modules/libphonenumber-js/source/isPossible.js","turbopack:///[project]/node_modules/libphonenumber-js/source/helpers/formatNationalNumberUsingFormat.js","turbopack:///[project]/node_modules/libphonenumber-js/source/helpers/extractNationalNumber.js","turbopack:///[project]/node_modules/libphonenumber-js/source/helpers/getIddPrefix.js","turbopack:///[project]/node_modules/libphonenumber-js/source/isValid.js","turbopack:///[project]/node_modules/libphonenumber-js/source/helpers/stripIddPrefix.js","turbopack:///[project]/node_modules/libphonenumber-js/source/helpers/extractCountryCallingCodeFromInternationalNumberWithoutPlusSign.js","turbopack:///[project]/node_modules/libphonenumber-js/source/helpers/checkNumberLength.js","turbopack:///[project]/node_modules/libphonenumber-js/source/AsYouTypeFormatter.complete.js","turbopack:///[project]/node_modules/libphonenumber-js/source/helpers/getPossibleCountriesForNumber.js","turbopack:///[project]/node_modules/libphonenumber-js/source/constants.js","turbopack:///[project]/src/utils/string.ts","turbopack:///[project]/src/features/profile/components/overview/intro-item.tsx","turbopack:///[project]/src/lib/libphonenumber.ts","turbopack:///[project]/node_modules/libphonenumber-js/source/helpers/extension/createExtensionPattern.js","turbopack:///[project]/node_modules/libphonenumber-js/source/helpers/getNumberType.js","turbopack:///[project]/node_modules/libphonenumber-js/source/helpers/getCountryByNationalNumber.js","turbopack:///[project]/node_modules/libphonenumber-js/source/AsYouTypeFormatter.util.js","turbopack:///[project]/node_modules/libphonenumber-js/source/helpers/matchesEntirely.js","turbopack:///[project]/node_modules/libphonenumber-js/source/AsYouTypeFormatter.PatternParser.js","turbopack:///[project]/node_modules/libphonenumber-js/source/format.js","turbopack:///[project]/node_modules/libphonenumber-js/source/metadata.js","turbopack:///[project]/node_modules/libphonenumber-js/source/tools/semver-compare.js","turbopack:///[project]/node_modules/libphonenumber-js/source/helpers/mergeArrays.js","turbopack:///[project]/node_modules/libphonenumber-js/source/helpers/parseDigits.js","turbopack:///[project]/node_modules/libphonenumber-js/source/PhoneNumber.js","turbopack:///[project]/node_modules/libphonenumber-js/source/AsYouTypeFormatter.js","turbopack:///[project]/node_modules/libphonenumber-js/source/AsYouTypeFormatter.PatternMatcher.js","turbopack:///[project]/node_modules/libphonenumber-js/source/AsYouTypeParser.js","turbopack:///[project]/node_modules/libphonenumber-js/source/helpers/extractNationalNumberFromPossiblyIncompleteNumber.js","turbopack:///[project]/node_modules/libphonenumber-js/source/AsYouType.js","turbopack:///[project]/node_modules/libphonenumber-js/source/helpers/RFC3966.js","turbopack:///[project]/node_modules/libphonenumber-js/source/helpers/isViablePhoneNumber.js","turbopack:///[project]/node_modules/libphonenumber-js/source/AsYouTypeState.js","turbopack:///[project]/node_modules/libphonenumber-js/source/helpers/applyInternationalSeparatorStyle.js","turbopack:///[project]/src/features/profile/components/overview/email-item.tsx","turbopack:///[project]/node_modules/lucide-react/src/icons/mail.ts","turbopack:///[project]/src/features/profile/components/overview/phone-item.tsx","turbopack:///[project]/node_modules/lucide-react/src/icons/phone.ts","turbopack:///[project]/src/registry/flip-sentences/flip-sentences.tsx","turbopack:///[project]/src/features/profile/components/verified-button.tsx","turbopack:///[project]/src/features/profile/components/verified-icon2.tsx"],"sourcesContent":["import { useEffect, useState } from \"react\";\n\nexport function useIsClient() {\n  const [isClient, setIsClient] = useState(false);\n\n  useEffect(() => {\n    setIsClient(true);\n  }, []);\n\n  return isClient;\n}\n","const objectConstructor = {}.constructor;\r\n\r\nexport default function isObject(object) {\r\n  return object !== undefined && object !== null && object.constructor === objectConstructor;\r\n}\r\n","import getCountryByNationalNumber from './getCountryByNationalNumber.js'\r\n\r\nconst USE_NON_GEOGRAPHIC_COUNTRY_CODE = false\r\n\r\n// Returns the exact country for the `nationalNumber`\r\n// that belongs to the specified \"country calling code\".\r\nexport default function getCountryByCallingCode(callingCode, {\r\n\tnationalNumber: nationalPhoneNumber,\r\n\tmetadata\r\n}) {\r\n\t/* istanbul ignore if */\r\n\tif (USE_NON_GEOGRAPHIC_COUNTRY_CODE) {\r\n\t\tif (metadata.isNonGeographicCallingCode(callingCode)) {\r\n\t\t\treturn '001'\r\n\t\t}\r\n\t}\r\n\tconst possibleCountries = metadata.getCountryCodesForCallingCode(callingCode)\r\n\tif (!possibleCountries) {\r\n\t\treturn\r\n\t}\r\n\t// If there's just one country corresponding to the country code,\r\n\t// then just return it, without further phone number digits validation.\r\n\tif (possibleCountries.length === 1) {\r\n\t\treturn possibleCountries[0]\r\n\t}\r\n\treturn getCountryByNationalNumber(nationalPhoneNumber, {\r\n\t\tcountries: possibleCountries,\r\n\t\tmetadata: metadata.metadata\r\n\t})\r\n}","import stripIddPrefix from './stripIddPrefix.js'\r\nimport extractCountryCallingCodeFromInternationalNumberWithoutPlusSign from './extractCountryCallingCodeFromInternationalNumberWithoutPlusSign.js'\r\nimport Metadata from '../metadata.js'\r\nimport { MAX_LENGTH_COUNTRY_CODE } from '../constants.js'\r\n\r\n/**\r\n * Converts a phone number digits (possibly with a `+`)\r\n * into a calling code and the rest phone number digits.\r\n * The \"rest phone number digits\" could include\r\n * a national prefix, carrier code, and national\r\n * (significant) number.\r\n * @param  {string} number — Phone number digits (possibly with a `+`).\r\n * @param  {string} [country] — Country.\r\n * @param  {string} [defaultCountry] — Default country.\r\n * @param  {string} [defaultCallingCode] — Default calling code (some phone numbering plans are non-geographic).\r\n * @param  {object} metadata\r\n * @return {object} `{ countryCallingCodeSource: string?, countryCallingCode: string?, number: string }`\r\n * @example\r\n * // Returns `{ countryCallingCode: \"1\", number: \"2133734253\" }`.\r\n * extractCountryCallingCode('2133734253', null, 'US', null, metadata)\r\n * extractCountryCallingCode('2133734253', null, null, '1', metadata)\r\n * extractCountryCallingCode('+12133734253', null, null, null, metadata)\r\n * extractCountryCallingCode('+12133734253', null, 'RU', null, metadata)\r\n */\r\nexport default function extractCountryCallingCode(\r\n\tnumber,\r\n\tcountry,\r\n\tdefaultCountry,\r\n\tdefaultCallingCode,\r\n\tmetadata\r\n) {\r\n\tif (!number) {\r\n\t\treturn {}\r\n\t}\r\n\r\n\tlet isNumberWithIddPrefix\r\n\r\n\t// If this is not an international phone number,\r\n\t// then either extract an \"IDD\" prefix, or extract a\r\n\t// country calling code from a number by autocorrecting it\r\n\t// by prepending a leading `+` in cases when it starts\r\n\t// with the country calling code.\r\n\t// https://wikitravel.org/en/International_dialling_prefix\r\n\t// https://github.com/catamphetamine/libphonenumber-js/issues/376\r\n\tif (number[0] !== '+') {\r\n\t\t// Convert an \"out-of-country\" dialing phone number\r\n\t\t// to a proper international phone number.\r\n\t\tconst numberWithoutIDD = stripIddPrefix(number, country || defaultCountry, defaultCallingCode, metadata)\r\n\t\t// If an IDD prefix was stripped then\r\n\t\t// convert the number to international one\r\n\t\t// for subsequent parsing.\r\n\t\tif (numberWithoutIDD && numberWithoutIDD !== number) {\r\n\t\t\tisNumberWithIddPrefix = true\r\n\t\t\tnumber = '+' + numberWithoutIDD\r\n\t\t} else {\r\n\t\t\t// Check to see if the number starts with the country calling code\r\n\t\t\t// for the default country. If so, we remove the country calling code,\r\n\t\t\t// and do some checks on the validity of the number before and after.\r\n\t\t\t// https://github.com/catamphetamine/libphonenumber-js/issues/376\r\n\t\t\tif (country || defaultCountry || defaultCallingCode) {\r\n\t\t\t\tconst {\r\n\t\t\t\t\tcountryCallingCode,\r\n\t\t\t\t\tnumber: shorterNumber\r\n\t\t\t\t} = extractCountryCallingCodeFromInternationalNumberWithoutPlusSign(\r\n\t\t\t\t\tnumber,\r\n\t\t\t\t\tcountry,\r\n\t\t\t\t\tdefaultCountry,\r\n\t\t\t\t\tdefaultCallingCode,\r\n\t\t\t\t\tmetadata\r\n\t\t\t\t)\r\n\t\t\t\tif (countryCallingCode) {\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\tcountryCallingCodeSource: 'FROM_NUMBER_WITHOUT_PLUS_SIGN',\r\n\t\t\t\t\t\tcountryCallingCode,\r\n\t\t\t\t\t\tnumber: shorterNumber\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn {\r\n\t\t\t\t// No need to set it to `UNSPECIFIED`. It can be just `undefined`.\r\n\t\t\t\t// countryCallingCodeSource: 'UNSPECIFIED',\r\n\t\t\t\tnumber\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// `number` can only be international at this point.\r\n\r\n\t// Fast abortion: country codes do not begin with a '0'\r\n\tif (number[1] === '0') {\r\n\t\treturn {}\r\n\t}\r\n\r\n\tmetadata = new Metadata(metadata)\r\n\r\n\t// The thing with country phone codes\r\n\t// is that they are orthogonal to each other\r\n\t// i.e. there's no such country phone code A\r\n\t// for which country phone code B exists\r\n\t// where B starts with A.\r\n\t// Therefore, while scanning digits,\r\n\t// if a valid country code is found,\r\n\t// that means that it is the country code.\r\n\t//\r\n\tlet i = 2\r\n\twhile (i - 1 <= MAX_LENGTH_COUNTRY_CODE && i <= number.length) {\r\n\t\tconst countryCallingCode = number.slice(1, i)\r\n\t\tif (metadata.hasCallingCode(countryCallingCode)) {\r\n\t\t\tmetadata.selectNumberingPlan(countryCallingCode)\r\n\t\t\treturn {\r\n\t\t\t\tcountryCallingCodeSource: isNumberWithIddPrefix ? 'FROM_NUMBER_WITH_IDD' : 'FROM_NUMBER_WITH_PLUS_SIGN',\r\n\t\t\t\tcountryCallingCode,\r\n\t\t\t\tnumber: number.slice(i)\r\n\t\t\t}\r\n\t\t}\r\n\t\ti++\r\n\t}\r\n\r\n\treturn {}\r\n}\r\n\r\n// The possible values for the returned `countryCallingCodeSource` are:\r\n//\r\n// Copy-pasted from:\r\n// https://github.com/google/libphonenumber/blob/master/resources/phonenumber.proto\r\n//\r\n// // The source from which the country_code is derived. This is not set in the\r\n// // general parsing method, but in the method that parses and keeps raw_input.\r\n// // New fields could be added upon request.\r\n// enum CountryCodeSource {\r\n//  // Default value returned if this is not set, because the phone number was\r\n//  // created using parse, not parseAndKeepRawInput. hasCountryCodeSource will\r\n//  // return false if this is the case.\r\n//  UNSPECIFIED = 0;\r\n//\r\n//  // The country_code is derived based on a phone number with a leading \"+\",\r\n//  // e.g. the French number \"+33 1 42 68 53 00\".\r\n//  FROM_NUMBER_WITH_PLUS_SIGN = 1;\r\n//\r\n//  // The country_code is derived based on a phone number with a leading IDD,\r\n//  // e.g. the French number \"011 33 1 42 68 53 00\", as it is dialled from US.\r\n//  FROM_NUMBER_WITH_IDD = 5;\r\n//\r\n//  // The country_code is derived based on a phone number without a leading\r\n//  // \"+\", e.g. the French number \"33 1 42 68 53 00\" when defaultCountry is\r\n//  // supplied as France.\r\n//  FROM_NUMBER_WITHOUT_PLUS_SIGN = 10;\r\n//\r\n//  // The country_code is derived NOT based on the phone number itself, but\r\n//  // from the defaultCountry parameter provided in the parsing function by the\r\n//  // clients. This happens mostly for numbers written in the national format\r\n//  // (without country code). For example, this would be set when parsing the\r\n//  // French number \"01 42 68 53 00\", when defaultCountry is supplied as\r\n//  // France.\r\n//  FROM_DEFAULT_COUNTRY = 20;\r\n// }","import AsYouType from './AsYouType.js'\r\n\r\n/**\r\n * Formats a (possibly incomplete) phone number.\r\n * The phone number can be either in E.164 format\r\n * or in a form of national number digits.\r\n * @param {string} value - A possibly incomplete phone number. Either in E.164 format or in a form of national number digits.\r\n * @param {string|object} [optionsOrDefaultCountry] - A two-letter (\"ISO 3166-1 alpha-2\") country code, or an object of shape `{ defaultCountry?: string, defaultCallingCode?: string }`.\r\n * @return {string} Formatted (possibly incomplete) phone number.\r\n */\r\nexport default function formatIncompletePhoneNumber(value, optionsOrDefaultCountry, metadata) {\r\n\tif (!metadata) {\r\n\t\tmetadata = optionsOrDefaultCountry\r\n\t\toptionsOrDefaultCountry = undefined\r\n\t}\r\n\treturn new AsYouType(optionsOrDefaultCountry, metadata).input(value)\r\n}","import Metadata from './metadata.js'\r\nimport checkNumberLength from './helpers/checkNumberLength.js'\r\n\r\n/**\r\n * Checks if a phone number is \"possible\" (basically just checks its length).\r\n *\r\n * isPossible(phoneNumberInstance, { ..., v2: true }, metadata)\r\n *\r\n * isPossible({ phone: '8005553535', country: 'RU' }, { ... }, metadata)\r\n * isPossible({ phone: '8005553535', country: 'RU' }, undefined, metadata)\r\n *\r\n * @param  {object|PhoneNumber} input — If `options.v2: true` flag is passed, the `input` should be a `PhoneNumber` instance. Otherwise, it should be an object of shape `{ phone: '...', country: '...' }`.\r\n * @param  {object} [options]\r\n * @param  {object} metadata\r\n * @return {string}\r\n */\r\nexport default function isPossiblePhoneNumber(input, options, metadata) {\r\n\t/* istanbul ignore if */\r\n\tif (options === undefined) {\r\n\t\toptions = {}\r\n\t}\r\n\r\n\tmetadata = new Metadata(metadata)\r\n\r\n\tif (options.v2) {\r\n\t\tif (!input.countryCallingCode) {\r\n\t\t\tthrow new Error('Invalid phone number object passed')\r\n\t\t}\r\n\t\tmetadata.selectNumberingPlan(input.countryCallingCode)\r\n\t} else {\r\n\t\tif (!input.phone) {\r\n\t\t\treturn false\r\n\t\t}\r\n\t\tif (input.country) {\r\n\t\t\tif (!metadata.hasCountry(input.country)) {\r\n\t\t\t\tthrow new Error(`Unknown country: ${input.country}`)\r\n\t\t\t}\r\n\t\t\tmetadata.selectNumberingPlan(input.country)\r\n\t\t} else {\r\n\t\t\tif (!input.countryCallingCode) {\r\n\t\t\t\tthrow new Error('Invalid phone number object passed')\r\n\t\t\t}\r\n\t\t\tmetadata.selectNumberingPlan(input.countryCallingCode)\r\n\t\t}\r\n\t}\r\n\r\n\t// Old metadata (< 1.0.18) had no \"possible length\" data.\r\n\tif (metadata.possibleLengths()) {\r\n\t\treturn isPossibleNumber(input.phone || input.nationalNumber, input.country, metadata)\r\n\t} else {\r\n\t\t// There was a bug between `1.7.35` and `1.7.37` where \"possible_lengths\"\r\n\t\t// were missing for \"non-geographical\" numbering plans.\r\n\t\t// Just assume the number is possible in such cases:\r\n\t\t// it's unlikely that anyone generated their custom metadata\r\n\t\t// in that short period of time (one day).\r\n\t\t// This code can be removed in some future major version update.\r\n\t\tif (input.countryCallingCode && metadata.isNonGeographicCallingCode(input.countryCallingCode)) {\r\n\t\t\t// \"Non-geographic entities\" did't have `possibleLengths`\r\n\t\t\t// due to a bug in metadata generation process.\r\n\t\t\treturn true\r\n\t\t} else {\r\n\t\t\tthrow new Error('Missing \"possibleLengths\" in metadata. Perhaps the metadata has been generated before v1.0.18.');\r\n\t\t}\r\n\t}\r\n}\r\n\r\nexport function isPossibleNumber(nationalNumber, country, metadata) { //, isInternational) {\r\n\tswitch (checkNumberLength(nationalNumber, country, metadata)) {\r\n\t\tcase 'IS_POSSIBLE':\r\n\t\t\treturn true\r\n\t\t// This library ignores \"local-only\" phone numbers (for simplicity).\r\n\t\t// See the readme for more info on what are \"local-only\" phone numbers.\r\n\t\t// case 'IS_POSSIBLE_LOCAL_ONLY':\r\n\t\t// \treturn !isInternational\r\n\t\tdefault:\r\n\t\t\treturn false\r\n\t}\r\n}","import applyInternationalSeparatorStyle from './applyInternationalSeparatorStyle.js'\r\n\r\n// This was originally set to $1 but there are some countries for which the\r\n// first group is not used in the national pattern (e.g. Argentina) so the $1\r\n// group does not match correctly. Therefore, we use `\\d`, so that the first\r\n// group actually used in the pattern will be matched.\r\nexport const FIRST_GROUP_PATTERN = /(\\$\\d)/\r\n\r\nexport default function formatNationalNumberUsingFormat(\r\n\tnumber,\r\n\tformat,\r\n\t{\r\n\t\tuseInternationalFormat,\r\n\t\twithNationalPrefix,\r\n\t\tcarrierCode,\r\n\t\tmetadata\r\n\t}\r\n) {\r\n\tconst formattedNumber = number.replace(\r\n\t\tnew RegExp(format.pattern()),\r\n\t\tuseInternationalFormat\r\n\t\t\t? format.internationalFormat()\r\n\t\t\t: (\r\n\t\t\t\t// This library doesn't use `domestic_carrier_code_formatting_rule`,\r\n\t\t\t\t// because that one is only used when formatting phone numbers\r\n\t\t\t\t// for dialing from a mobile phone, and this is not a dialing library.\r\n\t\t\t\t// carrierCode && format.domesticCarrierCodeFormattingRule()\r\n\t\t\t\t// \t// First, replace the $CC in the formatting rule with the desired carrier code.\r\n\t\t\t\t// \t// Then, replace the $FG in the formatting rule with the first group\r\n\t\t\t\t// \t// and the carrier code combined in the appropriate way.\r\n\t\t\t\t// \t? format.format().replace(FIRST_GROUP_PATTERN, format.domesticCarrierCodeFormattingRule().replace('$CC', carrierCode))\r\n\t\t\t\t// \t: (\r\n\t\t\t\t// \t\twithNationalPrefix && format.nationalPrefixFormattingRule()\r\n\t\t\t\t// \t\t\t? format.format().replace(FIRST_GROUP_PATTERN, format.nationalPrefixFormattingRule())\r\n\t\t\t\t// \t\t\t: format.format()\r\n\t\t\t\t// \t)\r\n\t\t\t\twithNationalPrefix && format.nationalPrefixFormattingRule()\r\n\t\t\t\t\t? format.format().replace(FIRST_GROUP_PATTERN, format.nationalPrefixFormattingRule())\r\n\t\t\t\t\t: format.format()\r\n\t\t\t)\r\n\t)\r\n\tif (useInternationalFormat) {\r\n\t\treturn applyInternationalSeparatorStyle(formattedNumber)\r\n\t}\r\n\treturn formattedNumber\r\n}","import extractNationalNumberFromPossiblyIncompleteNumber from './extractNationalNumberFromPossiblyIncompleteNumber.js'\r\nimport matchesEntirely from './matchesEntirely.js'\r\nimport checkNumberLength from './checkNumberLength.js'\r\nimport getCountryByCallingCode from './getCountryByCallingCode.js'\r\n\r\n/**\r\n * Strips national prefix and carrier code from a complete phone number.\r\n * The difference from the non-\"FromCompleteNumber\" function is that\r\n * it won't extract national prefix if the resultant number is too short\r\n * to be a complete number for the selected phone numbering plan.\r\n * @param  {string} number — Complete phone number digits.\r\n * @param  {string?} country — Country, if known.\r\n * @param  {Metadata} metadata — Metadata with a phone numbering plan selected.\r\n * @return {object} `{ nationalNumber: string, carrierCode: string? }`.\r\n */\r\nexport default function extractNationalNumber(number, country, metadata) {\r\n\t// Parsing national prefixes and carrier codes\r\n\t// is only required for local phone numbers\r\n\t// but some people don't understand that\r\n\t// and sometimes write international phone numbers\r\n\t// with national prefixes (or maybe even carrier codes).\r\n\t// http://ucken.blogspot.ru/2016/03/trunk-prefixes-in-skype4b.html\r\n\t// Google's original library forgives such mistakes\r\n\t// and so does this library, because it has been requested:\r\n\t// https://github.com/catamphetamine/libphonenumber-js/issues/127\r\n\tconst {\r\n\t\tcarrierCode,\r\n\t\tnationalNumber\r\n\t} = extractNationalNumberFromPossiblyIncompleteNumber(\r\n\t\tnumber,\r\n\t\tmetadata\r\n\t)\r\n\r\n\tif (nationalNumber !== number) {\r\n\t\tif (!shouldHaveExtractedNationalPrefix(number, nationalNumber, metadata)) {\r\n\t\t\t// Don't strip the national prefix.\r\n\t\t\treturn { nationalNumber: number }\r\n\t\t}\r\n\t\t// Check the national (significant) number length after extracting national prefix and carrier code.\r\n\t\t// Legacy generated metadata (before `1.0.18`) didn't support the \"possible lengths\" feature.\r\n\t\tif (metadata.numberingPlan.possibleLengths()) {\r\n\t\t\t// If an exact `country` is not specified, attempt to detect it from the assumed national number.\r\n\t\t\tif (!country) {\r\n\t\t\t\tcountry = getCountryByCallingCode(metadata.numberingPlan.callingCode(), {\r\n\t\t\t\t\tnationalNumber,\r\n\t\t\t\t\tmetadata\r\n\t\t\t\t})\r\n\t\t\t}\r\n\r\n\t\t\t// The number remaining after stripping the national prefix and carrier code\r\n\t\t\t// should be long enough to have a possible length for the country.\r\n\t\t\t// Otherwise, don't strip the national prefix and carrier code,\r\n\t\t\t// since the original number could be a valid number.\r\n\t\t\t// This check has been copy-pasted \"as is\" from Google's original library:\r\n\t\t\t// https://github.com/google/libphonenumber/blob/876268eb1ad6cdc1b7b5bef17fc5e43052702d57/java/libphonenumber/src/com/google/i18n/phonenumbers/PhoneNumberUtil.java#L3236-L3250\r\n\t\t\t// It doesn't check for the \"possibility\" of the original `number`.\r\n\t\t\t// I guess it's fine not checking that one. It works as is anyway.\r\n\t\t\tif (!isPossibleIncompleteNationalNumber(nationalNumber, country, metadata)) {\r\n\t\t\t\t// Don't strip the national prefix.\r\n\t\t\t\treturn { nationalNumber: number }\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn { nationalNumber, carrierCode }\r\n}\r\n\r\n// In some countries, the same digit could be a national prefix\r\n// or a leading digit of a valid phone number.\r\n// For example, in Russia, national prefix is `8`,\r\n// and also `800 555 35 35` is a valid number\r\n// in which `8` is not a national prefix, but the first digit\r\n// of a national (significant) number.\r\n// Same's with Belarus:\r\n// `82004910060` is a valid national (significant) number,\r\n// but `2004910060` is not.\r\n// To support such cases (to prevent the code from always stripping\r\n// national prefix), a condition is imposed: a national prefix\r\n// is not extracted when the original number is \"viable\" and the\r\n// resultant number is not, a \"viable\" national number being the one\r\n// that matches `national_number_pattern`.\r\nfunction shouldHaveExtractedNationalPrefix(nationalNumberBefore, nationalNumberAfter, metadata) {\r\n\t// The equivalent in Google's code is:\r\n\t// https://github.com/google/libphonenumber/blob/e326fa1fc4283bb05eb35cb3c15c18f98a31af33/java/libphonenumber/src/com/google/i18n/phonenumbers/PhoneNumberUtil.java#L2969-L3004\r\n\tif (matchesEntirely(nationalNumberBefore, metadata.nationalNumberPattern()) &&\r\n\t\t!matchesEntirely(nationalNumberAfter, metadata.nationalNumberPattern())) {\r\n\t\treturn false\r\n\t}\r\n\t// This \"is possible\" national number (length) check has been commented out\r\n\t// because it's superceded by the (effectively) same check done in the\r\n\t// `extractNationalNumber()` function after it calls `shouldHaveExtractedNationalPrefix()`.\r\n\t// In other words, why run the same check twice if it could only be run once.\r\n\t// // Check the national (significant) number length after extracting national prefix and carrier code.\r\n\t// // Fixes a minor \"weird behavior\" bug: https://gitlab.com/catamphetamine/libphonenumber-js/-/issues/57\r\n\t// // (Legacy generated metadata (before `1.0.18`) didn't support the \"possible lengths\" feature).\r\n\t// if (metadata.possibleLengths()) {\r\n\t// \tif (isPossibleIncompleteNationalNumber(nationalNumberBefore, metadata) &&\r\n\t// \t\t!isPossibleIncompleteNationalNumber(nationalNumberAfter, metadata)) {\r\n\t// \t\treturn false\r\n\t// \t}\r\n\t// }\r\n\treturn true\r\n}\r\n\r\nfunction isPossibleIncompleteNationalNumber(nationalNumber, country, metadata) {\r\n\tswitch (checkNumberLength(nationalNumber, country, metadata)) {\r\n\t\tcase 'TOO_SHORT':\r\n\t\tcase 'INVALID_LENGTH':\r\n\t\t// This library ignores \"local-only\" phone numbers (for simplicity).\r\n\t\t// See the readme for more info on what are \"local-only\" phone numbers.\r\n\t\t// case 'IS_POSSIBLE_LOCAL_ONLY':\r\n\t\t\treturn false\r\n\t\tdefault:\r\n\t\t\treturn true\r\n\t}\r\n}","import Metadata from '../metadata.js'\r\n\r\n/**\r\n * Pattern that makes it easy to distinguish whether a region has a single\r\n * international dialing prefix or not. If a region has a single international\r\n * prefix (e.g. 011 in USA), it will be represented as a string that contains\r\n * a sequence of ASCII digits, and possibly a tilde, which signals waiting for\r\n * the tone. If there are multiple available international prefixes in a\r\n * region, they will be represented as a regex string that always contains one\r\n * or more characters that are not ASCII digits or a tilde.\r\n */\r\nconst SINGLE_IDD_PREFIX_REG_EXP = /^[\\d]+(?:[~\\u2053\\u223C\\uFF5E][\\d]+)?$/\r\n\r\n// For regions that have multiple IDD prefixes\r\n// a preferred IDD prefix is returned.\r\nexport default function getIddPrefix(country, callingCode, metadata) {\r\n\tconst countryMetadata = new Metadata(metadata)\r\n\tcountryMetadata.selectNumberingPlan(country, callingCode)\r\n\tif (countryMetadata.defaultIDDPrefix()) {\r\n\t\treturn countryMetadata.defaultIDDPrefix()\r\n\t}\r\n\tif (SINGLE_IDD_PREFIX_REG_EXP.test(countryMetadata.IDDPrefix())) {\r\n\t\treturn countryMetadata.IDDPrefix()\r\n\t}\r\n}\r\n","import Metadata from './metadata.js'\r\nimport matchesEntirely from './helpers/matchesEntirely.js'\r\nimport getNumberType from './helpers/getNumberType.js'\r\n\r\n/**\r\n * Checks if a given phone number is valid.\r\n *\r\n * isValid(phoneNumberInstance, { ..., v2: true }, metadata)\r\n *\r\n * isPossible({ phone: '8005553535', country: 'RU' }, { ... }, metadata)\r\n * isPossible({ phone: '8005553535', country: 'RU' }, undefined, metadata)\r\n *\r\n * If the `number` is a string, it will be parsed to an object,\r\n * but only if it contains only valid phone number characters (including punctuation).\r\n * If the `number` is an object, it is used as is.\r\n *\r\n * The optional `defaultCountry` argument is the default country.\r\n * I.e. it does not restrict to just that country,\r\n * e.g. in those cases where several countries share\r\n * the same phone numbering rules (NANPA, Britain, etc).\r\n * For example, even though the number `07624 369230`\r\n * belongs to the Isle of Man (\"IM\" country code)\r\n * calling `isValidNumber('07624369230', 'GB', metadata)`\r\n * still returns `true` because the country is not restricted to `GB`,\r\n * it's just that `GB` is the default one for the phone numbering rules.\r\n * For restricting the country see `isValidNumberForRegion()`\r\n * though restricting a country might not be a good idea.\r\n * https://github.com/googlei18n/libphonenumber/blob/master/FAQ.md#when-should-i-use-isvalidnumberforregion\r\n *\r\n * Examples:\r\n *\r\n * ```js\r\n * isValidNumber('+78005553535', metadata)\r\n * isValidNumber('8005553535', 'RU', metadata)\r\n * isValidNumber('88005553535', 'RU', metadata)\r\n * isValidNumber({ phone: '8005553535', country: 'RU' }, metadata)\r\n * ```\r\n */\r\nexport default function isValidNumber(input, options, metadata)\r\n{\r\n\t// If assigning the `{}` default value is moved to the arguments above,\r\n\t// code coverage would decrease for some weird reason.\r\n\toptions = options || {}\r\n\r\n\tmetadata = new Metadata(metadata)\r\n\r\n\tmetadata.selectNumberingPlan(input.country, input.countryCallingCode)\r\n\r\n\t// By default, countries only have type regexps when it's required for\r\n\t// distinguishing different countries having the same `countryCallingCode`.\r\n\tif (metadata.hasTypes()) {\r\n\t\treturn getNumberType(input, options, metadata.metadata) !== undefined\r\n\t}\r\n\r\n\t// If there are no type regexps for this country in metadata then use\r\n\t// `nationalNumberPattern` as a \"better than nothing\" replacement.\r\n\tconst nationalNumber = options.v2 ? input.nationalNumber : input.phone\r\n\treturn matchesEntirely(nationalNumber, metadata.nationalNumberPattern())\r\n}","import Metadata from '../metadata.js'\r\nimport { VALID_DIGITS } from '../constants.js'\r\n\r\nconst CAPTURING_DIGIT_PATTERN = new RegExp('([' + VALID_DIGITS + '])')\r\n\r\nexport default function stripIddPrefix(number, country, callingCode, metadata) {\r\n\tif (!country) {\r\n\t\treturn\r\n\t}\r\n\t// Check if the number is IDD-prefixed.\r\n\tconst countryMetadata = new Metadata(metadata)\r\n\tcountryMetadata.selectNumberingPlan(country, callingCode)\r\n\tconst IDDPrefixPattern = new RegExp(countryMetadata.IDDPrefix())\r\n\tif (number.search(IDDPrefixPattern) !== 0) {\r\n\t\treturn\r\n\t}\r\n\t// Strip IDD prefix.\r\n\tnumber = number.slice(number.match(IDDPrefixPattern)[0].length)\r\n\t// If there're any digits after an IDD prefix,\r\n\t// then those digits are a country calling code.\r\n\t// Since no country code starts with a `0`,\r\n\t// the code below validates that the next digit (if present) is not `0`.\r\n\tconst matchedGroups = number.match(CAPTURING_DIGIT_PATTERN)\r\n\tif (matchedGroups && matchedGroups[1] != null && matchedGroups[1].length > 0) {\r\n\t\tif (matchedGroups[1] === '0') {\r\n\t\t\treturn\r\n\t\t}\r\n\t}\r\n\treturn number\r\n}","import Metadata from '../metadata.js'\r\nimport matchesEntirely from './matchesEntirely.js'\r\nimport extractNationalNumber from './extractNationalNumber.js'\r\nimport checkNumberLength from './checkNumberLength.js'\r\nimport getCountryCallingCode from '../getCountryCallingCode.js'\r\n\r\n/**\r\n * Sometimes some people incorrectly input international phone numbers\r\n * without the leading `+`. This function corrects such input.\r\n * @param  {string} number — Phone number digits.\r\n * @param  {string} [country] — Exact country of the phone number.\r\n * @param  {string} [defaultCountry]\r\n * @param  {string} [defaultCallingCode]\r\n * @param  {object} metadata\r\n * @return {object} `{ countryCallingCode: string?, number: string }`.\r\n */\r\nexport default function extractCountryCallingCodeFromInternationalNumberWithoutPlusSign(\r\n\tnumber,\r\n\tcountry,\r\n\tdefaultCountry,\r\n\tdefaultCallingCode,\r\n\tmetadata\r\n) {\r\n\tconst countryCallingCode = country || defaultCountry\r\n\t\t? getCountryCallingCode(country || defaultCountry, metadata)\r\n\t\t: defaultCallingCode\r\n\r\n\tif (number.indexOf(countryCallingCode) === 0) {\r\n\t\tmetadata = new Metadata(metadata)\r\n\t\tmetadata.selectNumberingPlan(country || defaultCountry, countryCallingCode)\r\n\r\n\t\tconst possibleShorterNumber = number.slice(countryCallingCode.length)\r\n\r\n\t\tconst {\r\n\t\t\tnationalNumber: possibleShorterNationalNumber,\r\n\t\t} = extractNationalNumber(\r\n\t\t\tpossibleShorterNumber,\r\n\t\t\tcountry,\r\n\t\t\tmetadata\r\n\t\t)\r\n\r\n\t\tconst {\r\n\t\t\tnationalNumber\r\n\t\t} = extractNationalNumber(\r\n\t\t\tnumber,\r\n\t\t\tcountry,\r\n\t\t\tmetadata\r\n\t\t)\r\n\r\n\t\t// If the number was not valid before but is valid now,\r\n\t\t// or if it was too long before, we consider the number\r\n\t\t// with the country calling code stripped to be a better result\r\n\t\t// and keep that instead.\r\n\t\t// For example, in Germany (+49), `49` is a valid area code,\r\n\t\t// so if a number starts with `49`, it could be both a valid\r\n\t\t// national German number or an international number without\r\n\t\t// a leading `+`.\r\n\t\tif (\r\n\t\t\t(\r\n\t\t\t\t!matchesEntirely(nationalNumber, metadata.nationalNumberPattern()) &&\r\n\t\t\t\tmatchesEntirely(possibleShorterNationalNumber, metadata.nationalNumberPattern())\r\n\t\t\t)\r\n\t\t\t||\r\n\t\t\tcheckNumberLength(nationalNumber, country, metadata) === 'TOO_LONG'\r\n\t\t) {\r\n\t\t\treturn {\r\n\t\t\t\tcountryCallingCode,\r\n\t\t\t\tnumber: possibleShorterNumber\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn { number }\r\n}","import Metadata from '../metadata.js'\r\nimport mergeArrays from './mergeArrays.js'\r\n\r\nexport default function checkNumberLength(nationalNumber, country, metadata) {\r\n\treturn checkNumberLengthForType(nationalNumber, country, undefined, metadata)\r\n}\r\n\r\n// Checks whether a number is possible for a certain `country` based on the number length.\r\n//\r\n// This function is not supported by metadata generated with ancient versions of\r\n// `libphonenumber-js` (before version `1.0.18`) which didn't include \"possible lengths\".\r\n//\r\n// There was also a known issue with `checkNumberLength()` function:\r\n// if a number is possible only in a certain `country` among several `countries`\r\n// that share the same \"country calling code\", that function would check\r\n// the possibility of the phone number only in the \"main\" `country` for the \"country calling code\"\r\n// and would not check if it's actually be possible in the speciifc `country`.\r\n//\r\n// For example, \"+1310xxxx\" numbers are valid in Canada.\r\n// However, they are not possible in the US due to being too short.\r\n// Since Canada and the US share the same country calling code — \"+1\" —\r\n// `checkNumberLength()` function used to return not \"IS_POSSIBLE\" for \"+1310xxxx\" numbers.\r\n//\r\n// In such cases, when using \"/max\" metadata, `isValid()` could output `true`\r\n// but at the same time `isPossible()` could output `false`, which was contradictory.\r\n//\r\n// See https://issuetracker.google.com/issues/335892662 for the discusson in Google's issues.\r\n//\r\n// The solution suggested by Google was implemented: an optional `country` argument\r\n// was added to `checkNumberLength()` function. If present, that `country` will be used\r\n// to check phone number length for that specific `country` rather than the \"main\" country\r\n// for the shared \"country calling code\".\r\n//\r\nexport function checkNumberLengthForType(nationalNumber, country, type, metadata) {\r\n\t// If the exact `country` is specified, it's no necessarily already selected in `metadata`.\r\n\t// Most likely, in cases when there're multiple countries corresponding to the same\r\n\t// \"country calling code\", the \"main\" country for that \"country calling code\" will be selected.\r\n\tif (country) {\r\n\t\tmetadata = new Metadata(metadata.metadata)\r\n\t\tmetadata.selectNumberingPlan(country)\r\n\t}\r\n\r\n\tconst type_info = metadata.type(type)\r\n\r\n\t// There should always be \"<possiblePengths/>\" set for every type element.\r\n\t// This is declared in the XML schema.\r\n\t// For size efficiency, where a sub-description (e.g. fixed-line)\r\n\t// has the same \"<possiblePengths/>\" as the \"general description\", this is missing,\r\n\t// so we fall back to the \"general description\". Where no numbers of the type\r\n\t// exist at all, there is one possible length (-1) which is guaranteed\r\n\t// not to match the length of any real phone number.\r\n\tlet possible_lengths = type_info && type_info.possibleLengths() || metadata.possibleLengths()\r\n\t// let local_lengths = type_info && type.possibleLengthsLocal() || metadata.possibleLengthsLocal()\r\n\r\n\t// Metadata before version `1.0.18` didn't contain `possible_lengths`.\r\n\tif (!possible_lengths) {\r\n\t\treturn 'IS_POSSIBLE'\r\n\t}\r\n\r\n\tif (type === 'FIXED_LINE_OR_MOBILE') {\r\n\t\t// No such country in metadata.\r\n\t\t/* istanbul ignore next */\r\n\t\tif (!metadata.type('FIXED_LINE')) {\r\n\t\t\t// The rare case has been encountered where no fixedLine data is available\r\n\t\t\t// (true for some non-geographic entities), so we just check mobile.\r\n\t\t\treturn checkNumberLengthForType(nationalNumber, country, 'MOBILE', metadata)\r\n\t\t}\r\n\r\n\t\tconst mobile_type = metadata.type('MOBILE')\r\n\t\tif (mobile_type) {\r\n\t\t\t// Merge the mobile data in if there was any. \"Concat\" creates a new\r\n\t\t\t// array, it doesn't edit possible_lengths in place, so we don't need a copy.\r\n\t\t\t// Note that when adding the possible lengths from mobile, we have\r\n\t\t\t// to again check they aren't empty since if they are this indicates\r\n\t\t\t// they are the same as the general desc and should be obtained from there.\r\n\t\t\tpossible_lengths = mergeArrays(possible_lengths, mobile_type.possibleLengths())\r\n\t\t\t// The current list is sorted; we need to merge in the new list and\r\n\t\t\t// re-sort (duplicates are okay). Sorting isn't so expensive because\r\n\t\t\t// the lists are very small.\r\n\r\n\t\t\t// if (local_lengths) {\r\n\t\t\t// \tlocal_lengths = mergeArrays(local_lengths, mobile_type.possibleLengthsLocal())\r\n\t\t\t// } else {\r\n\t\t\t// \tlocal_lengths = mobile_type.possibleLengthsLocal()\r\n\t\t\t// }\r\n\t\t}\r\n\t}\r\n\t// If the type doesn't exist then return 'INVALID_LENGTH'.\r\n\telse if (type && !type_info) {\r\n\t\treturn 'INVALID_LENGTH'\r\n\t}\r\n\r\n\tconst actual_length = nationalNumber.length\r\n\r\n\t// In `libphonenumber-js` all \"local-only\" formats are dropped for simplicity.\r\n\t// // This is safe because there is never an overlap beween the possible lengths\r\n\t// // and the local-only lengths; this is checked at build time.\r\n\t// if (local_lengths && local_lengths.indexOf(nationalNumber.length) >= 0)\r\n\t// {\r\n\t// \treturn 'IS_POSSIBLE_LOCAL_ONLY'\r\n\t// }\r\n\r\n\tconst minimum_length = possible_lengths[0]\r\n\r\n\tif (minimum_length === actual_length) {\r\n\t\treturn 'IS_POSSIBLE'\r\n\t}\r\n\r\n\tif (minimum_length > actual_length) {\r\n\t\treturn 'TOO_SHORT'\r\n\t}\r\n\r\n\tif (possible_lengths[possible_lengths.length - 1] < actual_length) {\r\n\t\treturn 'TOO_LONG'\r\n\t}\r\n\r\n\t// We skip the first element since we've already checked it.\r\n\treturn possible_lengths.indexOf(actual_length, 1) >= 0 ? 'IS_POSSIBLE' : 'INVALID_LENGTH'\r\n}","import checkNumberLength from './helpers/checkNumberLength.js'\r\nimport parseDigits from './helpers/parseDigits.js'\r\nimport formatNationalNumberUsingFormat from './helpers/formatNationalNumberUsingFormat.js'\r\n\r\nexport default function formatCompleteNumber(state, format, {\r\n\tmetadata,\r\n\tshouldTryNationalPrefixFormattingRule,\r\n\tgetSeparatorAfterNationalPrefix\r\n}) {\r\n\tconst matcher = new RegExp(`^(?:${format.pattern()})$`)\r\n\tif (matcher.test(state.nationalSignificantNumber)) {\r\n\t\treturn formatNationalNumberWithAndWithoutNationalPrefixFormattingRule(\r\n\t\t\tstate,\r\n\t\t\tformat,\r\n\t\t\t{\r\n\t\t\t\tmetadata,\r\n\t\t\t\tshouldTryNationalPrefixFormattingRule,\r\n\t\t\t\tgetSeparatorAfterNationalPrefix\r\n\t\t\t}\r\n\t\t)\r\n\t}\r\n}\r\n\r\nexport function canFormatCompleteNumber(nationalSignificantNumber, country, metadata) {\r\n\treturn checkNumberLength(nationalSignificantNumber, country, metadata) === 'IS_POSSIBLE'\r\n}\r\n\r\nfunction formatNationalNumberWithAndWithoutNationalPrefixFormattingRule(state, format, {\r\n\tmetadata,\r\n\tshouldTryNationalPrefixFormattingRule,\r\n\tgetSeparatorAfterNationalPrefix\r\n}) {\r\n\t// `format` has already been checked for `nationalPrefix` requirement.\r\n\r\n\tconst {\r\n\t\tnationalSignificantNumber,\r\n\t\tinternational,\r\n\t\tnationalPrefix,\r\n\t\tcarrierCode\r\n\t} = state\r\n\r\n\t// Format the number with using `national_prefix_formatting_rule`.\r\n\t// If the resulting formatted number is a valid formatted number, then return it.\r\n\t//\r\n\t// Google's AsYouType formatter is different in a way that it doesn't try\r\n\t// to format using the \"national prefix formatting rule\", and instead it\r\n\t// simply prepends a national prefix followed by a \" \" character.\r\n\t// This code does that too, but as a fallback.\r\n\t// The reason is that \"national prefix formatting rule\" may use parentheses,\r\n\t// which wouldn't be included has it used the simpler Google's way.\r\n\t//\r\n\tif (shouldTryNationalPrefixFormattingRule(format)) {\r\n\t\tconst formattedNumber = formatNationalNumber(state, format, {\r\n\t\t\tuseNationalPrefixFormattingRule: true,\r\n\t\t\tgetSeparatorAfterNationalPrefix,\r\n\t\t\tmetadata\r\n\t\t})\r\n\t\tif (formattedNumber) {\r\n\t\t\treturn formattedNumber\r\n\t\t}\r\n\t}\r\n\r\n\t// Format the number without using `national_prefix_formatting_rule`.\r\n\treturn formatNationalNumber(state, format, {\r\n\t\tuseNationalPrefixFormattingRule: false,\r\n\t\tgetSeparatorAfterNationalPrefix,\r\n\t\tmetadata\r\n\t})\r\n}\r\n\r\nfunction formatNationalNumber(state, format, {\r\n\tmetadata,\r\n\tuseNationalPrefixFormattingRule,\r\n\tgetSeparatorAfterNationalPrefix\r\n}) {\r\n\tlet formattedNationalNumber = formatNationalNumberUsingFormat(\r\n\t\tstate.nationalSignificantNumber,\r\n\t\tformat,\r\n\t\t{\r\n\t\t\tcarrierCode: state.carrierCode,\r\n\t\t\tuseInternationalFormat: state.international,\r\n\t\t\twithNationalPrefix: useNationalPrefixFormattingRule,\r\n\t\t\tmetadata\r\n\t\t}\r\n\t)\r\n\tif (!useNationalPrefixFormattingRule) {\r\n\t\tif (state.nationalPrefix) {\r\n\t\t\t// If a national prefix was extracted, then just prepend it,\r\n\t\t\t// followed by a \" \" character.\r\n\t\t\tformattedNationalNumber = state.nationalPrefix +\r\n\t\t\t\tgetSeparatorAfterNationalPrefix(format) +\r\n\t\t\t\tformattedNationalNumber\r\n\t\t} else if (state.prefixBeforeNationalSignificantNumberThatIsNotNationalPrefix) {\r\n\t\t\tformattedNationalNumber = state.prefixBeforeNationalSignificantNumberThatIsNotNationalPrefix +\r\n\t\t\t\t' ' +\r\n\t\t\t\tformattedNationalNumber\r\n\t\t}\r\n\t}\r\n\tif (isValidFormattedNationalNumber(formattedNationalNumber, state)) {\r\n\t\treturn formattedNationalNumber\r\n\t}\r\n}\r\n\r\n// Check that the formatted phone number contains exactly\r\n// the same digits that have been input by the user.\r\n// For example, when \"0111523456789\" is input for `AR` country,\r\n// the extracted `this.nationalSignificantNumber` is \"91123456789\",\r\n// which means that the national part of `this.digits` isn't simply equal to\r\n// `this.nationalPrefix` + `this.nationalSignificantNumber`.\r\n//\r\n// Also, a `format` can add extra digits to the `this.nationalSignificantNumber`\r\n// being formatted via `metadata[country].national_prefix_transform_rule`.\r\n// For example, for `VI` country, it prepends `340` to the national number,\r\n// and if this check hasn't been implemented, then there would be a bug\r\n// when `340` \"area coude\" is \"duplicated\" during input for `VI` country:\r\n// https://github.com/catamphetamine/libphonenumber-js/issues/318\r\n//\r\n// So, all these \"gotchas\" are filtered out.\r\n//\r\n// In the original Google's code, the comments say:\r\n// \"Check that we didn't remove nor add any extra digits when we matched\r\n// this formatting pattern. This usually happens after we entered the last\r\n// digit during AYTF. Eg: In case of MX, we swallow mobile token (1) when\r\n// formatted but AYTF should retain all the number entered and not change\r\n// in order to match a format (of same leading digits and length) display\r\n// in that way.\"\r\n// \"If it's the same (i.e entered number and format is same), then it's\r\n// safe to return this in formatted number as nothing is lost / added.\"\r\n// Otherwise, don't use this format.\r\n// https://github.com/google/libphonenumber/commit/3e7c1f04f5e7200f87fb131e6f85c6e99d60f510#diff-9149457fa9f5d608a11bb975c6ef4bc5\r\n// https://github.com/google/libphonenumber/commit/3ac88c7106e7dcb553bcc794b15f19185928a1c6#diff-2dcb77e833422ee304da348b905cde0b\r\n//\r\nfunction isValidFormattedNationalNumber(formattedNationalNumber, state) {\r\n\treturn parseDigits(formattedNationalNumber) === state.getNationalDigits()\r\n}","import Metadata from '../metadata.js'\r\n\r\n/**\r\n * Returns a list of countries that the phone number could potentially belong to.\r\n * @param  {string} callingCode — Calling code.\r\n * @param  {string} nationalNumber — National (significant) number.\r\n * @param  {object} metadata — Metadata.\r\n * @return {string[]} A list of possible countries.\r\n */\r\nexport default function getPossibleCountriesForNumber(callingCode, nationalNumber, metadata) {\r\n\tconst _metadata = new Metadata(metadata)\r\n\tlet possibleCountries = _metadata.getCountryCodesForCallingCode(callingCode)\r\n\tif (!possibleCountries) {\r\n\t\treturn []\r\n\t}\r\n\treturn possibleCountries.filter((country) => {\r\n\t\treturn couldNationalNumberBelongToCountry(nationalNumber, country, metadata)\r\n\t})\r\n}\r\n\r\nfunction couldNationalNumberBelongToCountry(nationalNumber, country, metadata) {\r\n\tconst _metadata = new Metadata(metadata)\r\n\t_metadata.selectNumberingPlan(country)\r\n\tif (_metadata.numberingPlan.possibleLengths().indexOf(nationalNumber.length) >= 0) {\r\n\t\treturn true\r\n\t}\r\n\treturn false\r\n}","// The minimum length of the national significant number.\r\nexport const MIN_LENGTH_FOR_NSN = 2\r\n\r\n// The ITU says the maximum length should be 15,\r\n// but one can find longer numbers in Germany.\r\nexport const MAX_LENGTH_FOR_NSN = 17\r\n\r\n// The maximum length of the country calling code.\r\nexport const MAX_LENGTH_COUNTRY_CODE = 3\r\n\r\n// Digits accepted in phone numbers\r\n// (ascii, fullwidth, arabic-indic, and eastern arabic digits).\r\nexport const VALID_DIGITS = '0-9\\uFF10-\\uFF19\\u0660-\\u0669\\u06F0-\\u06F9'\r\n\r\n// `DASHES` will be right after the opening square bracket of the \"character class\"\r\nconst DASHES = '-\\u2010-\\u2015\\u2212\\u30FC\\uFF0D'\r\nconst SLASHES = '\\uFF0F/'\r\nconst DOTS = '\\uFF0E.'\r\nexport const WHITESPACE = ' \\u00A0\\u00AD\\u200B\\u2060\\u3000'\r\nconst BRACKETS = '()\\uFF08\\uFF09\\uFF3B\\uFF3D\\\\[\\\\]'\r\n// export const OPENING_BRACKETS = '(\\uFF08\\uFF3B\\\\\\['\r\nconst TILDES = '~\\u2053\\u223C\\uFF5E'\r\n\r\n// Regular expression of acceptable punctuation found in phone numbers. This\r\n// excludes punctuation found as a leading character only. This consists of dash\r\n// characters, white space characters, full stops, slashes, square brackets,\r\n// parentheses and tildes. Full-width variants are also present.\r\nexport const VALID_PUNCTUATION = `${DASHES}${SLASHES}${DOTS}${WHITESPACE}${BRACKETS}${TILDES}`\r\n\r\nexport const PLUS_CHARS = '+\\uFF0B'\r\n// const LEADING_PLUS_CHARS_PATTERN = new RegExp('^[' + PLUS_CHARS + ']+')","import { formatIncompletePhoneNumber } from \"@/lib/libphonenumber\";\n\nexport function decodeEmail(email: string) {\n  return atob(email);\n}\n\nexport function decodePhoneNumber(phone: string) {\n  return atob(phone);\n}\n\nexport function formatPhoneNumber(phone: string) {\n  return formatIncompletePhoneNumber(phone);\n}\n","import type { LucideProps } from \"lucide-react\";\n\nexport function IntroItem({\n  icon: Icon,\n  content,\n  href,\n}: {\n  icon: React.ComponentType<LucideProps>;\n  content: React.ReactNode;\n  href?: string;\n}) {\n  return (\n    <div className=\"flex items-center gap-4 font-mono text-sm\">\n      <div\n        className=\"flex size-6 shrink-0 items-center justify-center rounded-lg bg-muted dark:inset-shadow-[1px_1px_1px,0px_0px_2px] dark:inset-shadow-white/15\"\n        aria-hidden\n      >\n        <Icon className=\"pointer-events-none size-4 text-muted-foreground\" />\n      </div>\n\n      <p className=\"text-balance\">\n        {href ? (\n          <a\n            className=\"underline-offset-4 hover:underline\"\n            href={href}\n            target=\"_blank\"\n            rel=\"noopener noreferrer\"\n          >\n            {content}\n          </a>\n        ) : (\n          content\n        )}\n      </p>\n    </div>\n  );\n}\n","import type { MetadataJson } from \"libphonenumber-js/core\";\nimport { formatIncompletePhoneNumber as _formatIncompletePhoneNumber } from \"libphonenumber-js/core\";\n\nimport metadataJson from \"@/assets/libphonenumber.metadata.json\";\n\nconst metadata = metadataJson as MetadataJson;\n\n/**\n * Formats an incomplete phone number string according to the metadata provided (currently only for Viet Nam).\n *\n * Uses `libphonenumber-js`'s `formatIncompletePhoneNumber` function with custom metadata.\n *\n * @param phone - The phone number string to format (may be incomplete).\n * @returns The formatted phone number string.\n *\n * @remarks\n * - Only Viet Nam (VN) metadata is included by default. To add more countries, update and run the `generate-libphonenumber-metadata` script in `package.json`.\n * - This function is useful for formatting user input as they type a phone number.\n *\n * @see https://www.npmjs.com/package/libphonenumber-js#customizing-metadata\n */\nexport function formatIncompletePhoneNumber(phone: string) {\n  return _formatIncompletePhoneNumber(phone, metadata);\n}\n","import { VALID_DIGITS } from '../../constants.js'\r\n\r\n// The RFC 3966 format for extensions.\r\nconst RFC3966_EXTN_PREFIX = ';ext='\r\n\r\n/**\r\n * Helper method for constructing regular expressions for parsing. Creates\r\n * an expression that captures up to max_length digits.\r\n * @return {string} RegEx pattern to capture extension digits.\r\n */\r\nconst getExtensionDigitsPattern = (maxLength) => `([${VALID_DIGITS}]{1,${maxLength}})`\r\n\r\n/**\r\n * Helper initialiser method to create the regular-expression pattern to match\r\n * extensions.\r\n * Copy-pasted from Google's `libphonenumber`:\r\n * https://github.com/google/libphonenumber/blob/55b2646ec9393f4d3d6661b9c82ef9e258e8b829/javascript/i18n/phonenumbers/phonenumberutil.js#L759-L766\r\n * @return {string} RegEx pattern to capture extensions.\r\n */\r\nexport default function createExtensionPattern(purpose) {\r\n\t// We cap the maximum length of an extension based on the ambiguity of the way\r\n\t// the extension is prefixed. As per ITU, the officially allowed length for\r\n\t// extensions is actually 40, but we don't support this since we haven't seen real\r\n\t// examples and this introduces many false interpretations as the extension labels\r\n\t// are not standardized.\r\n\t/** @type {string} */\r\n\tvar extLimitAfterExplicitLabel = '20';\r\n\t/** @type {string} */\r\n\tvar extLimitAfterLikelyLabel = '15';\r\n\t/** @type {string} */\r\n\tvar extLimitAfterAmbiguousChar = '9';\r\n\t/** @type {string} */\r\n\tvar extLimitWhenNotSure = '6';\r\n\r\n\t/** @type {string} */\r\n\tvar possibleSeparatorsBetweenNumberAndExtLabel = \"[ \\u00A0\\\\t,]*\";\r\n\t// Optional full stop (.) or colon, followed by zero or more spaces/tabs/commas.\r\n\t/** @type {string} */\r\n\tvar possibleCharsAfterExtLabel = \"[:\\\\.\\uFF0E]?[ \\u00A0\\\\t,-]*\";\r\n\t/** @type {string} */\r\n\tvar optionalExtnSuffix = \"#?\";\r\n\r\n\t// Here the extension is called out in more explicit way, i.e mentioning it obvious\r\n\t// patterns like \"ext.\".\r\n\t/** @type {string} */\r\n\tvar explicitExtLabels =\r\n\t  \"(?:e?xt(?:ensi(?:o\\u0301?|\\u00F3))?n?|\\uFF45?\\uFF58\\uFF54\\uFF4E?|\\u0434\\u043E\\u0431|anexo)\";\r\n\t// One-character symbols that can be used to indicate an extension, and less\r\n\t// commonly used or more ambiguous extension labels.\r\n\t/** @type {string} */\r\n\tvar ambiguousExtLabels = \"(?:[x\\uFF58#\\uFF03~\\uFF5E]|int|\\uFF49\\uFF4E\\uFF54)\";\r\n\t// When extension is not separated clearly.\r\n\t/** @type {string} */\r\n\tvar ambiguousSeparator = \"[- ]+\";\r\n\t// This is the same as possibleSeparatorsBetweenNumberAndExtLabel, but not matching\r\n\t// comma as extension label may have it.\r\n\t/** @type {string} */\r\n\tvar possibleSeparatorsNumberExtLabelNoComma = \"[ \\u00A0\\\\t]*\";\r\n\t// \",,\" is commonly used for auto dialling the extension when connected. First\r\n\t// comma is matched through possibleSeparatorsBetweenNumberAndExtLabel, so we do\r\n\t// not repeat it here. Semi-colon works in Iphone and Android also to pop up a\r\n\t// button with the extension number following.\r\n\t/** @type {string} */\r\n\tvar autoDiallingAndExtLabelsFound = \"(?:,{2}|;)\";\r\n\r\n\t/** @type {string} */\r\n\tvar rfcExtn = RFC3966_EXTN_PREFIX\r\n\t     + getExtensionDigitsPattern(extLimitAfterExplicitLabel);\r\n\t/** @type {string} */\r\n\tvar explicitExtn = possibleSeparatorsBetweenNumberAndExtLabel + explicitExtLabels\r\n\t     + possibleCharsAfterExtLabel\r\n\t     + getExtensionDigitsPattern(extLimitAfterExplicitLabel)\r\n\t     + optionalExtnSuffix;\r\n\t/** @type {string} */\r\n\tvar ambiguousExtn = possibleSeparatorsBetweenNumberAndExtLabel + ambiguousExtLabels\r\n\t     + possibleCharsAfterExtLabel\r\n\t+ getExtensionDigitsPattern(extLimitAfterAmbiguousChar)\r\n\t+ optionalExtnSuffix;\r\n\t/** @type {string} */\r\n\tvar americanStyleExtnWithSuffix = ambiguousSeparator\r\n\t+ getExtensionDigitsPattern(extLimitWhenNotSure) + \"#\";\r\n\r\n\t/** @type {string} */\r\n\tvar autoDiallingExtn = possibleSeparatorsNumberExtLabelNoComma\r\n\t     + autoDiallingAndExtLabelsFound + possibleCharsAfterExtLabel\r\n\t     + getExtensionDigitsPattern(extLimitAfterLikelyLabel)\r\n\t+ optionalExtnSuffix;\r\n\t/** @type {string} */\r\n\tvar onlyCommasExtn = possibleSeparatorsNumberExtLabelNoComma\r\n\t    + \"(?:,)+\" + possibleCharsAfterExtLabel\r\n\t    + getExtensionDigitsPattern(extLimitAfterAmbiguousChar)\r\n\t    + optionalExtnSuffix;\r\n\r\n\t// The first regular expression covers RFC 3966 format, where the extension is added\r\n\t// using \";ext=\". The second more generic where extension is mentioned with explicit\r\n\t// labels like \"ext:\". In both the above cases we allow more numbers in extension than\r\n\t// any other extension labels. The third one captures when single character extension\r\n\t// labels or less commonly used labels are used. In such cases we capture fewer\r\n\t// extension digits in order to reduce the chance of falsely interpreting two\r\n\t// numbers beside each other as a number + extension. The fourth one covers the\r\n\t// special case of American numbers where the extension is written with a hash\r\n\t// at the end, such as \"- 503#\". The fifth one is exclusively for extension\r\n\t// autodialling formats which are used when dialling and in this case we accept longer\r\n\t// extensions. The last one is more liberal on the number of commas that acts as\r\n\t// extension labels, so we have a strict cap on the number of digits in such extensions.\r\n\treturn rfcExtn + \"|\"\r\n\t       + explicitExtn + \"|\"\r\n\t       + ambiguousExtn + \"|\"\r\n\t       + americanStyleExtnWithSuffix + \"|\"\r\n\t       + autoDiallingExtn + \"|\"\r\n\t       + onlyCommasExtn;\r\n}","import Metadata from '../metadata.js'\r\nimport matchesEntirely from './matchesEntirely.js'\r\n\r\nconst NON_FIXED_LINE_PHONE_TYPES = [\r\n\t'MOBILE',\r\n\t'PREMIUM_RATE',\r\n\t'TOLL_FREE',\r\n\t'SHARED_COST',\r\n\t'VOIP',\r\n\t'PERSONAL_NUMBER',\r\n\t'PAGER',\r\n\t'UAN',\r\n\t'VOICEMAIL'\r\n]\r\n\r\n// Finds out national phone number type (fixed line, mobile, etc)\r\nexport default function getNumberType(input, options, metadata)\r\n{\r\n\t// If assigning the `{}` default value is moved to the arguments above,\r\n\t// code coverage would decrease for some weird reason.\r\n\toptions = options || {}\r\n\r\n\t// When `parse()` returns an empty object — `{}` —\r\n\t// that means that the phone number is malformed,\r\n\t// so it can't possibly be valid.\r\n\tif (!input.country && !input.countryCallingCode) {\r\n\t\treturn\r\n\t}\r\n\r\n\tmetadata = new Metadata(metadata)\r\n\r\n\tmetadata.selectNumberingPlan(input.country, input.countryCallingCode)\r\n\r\n\tconst nationalNumber = options.v2 ? input.nationalNumber : input.phone\r\n\r\n\t// The following is copy-pasted from the original function:\r\n\t// https://github.com/googlei18n/libphonenumber/blob/3ea547d4fbaa2d0b67588904dfa5d3f2557c27ff/javascript/i18n/phonenumbers/phonenumberutil.js#L2835\r\n\r\n\t// Is this national number even valid for this country\r\n\tif (!matchesEntirely(nationalNumber, metadata.nationalNumberPattern())) {\r\n\t\treturn\r\n\t}\r\n\r\n\t// Is it fixed line number\r\n\tif (isNumberTypeEqualTo(nationalNumber, 'FIXED_LINE', metadata)) {\r\n\t\t// Because duplicate regular expressions are removed\r\n\t\t// to reduce metadata size, if \"mobile\" pattern is \"\"\r\n\t\t// then it means it was removed due to being a duplicate of the fixed-line pattern.\r\n\t\t//\r\n\t\tif (metadata.type('MOBILE') && metadata.type('MOBILE').pattern() === '') {\r\n\t\t\treturn 'FIXED_LINE_OR_MOBILE'\r\n\t\t}\r\n\r\n\t\t// `MOBILE` type pattern isn't included if it matched `FIXED_LINE` one.\r\n\t\t// For example, for \"US\" country.\r\n\t\t// Old metadata (< `1.0.18`) had a specific \"types\" data structure\r\n\t\t// that happened to be `undefined` for `MOBILE` in that case.\r\n\t\t// Newer metadata (>= `1.0.18`) has another data structure that is\r\n\t\t// not `undefined` for `MOBILE` in that case (it's just an empty array).\r\n\t\t// So this `if` is just for backwards compatibility with old metadata.\r\n\t\tif (!metadata.type('MOBILE')) {\r\n\t\t\treturn 'FIXED_LINE_OR_MOBILE'\r\n\t\t}\r\n\r\n\t\t// Check if the number happens to qualify as both fixed line and mobile.\r\n\t\t// (no such country in the minimal metadata set)\r\n\t\t/* istanbul ignore if */\r\n\t\tif (isNumberTypeEqualTo(nationalNumber, 'MOBILE', metadata)) {\r\n\t\t\treturn 'FIXED_LINE_OR_MOBILE'\r\n\t\t}\r\n\r\n\t\treturn 'FIXED_LINE'\r\n\t}\r\n\r\n\tfor (const type of NON_FIXED_LINE_PHONE_TYPES) {\r\n\t\tif (isNumberTypeEqualTo(nationalNumber, type, metadata)) {\r\n\t\t\treturn type\r\n\t\t}\r\n\t}\r\n}\r\n\r\nexport function isNumberTypeEqualTo(nationalNumber, type, metadata) {\r\n\ttype = metadata.type(type)\r\n\tif (!type || !type.pattern()) {\r\n\t\treturn false\r\n\t}\r\n\t// Check if any possible number lengths are present;\r\n\t// if so, we use them to avoid checking\r\n\t// the validation pattern if they don't match.\r\n\t// If they are absent, this means they match\r\n\t// the general description, which we have\r\n\t// already checked before a specific number type.\r\n\tif (type.possibleLengths() &&\r\n\t\ttype.possibleLengths().indexOf(nationalNumber.length) < 0) {\r\n\t\treturn false\r\n\t}\r\n\treturn matchesEntirely(nationalNumber, type.pattern())\r\n}","import Metadata from '../metadata.js'\r\nimport getNumberType from './getNumberType.js'\r\n\r\n// Returns the exact country that the `nationalPhoneNumber` belongs to\r\n// in cases of ambiguity, i.e. when multiple countries share the same \"country calling code\".\r\nexport default function getCountryByNationalNumber(nationalPhoneNumber, {\r\n\tcountries,\r\n\tmetadata\r\n}) {\r\n\t// Re-create `metadata` because it will be selecting a `country`.\r\n\tmetadata = new Metadata(metadata)\r\n\r\n\t// const matchingCountries = []\r\n\r\n\tfor (const country of countries) {\r\n\t\tmetadata.selectNumberingPlan(country)\r\n\t\t// \"Leading digits\" patterns are only defined for about 20% of all countries.\r\n\t\t// By definition, matching \"leading digits\" is a sufficient but not a necessary\r\n\t\t// condition for a phone number to belong to a country.\r\n\t\t// The point of \"leading digits\" check is that it's the fastest one to get a match.\r\n\t\t// https://gitlab.com/catamphetamine/libphonenumber-js/blob/master/METADATA.md#leading_digits\r\n\t\t// I'd suppose that \"leading digits\" patterns are mutually exclusive for different countries\r\n\t\t// because of the intended use of that feature.\r\n\t\tif (metadata.leadingDigits()) {\r\n\t\t\tif (nationalPhoneNumber &&\r\n\t\t\t\tnationalPhoneNumber.search(metadata.leadingDigits()) === 0) {\r\n\t\t\t\treturn country\r\n\t\t\t}\r\n\t\t}\r\n\t\t// Else perform full validation with all of those\r\n\t\t// fixed-line/mobile/etc regular expressions.\r\n\t\telse if (getNumberType({ phone: nationalPhoneNumber, country }, undefined, metadata.metadata)) {\r\n\t\t\t// When multiple countries share the same \"country calling code\",\r\n\t\t\t// type patterns aren't guaranteed to be unique among them.\r\n\t\t\t// For example, both `US` and `CA` have the same pattern for `toll_free` numbers.\r\n\t\t\t// https://gitlab.com/catamphetamine/libphonenumber-js/-/issues/103#note_1417147572\r\n\t\t\t//\r\n\t\t\t// That means that this `if` condition could be `true` for multiple countries from the list.\r\n\t\t\t// Currently, it just returns the first one, which is also the \"main\" country for the \"country calling code\".\r\n\t\t\t// In an example with `toll_free` numbers above, `\"US\"` would be returned even though\r\n\t\t\t// it could as well be `\"CA\"`.\r\n\t\t\t//\r\n\t\t\t// There was also a time when this attempted to be overly smart\r\n\t\t\t// and kept track of all such multiple matching countries\r\n\t\t\t// and then picked the one that matched the `defaultCountry`, if provided.\r\n\t\t\t// For example, with `toll_free` numbers above, and with `defaultCountry: \"CA\"`,\r\n\t\t\t// it would've returned `\"CA\"` instead of `\"US\"`.\r\n\t\t\t// Later it turned out that such \"overly smart\" behavior turned out to be just confusing,\r\n\t\t\t// so this \"overly smart\" country detection was reverted to returning the \"main\" country\r\n\t\t\t// for the \"country calling code\".\r\n\t\t\t// https://gitlab.com/catamphetamine/libphonenumber-js/-/issues/154\r\n\t\t\t//\r\n\t\t\treturn country\r\n\t\t\t//\r\n\t\t\t// The \"overly smart\" behavior code:\r\n\t\t\t//\r\n\t\t\t// if (defaultCountry) {\r\n\t\t\t// \tif (country === defaultCountry) {\r\n\t\t\t// \t\treturn country\r\n\t\t\t// \t} else {\r\n\t\t\t// \t\tmatchingCountries.push(country)\r\n\t\t\t// \t}\r\n\t\t\t// } else {\r\n\t\t\t// \treturn country\r\n\t\t\t// }\r\n\t\t}\r\n\t}\r\n\r\n\t// // Return the first (\"main\") one of the `matchingCountries`.\r\n\t// if (matchingCountries.length > 0) {\r\n\t// \treturn matchingCountries[0]\r\n\t// }\r\n}","// Should be the same as `DIGIT_PLACEHOLDER` in `libphonenumber-metadata-generator`.\r\nexport const DIGIT_PLACEHOLDER = 'x' // '\\u2008' (punctuation space)\r\nconst DIGIT_PLACEHOLDER_MATCHER = new RegExp(DIGIT_PLACEHOLDER)\r\n\r\n// Counts all occurences of a symbol in a string.\r\n// Unicode-unsafe (because using `.split()`).\r\nexport function countOccurences(symbol, string) {\r\n\tlet count = 0\r\n\t// Using `.split('')` to iterate through a string here\r\n\t// to avoid requiring `Symbol.iterator` polyfill.\r\n\t// `.split('')` is generally not safe for Unicode,\r\n\t// but in this particular case for counting brackets it is safe.\r\n\t// for (const character of string)\r\n\tfor (const character of string.split('')) {\r\n\t\tif (character === symbol) {\r\n\t\t\tcount++\r\n\t\t}\r\n\t}\r\n\treturn count\r\n}\r\n\r\n// Repeats a string (or a symbol) N times.\r\n// http://stackoverflow.com/questions/202605/repeat-string-javascript\r\nexport function repeat(string, times) {\r\n\tif (times < 1) {\r\n\t\treturn ''\r\n\t}\r\n\tlet result = ''\r\n\twhile (times > 1) {\r\n\t\tif (times & 1) {\r\n\t\t\tresult += string\r\n\t\t}\r\n\t\ttimes >>= 1\r\n\t\tstring += string\r\n\t}\r\n\treturn result + string\r\n}\r\n\r\nexport function cutAndStripNonPairedParens(string, cutBeforeIndex) {\r\n\tif (string[cutBeforeIndex] === ')') {\r\n\t\tcutBeforeIndex++\r\n\t}\r\n\treturn stripNonPairedParens(string.slice(0, cutBeforeIndex))\r\n}\r\n\r\nexport function closeNonPairedParens(template, cut_before) {\r\n\tconst retained_template = template.slice(0, cut_before)\r\n\tconst opening_braces = countOccurences('(', retained_template)\r\n\tconst closing_braces = countOccurences(')', retained_template)\r\n\tlet dangling_braces = opening_braces - closing_braces\r\n\twhile (dangling_braces > 0 && cut_before < template.length) {\r\n\t\tif (template[cut_before] === ')') {\r\n\t\t\tdangling_braces--\r\n\t\t}\r\n\t\tcut_before++\r\n\t}\r\n\treturn template.slice(0, cut_before)\r\n}\r\n\r\nexport function stripNonPairedParens(string) {\r\n\tconst dangling_braces =[]\r\n\tlet i = 0\r\n\twhile (i < string.length) {\r\n\t\tif (string[i] === '(') {\r\n\t\t\tdangling_braces.push(i)\r\n\t\t}\r\n\t\telse if (string[i] === ')') {\r\n\t\t\tdangling_braces.pop()\r\n\t\t}\r\n\t\ti++\r\n\t}\r\n\tlet start = 0\r\n\tlet cleared_string = ''\r\n\tdangling_braces.push(string.length)\r\n\tfor (const index of dangling_braces) {\r\n\t\tcleared_string += string.slice(start, index)\r\n\t\tstart = index + 1\r\n\t}\r\n\treturn cleared_string\r\n}\r\n\r\nexport function populateTemplateWithDigits(template, position, digits) {\r\n\t// Using `.split('')` to iterate through a string here\r\n\t// to avoid requiring `Symbol.iterator` polyfill.\r\n\t// `.split('')` is generally not safe for Unicode,\r\n\t// but in this particular case for `digits` it is safe.\r\n\t// for (const digit of digits)\r\n\tfor (const digit of digits.split('')) {\r\n\t\t// If there is room for more digits in current `template`,\r\n\t\t// then set the next digit in the `template`,\r\n\t\t// and return the formatted digits so far.\r\n\t\t// If more digits are entered than the current format could handle.\r\n\t\tif (template.slice(position + 1).search(DIGIT_PLACEHOLDER_MATCHER) < 0) {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tposition = template.search(DIGIT_PLACEHOLDER_MATCHER)\r\n\t\ttemplate = template.replace(DIGIT_PLACEHOLDER_MATCHER, digit)\r\n\t}\r\n\treturn [template, position]\r\n}","/**\r\n * Checks whether the entire input sequence can be matched\r\n * against the regular expression.\r\n * @return {boolean}\r\n */\r\nexport default function matchesEntirely(text, regularExpressionText) {\r\n\t// If the assigning of the `''` default value is moved to the arguments above,\r\n\t// the code coverage would decrease for some weird reason.\r\n\ttext = text || ''\r\n\treturn new RegExp('^(?:' + regularExpressionText + ')$').test(text)\r\n}","export default class PatternParser {\r\n\tparse(pattern) {\r\n\t\tthis.context = [{\r\n\t\t\tor: true,\r\n\t\t\tinstructions: []\r\n\t\t}]\r\n\r\n\t\tthis.parsePattern(pattern)\r\n\r\n\t\tif (this.context.length !== 1) {\r\n\t\t\tthrow new Error('Non-finalized contexts left when pattern parse ended')\r\n\t\t}\r\n\r\n\t\tconst { branches, instructions } = this.context[0]\r\n\r\n\t\tif (branches) {\r\n\t\t\treturn {\r\n\t\t\t\top: '|',\r\n\t\t\t\targs: branches.concat([\r\n\t\t\t\t\texpandSingleElementArray(instructions)\r\n\t\t\t\t])\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/* istanbul ignore if */\r\n\t\tif (instructions.length === 0) {\r\n\t\t\tthrow new Error('Pattern is required')\r\n\t\t}\r\n\r\n\t\tif (instructions.length === 1) {\r\n\t\t\treturn instructions[0]\r\n\t\t}\r\n\r\n\t\treturn instructions\r\n\t}\r\n\r\n\tstartContext(context) {\r\n\t\tthis.context.push(context)\r\n\t}\r\n\r\n\tendContext() {\r\n\t\tthis.context.pop()\r\n\t}\r\n\r\n\tgetContext() {\r\n\t\treturn this.context[this.context.length - 1]\r\n\t}\r\n\r\n\tparsePattern(pattern) {\r\n\t\tif (!pattern) {\r\n\t\t\tthrow new Error('Pattern is required')\r\n\t\t}\r\n\r\n\t\tconst match = pattern.match(OPERATOR)\r\n\t\tif (!match) {\r\n\t\t\tif (ILLEGAL_CHARACTER_REGEXP.test(pattern)) {\r\n\t\t\t\tthrow new Error(`Illegal characters found in a pattern: ${pattern}`)\r\n\t\t\t}\r\n\t\t\tthis.getContext().instructions = this.getContext().instructions.concat(\r\n\t\t\t\tpattern.split('')\r\n\t\t\t)\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tconst operator = match[1]\r\n\t\tconst before = pattern.slice(0, match.index)\r\n\t\tconst rightPart = pattern.slice(match.index + operator.length)\r\n\r\n\t\tswitch (operator) {\r\n\t\t\tcase '(?:':\r\n\t\t\t\tif (before) {\r\n\t\t\t\t\tthis.parsePattern(before)\r\n\t\t\t\t}\r\n\t\t\t\tthis.startContext({\r\n\t\t\t\t\tor: true,\r\n\t\t\t\t\tinstructions: [],\r\n\t\t\t\t\tbranches: []\r\n\t\t\t\t})\r\n\t\t\t\tbreak\r\n\r\n\t\t\tcase ')':\r\n\t\t\t\tif (!this.getContext().or) {\r\n\t\t\t\t\tthrow new Error('\")\" operator must be preceded by \"(?:\" operator')\r\n\t\t\t\t}\r\n\t\t\t\tif (before) {\r\n\t\t\t\t\tthis.parsePattern(before)\r\n\t\t\t\t}\r\n\t\t\t\tif (this.getContext().instructions.length === 0) {\r\n\t\t\t\t\tthrow new Error('No instructions found after \"|\" operator in an \"or\" group')\r\n\t\t\t\t}\r\n\t\t\t\tconst { branches } = this.getContext()\r\n\t\t\t\tbranches.push(\r\n\t\t\t\t\texpandSingleElementArray(\r\n\t\t\t\t\t\tthis.getContext().instructions\r\n\t\t\t\t\t)\r\n\t\t\t\t)\r\n\t\t\t\tthis.endContext()\r\n\t\t\t\tthis.getContext().instructions.push({\r\n\t\t\t\t\top: '|',\r\n\t\t\t\t\targs: branches\r\n\t\t\t\t})\r\n\t\t\t\tbreak\r\n\r\n\t\t\tcase '|':\r\n\t\t\t\tif (!this.getContext().or) {\r\n\t\t\t\t\tthrow new Error('\"|\" operator can only be used inside \"or\" groups')\r\n\t\t\t\t}\r\n\t\t\t\tif (before) {\r\n\t\t\t\t\tthis.parsePattern(before)\r\n\t\t\t\t}\r\n\t\t\t\t// The top-level is an implicit \"or\" group, if required.\r\n\t\t\t\tif (!this.getContext().branches) {\r\n\t\t\t\t\t// `branches` are not defined only for the root implicit \"or\" operator.\r\n\t\t\t\t\t/* istanbul ignore else */\r\n\t\t\t\t\tif (this.context.length === 1) {\r\n\t\t\t\t\t\tthis.getContext().branches = []\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tthrow new Error('\"branches\" not found in an \"or\" group context')\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tthis.getContext().branches.push(\r\n\t\t\t\t\texpandSingleElementArray(\r\n\t\t\t\t\t\tthis.getContext().instructions\r\n\t\t\t\t\t)\r\n\t\t\t\t)\r\n\t\t\t\tthis.getContext().instructions = []\r\n\t\t\t\tbreak\r\n\r\n\t\t\tcase '[':\r\n\t\t\t\tif (before) {\r\n\t\t\t\t\tthis.parsePattern(before)\r\n\t\t\t\t}\r\n\t\t\t\tthis.startContext({\r\n\t\t\t\t\toneOfSet: true\r\n\t\t\t\t})\r\n\t\t\t\tbreak\r\n\r\n\t\t\tcase ']':\r\n\t\t\t\tif (!this.getContext().oneOfSet) {\r\n\t\t\t\t\tthrow new Error('\"]\" operator must be preceded by \"[\" operator')\r\n\t\t\t\t}\r\n\t\t\t\tthis.endContext()\r\n\t\t\t\tthis.getContext().instructions.push({\r\n\t\t\t\t\top: '[]',\r\n\t\t\t\t\targs: parseOneOfSet(before)\r\n\t\t\t\t})\r\n\t\t\t\tbreak\r\n\r\n\t\t\t/* istanbul ignore next */\r\n\t\t\tdefault:\r\n\t\t\t\tthrow new Error(`Unknown operator: ${operator}`)\r\n\t\t}\r\n\r\n\t\tif (rightPart) {\r\n\t\t\tthis.parsePattern(rightPart)\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction parseOneOfSet(pattern) {\r\n\tconst values = []\r\n\tlet i = 0\r\n\twhile (i < pattern.length) {\r\n\t\tif (pattern[i] === '-') {\r\n\t\t\tif (i === 0 || i === pattern.length - 1) {\r\n\t\t\t\tthrow new Error(`Couldn't parse a one-of set pattern: ${pattern}`)\r\n\t\t\t}\r\n\t\t\tconst prevValue = pattern[i - 1].charCodeAt(0) + 1\r\n\t\t\tconst nextValue = pattern[i + 1].charCodeAt(0) - 1\r\n\t\t\tlet value = prevValue\r\n\t\t\twhile (value <= nextValue) {\r\n\t\t\t\tvalues.push(String.fromCharCode(value))\r\n\t\t\t\tvalue++\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tvalues.push(pattern[i])\r\n\t\t}\r\n\t\ti++\r\n\t}\r\n\treturn values\r\n}\r\n\r\nconst ILLEGAL_CHARACTER_REGEXP = /[\\(\\)\\[\\]\\?\\:\\|]/\r\n\r\nconst OPERATOR = new RegExp(\r\n\t// any of:\r\n\t'(' +\r\n\t\t// or operator\r\n\t\t'\\\\|' +\r\n\t\t// or\r\n\t\t'|' +\r\n\t\t// or group start\r\n\t\t'\\\\(\\\\?\\\\:' +\r\n\t\t// or\r\n\t\t'|' +\r\n\t\t// or group end\r\n\t\t'\\\\)' +\r\n\t\t// or\r\n\t\t'|' +\r\n\t\t// one-of set start\r\n\t\t'\\\\[' +\r\n\t\t// or\r\n\t\t'|' +\r\n\t\t// one-of set end\r\n\t\t'\\\\]' +\r\n\t')'\r\n)\r\n\r\nfunction expandSingleElementArray(array) {\r\n\tif (array.length === 1) {\r\n\t\treturn array[0]\r\n\t}\r\n\treturn array\r\n}","// This is a port of Google Android `libphonenumber`'s\r\n// `phonenumberutil.js` of December 31th, 2018.\r\n//\r\n// https://github.com/googlei18n/libphonenumber/commits/master/javascript/i18n/phonenumbers/phonenumberutil.js\r\n\r\nimport matchesEntirely from './helpers/matchesEntirely.js'\r\nimport formatNationalNumberUsingFormat from './helpers/formatNationalNumberUsingFormat.js'\r\nimport Metadata, { getCountryCallingCode } from './metadata.js'\r\nimport getIddPrefix from './helpers/getIddPrefix.js'\r\nimport { formatRFC3966 } from './helpers/RFC3966.js'\r\n\r\nconst DEFAULT_OPTIONS = {\r\n\tformatExtension: (formattedNumber, extension, metadata) => `${formattedNumber}${metadata.ext()}${extension}`\r\n}\r\n\r\n/**\r\n * Formats a phone number.\r\n *\r\n * format(phoneNumberInstance, 'INTERNATIONAL', { ..., v2: true }, metadata)\r\n * format(phoneNumberInstance, 'NATIONAL', { ..., v2: true }, metadata)\r\n *\r\n * format({ phone: '8005553535', country: 'RU' }, 'INTERNATIONAL', { ... }, metadata)\r\n * format({ phone: '8005553535', country: 'RU' }, 'NATIONAL', undefined, metadata)\r\n *\r\n * @param  {object|PhoneNumber} input — If `options.v2: true` flag is passed, the `input` should be a `PhoneNumber` instance. Otherwise, it should be an object of shape `{ phone: '...', country: '...' }`.\r\n * @param  {string} format\r\n * @param  {object} [options]\r\n * @param  {object} metadata\r\n * @return {string}\r\n */\r\nexport default function formatNumber(input, format, options, metadata) {\r\n\t// Apply default options.\r\n\tif (options) {\r\n\t\t// Using ES6 \"rest spread\" syntax here didn't work with `babel`/`istanbul`\r\n\t\t// for some weird reason: this line of code would cause the code coverage\r\n\t\t// to show as not 100%. That's because `babel`/`istanbul`, for some weird reason,\r\n\t\t// apparently doesn't know how to properly exclude Babel polyfills from code coverage.\r\n\t\t//\r\n\t\t// options = { ...DEFAULT_OPTIONS, ...options }\r\n\t\t//\r\n\t\toptions = merge({}, DEFAULT_OPTIONS, options)\r\n\t} else {\r\n\t\toptions = DEFAULT_OPTIONS\r\n\t}\r\n\r\n\tmetadata = new Metadata(metadata)\r\n\r\n\tif (input.country && input.country !== '001') {\r\n\t\t// Validate `input.country`.\r\n\t\tif (!metadata.hasCountry(input.country)) {\r\n\t\t\tthrow new Error(`Unknown country: ${input.country}`)\r\n\t\t}\r\n\t\tmetadata.selectNumberingPlan(input.country)\r\n\t}\r\n\telse if (input.countryCallingCode) {\r\n\t\tmetadata.selectNumberingPlan(input.countryCallingCode)\r\n\t}\r\n\telse return input.phone || ''\r\n\r\n\tconst countryCallingCode = metadata.countryCallingCode()\r\n\r\n\tconst nationalNumber = options.v2 ? input.nationalNumber : input.phone\r\n\r\n\t// This variable should have been declared inside `case`s\r\n\t// but Babel has a bug and it says \"duplicate variable declaration\".\r\n\tlet number\r\n\r\n\tswitch (format) {\r\n\t\tcase 'NATIONAL':\r\n\t\t\t// Legacy argument support.\r\n\t\t\t// (`{ country: ..., phone: '' }`)\r\n\t\t\tif (!nationalNumber) {\r\n\t\t\t\treturn ''\r\n\t\t\t}\r\n\t\t\tnumber = formatNationalNumber(nationalNumber, input.carrierCode, 'NATIONAL', metadata, options)\r\n\t\t\treturn addExtension(number, input.ext, metadata, options.formatExtension)\r\n\r\n\t\tcase 'INTERNATIONAL':\r\n\t\t\t// Legacy argument support.\r\n\t\t\t// (`{ country: ..., phone: '' }`)\r\n\t\t\tif (!nationalNumber) {\r\n\t\t\t\treturn `+${countryCallingCode}`\r\n\t\t\t}\r\n\t\t\tnumber = formatNationalNumber(nationalNumber, null, 'INTERNATIONAL', metadata, options)\r\n\t\t\tnumber = `+${countryCallingCode} ${number}`\r\n\t\t\treturn addExtension(number, input.ext, metadata, options.formatExtension)\r\n\r\n\t\tcase 'E.164':\r\n\t\t\t// `E.164` doesn't define \"phone number extensions\".\r\n\t\t\treturn `+${countryCallingCode}${nationalNumber}`\r\n\r\n\t\tcase 'RFC3966':\r\n\t\t\treturn formatRFC3966({\r\n\t\t\t\tnumber: `+${countryCallingCode}${nationalNumber}`,\r\n\t\t\t\text: input.ext\r\n\t\t\t})\r\n\r\n\t\t// For reference, here's Google's IDD formatter:\r\n\t\t// https://github.com/google/libphonenumber/blob/32719cf74e68796788d1ca45abc85dcdc63ba5b9/java/libphonenumber/src/com/google/i18n/phonenumbers/PhoneNumberUtil.java#L1546\r\n\t\t// Not saying that this IDD formatter replicates it 1:1, but it seems to work.\r\n\t\t// Who would even need to format phone numbers in IDD format anyway?\r\n\t\tcase 'IDD':\r\n\t\t\tif (!options.fromCountry) {\r\n\t\t\t\treturn\r\n\t\t\t\t// throw new Error('`fromCountry` option not passed for IDD-prefixed formatting.')\r\n\t\t\t}\r\n\t\t\tconst formattedNumber = formatIDD(\r\n\t\t\t\tnationalNumber,\r\n\t\t\t\tinput.carrierCode,\r\n\t\t\t\tcountryCallingCode,\r\n\t\t\t\toptions.fromCountry,\r\n\t\t\t\tmetadata\r\n\t\t\t)\r\n\t\t\treturn addExtension(formattedNumber, input.ext, metadata, options.formatExtension)\r\n\r\n\t\tdefault:\r\n\t\t\tthrow new Error(`Unknown \"format\" argument passed to \"formatNumber()\": \"${format}\"`)\r\n\t}\r\n}\r\n\r\nfunction formatNationalNumber(number, carrierCode, formatAs, metadata, options) {\r\n\tconst format = chooseFormatForNumber(metadata.formats(), number)\r\n\tif (!format) {\r\n\t\treturn number\r\n\t}\r\n\treturn formatNationalNumberUsingFormat(\r\n\t\tnumber,\r\n\t\tformat,\r\n\t\t{\r\n\t\t\tuseInternationalFormat: formatAs === 'INTERNATIONAL',\r\n\t\t\twithNationalPrefix: format.nationalPrefixIsOptionalWhenFormattingInNationalFormat() && (options && options.nationalPrefix === false) ? false : true,\r\n\t\t\tcarrierCode,\r\n\t\t\tmetadata\r\n\t\t}\r\n\t)\r\n}\r\n\r\nexport function chooseFormatForNumber(availableFormats, nationalNumber) {\r\n\t// Using a `for ... of` loop here didn't work with `babel`/`istanbul`:\r\n\t// for some weird reason, it showed code coverage less than 100%.\r\n\t// That's because `babel`/`istanbul`, for some weird reason,\r\n\t// apparently doesn't know how to properly exclude Babel polyfills from code coverage.\r\n\t//\r\n\t// for (const format of availableFormats) { ... }\r\n\t//\r\n\treturn pickFirstMatchingElement(availableFormats, (format) => {\r\n\t\t// Validate leading digits.\r\n\t\t// The test case for \"else path\" could be found by searching for\r\n\t\t// \"format.leadingDigitsPatterns().length === 0\".\r\n\t\tif (format.leadingDigitsPatterns().length > 0) {\r\n\t\t\t// The last leading_digits_pattern is used here, as it is the most detailed\r\n\t\t\tconst lastLeadingDigitsPattern = format.leadingDigitsPatterns()[format.leadingDigitsPatterns().length - 1]\r\n\t\t\t// If leading digits don't match then move on to the next phone number format\r\n\t\t\tif (nationalNumber.search(lastLeadingDigitsPattern) !== 0) {\r\n\t\t\t\treturn false\r\n\t\t\t}\r\n\t\t}\r\n\t\t// Check that the national number matches the phone number format regular expression\r\n\t\treturn matchesEntirely(nationalNumber, format.pattern())\r\n\t})\r\n}\r\n\r\nfunction addExtension(formattedNumber, ext, metadata, formatExtension) {\r\n\treturn ext ? formatExtension(formattedNumber, ext, metadata) : formattedNumber\r\n}\r\n\r\nfunction formatIDD(\r\n\tnationalNumber,\r\n\tcarrierCode,\r\n\tcountryCallingCode,\r\n\tfromCountry,\r\n\tmetadata\r\n) {\r\n\tconst fromCountryCallingCode = getCountryCallingCode(fromCountry, metadata.metadata)\r\n\t// When calling within the same country calling code.\r\n\tif (fromCountryCallingCode === countryCallingCode) {\r\n\t\tconst formattedNumber = formatNationalNumber(nationalNumber, carrierCode, 'NATIONAL', metadata)\r\n\t\t// For NANPA regions, return the national format for these regions\r\n\t\t// but prefix it with the country calling code.\r\n\t\tif (countryCallingCode === '1') {\r\n\t\t\treturn countryCallingCode + ' ' + formattedNumber\r\n\t\t}\r\n\t\t// If regions share a country calling code, the country calling code need\r\n\t\t// not be dialled. This also applies when dialling within a region, so this\r\n\t\t// if clause covers both these cases. Technically this is the case for\r\n\t\t// dialling from La Reunion to other overseas departments of France (French\r\n\t\t// Guiana, Martinique, Guadeloupe), but not vice versa - so we don't cover\r\n\t\t// this edge case for now and for those cases return the version including\r\n\t\t// country calling code. Details here:\r\n\t\t// http://www.petitfute.com/voyage/225-info-pratiques-reunion\r\n\t\t//\r\n\t\treturn formattedNumber\r\n\t}\r\n\tconst iddPrefix = getIddPrefix(fromCountry, undefined, metadata.metadata)\r\n\tif (iddPrefix) {\r\n\t\treturn `${iddPrefix} ${countryCallingCode} ${formatNationalNumber(nationalNumber, null, 'INTERNATIONAL', metadata)}`\r\n\t}\r\n}\r\n\r\nfunction merge(...objects) {\r\n\tlet i = 1\r\n\twhile (i < objects.length) {\r\n\t\tif (objects[i]) {\r\n\t\t\tfor (const key in objects[i]) {\r\n\t\t\t\tobjects[0][key] = objects[i][key]\r\n\t\t\t}\r\n\t\t}\r\n\t\ti++\r\n\t}\r\n\treturn objects[0]\r\n}\r\n\r\nfunction pickFirstMatchingElement(elements, testFunction) {\r\n\tlet i = 0\r\n\twhile (i < elements.length) {\r\n\t\tif (testFunction(elements[i])) {\r\n\t\t\treturn elements[i]\r\n\t\t}\r\n\t\ti++\r\n\t}\r\n}","import compare from './tools/semver-compare.js'\r\nimport isObject from './helpers/isObject.js'\r\n\r\n// Added \"possibleLengths\" and renamed\r\n// \"country_phone_code_to_countries\" to \"country_calling_codes\".\r\nconst V2 = '1.0.18'\r\n\r\n// Added \"idd_prefix\" and \"default_idd_prefix\".\r\nconst V3 = '1.2.0'\r\n\r\n// Moved `001` country code to \"nonGeographic\" section of metadata.\r\nconst V4 = '1.7.35'\r\n\r\nconst DEFAULT_EXT_PREFIX = ' ext. '\r\n\r\nconst CALLING_CODE_REG_EXP = /^\\d+$/\r\n\r\n/**\r\n * See: https://gitlab.com/catamphetamine/libphonenumber-js/blob/master/METADATA.md\r\n */\r\nexport default class Metadata {\r\n\tconstructor(metadata) {\r\n\t\tvalidateMetadata(metadata)\r\n\t\tthis.metadata = metadata\r\n\t\tsetVersion.call(this, metadata)\r\n\t}\r\n\r\n\tgetCountries() {\r\n\t\treturn Object.keys(this.metadata.countries).filter(_ => _ !== '001')\r\n\t}\r\n\r\n\tgetCountryMetadata(countryCode) {\r\n\t\treturn this.metadata.countries[countryCode]\r\n\t}\r\n\r\n\tnonGeographic() {\r\n\t\tif (this.v1 || this.v2 || this.v3) return\r\n\t\t// `nonGeographical` was a typo.\r\n\t\t// It's present in metadata generated from `1.7.35` to `1.7.37`.\r\n\t\t// The test case could be found by searching for \"nonGeographical\".\r\n\t\treturn this.metadata.nonGeographic || this.metadata.nonGeographical\r\n\t}\r\n\r\n\thasCountry(country) {\r\n\t\treturn this.getCountryMetadata(country) !== undefined\r\n\t}\r\n\r\n\thasCallingCode(callingCode) {\r\n\t\tif (this.getCountryCodesForCallingCode(callingCode)) {\r\n\t\t\treturn true\r\n\t\t}\r\n\t\tif (this.nonGeographic()) {\r\n\t\t\tif (this.nonGeographic()[callingCode]) {\r\n\t\t\t\treturn true\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\t// A hacky workaround for old custom metadata (generated before V4).\r\n\t\t\tconst countryCodes = this.countryCallingCodes()[callingCode]\r\n\t\t\tif (countryCodes && countryCodes.length === 1 && countryCodes[0] === '001') {\r\n\t\t\t\treturn true\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tisNonGeographicCallingCode(callingCode) {\r\n\t\tif (this.nonGeographic()) {\r\n\t\t\treturn this.nonGeographic()[callingCode] ? true : false\r\n\t\t} else {\r\n\t\t\treturn this.getCountryCodesForCallingCode(callingCode) ? false : true\r\n\t\t}\r\n\t}\r\n\r\n\t// Deprecated.\r\n\tcountry(countryCode) {\r\n\t\treturn this.selectNumberingPlan(countryCode)\r\n\t}\r\n\r\n\tselectNumberingPlan(countryCode, callingCode) {\r\n\t\t// Supports just passing `callingCode` as the first argument.\r\n\t\tif (countryCode && CALLING_CODE_REG_EXP.test(countryCode)) {\r\n\t\t\tcallingCode = countryCode\r\n\t\t\tcountryCode = null\r\n\t\t}\r\n\t\tif (countryCode && countryCode !== '001') {\r\n\t\t\tif (!this.hasCountry(countryCode)) {\r\n\t\t\t\tthrow new Error(`Unknown country: ${countryCode}`)\r\n\t\t\t}\r\n\t\t\tthis.numberingPlan = new NumberingPlan(this.getCountryMetadata(countryCode), this)\r\n\t\t} else if (callingCode) {\r\n\t\t\tif (!this.hasCallingCode(callingCode)) {\r\n\t\t\t\tthrow new Error(`Unknown calling code: ${callingCode}`)\r\n\t\t\t}\r\n\t\t\tthis.numberingPlan = new NumberingPlan(this.getNumberingPlanMetadata(callingCode), this)\r\n\t\t} else {\r\n\t\t\tthis.numberingPlan = undefined\r\n\t\t}\r\n\t\treturn this\r\n\t}\r\n\r\n\tgetCountryCodesForCallingCode(callingCode) {\r\n\t\tconst countryCodes = this.countryCallingCodes()[callingCode]\r\n\t\tif (countryCodes) {\r\n\t\t\t// Metadata before V4 included \"non-geographic entity\" calling codes\r\n\t\t\t// inside `country_calling_codes` (for example, `\"881\":[\"001\"]`).\r\n\t\t\t// Now the semantics of `country_calling_codes` has changed:\r\n\t\t\t// it's specifically for \"countries\" now.\r\n\t\t\t// Older versions of custom metadata will simply skip parsing\r\n\t\t\t// \"non-geographic entity\" phone numbers with new versions\r\n\t\t\t// of this library: it's not considered a bug,\r\n\t\t\t// because such numbers are extremely rare,\r\n\t\t\t// and developers extremely rarely use custom metadata.\r\n\t\t\tif (countryCodes.length === 1 && countryCodes[0].length === 3) {\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\treturn countryCodes\r\n\t\t}\r\n\t}\r\n\r\n\tgetCountryCodeForCallingCode(callingCode) {\r\n\t\tconst countryCodes = this.getCountryCodesForCallingCode(callingCode)\r\n\t\tif (countryCodes) {\r\n\t\t\treturn countryCodes[0]\r\n\t\t}\r\n\t}\r\n\r\n\tgetNumberingPlanMetadata(callingCode) {\r\n\t\tconst countryCode = this.getCountryCodeForCallingCode(callingCode)\r\n\t\tif (countryCode) {\r\n\t\t\treturn this.getCountryMetadata(countryCode)\r\n\t\t}\r\n\t\tif (this.nonGeographic()) {\r\n\t\t\tconst metadata = this.nonGeographic()[callingCode]\r\n\t\t\tif (metadata) {\r\n\t\t\t\treturn metadata\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\t// A hacky workaround for old custom metadata (generated before V4).\r\n\t\t\t// In that metadata, there was no concept of \"non-geographic\" metadata\r\n\t\t\t// so metadata for `001` country code was stored along with other countries.\r\n\t\t\t// The test case can be found by searching for:\r\n\t\t\t// \"should work around `nonGeographic` metadata not existing\".\r\n\t\t\tconst countryCodes = this.countryCallingCodes()[callingCode]\r\n\t\t\tif (countryCodes && countryCodes.length === 1 && countryCodes[0] === '001') {\r\n\t\t\t\treturn this.metadata.countries['001']\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// Deprecated.\r\n\tcountryCallingCode() {\r\n\t\treturn this.numberingPlan.callingCode()\r\n\t}\r\n\r\n\t// Deprecated.\r\n\tIDDPrefix() {\r\n\t\treturn this.numberingPlan.IDDPrefix()\r\n\t}\r\n\r\n\t// Deprecated.\r\n\tdefaultIDDPrefix() {\r\n\t\treturn this.numberingPlan.defaultIDDPrefix()\r\n\t}\r\n\r\n\t// Deprecated.\r\n\tnationalNumberPattern() {\r\n\t\treturn this.numberingPlan.nationalNumberPattern()\r\n\t}\r\n\r\n\t// Deprecated.\r\n\tpossibleLengths() {\r\n\t\treturn this.numberingPlan.possibleLengths()\r\n\t}\r\n\r\n\t// Deprecated.\r\n\tformats() {\r\n\t\treturn this.numberingPlan.formats()\r\n\t}\r\n\r\n\t// Deprecated.\r\n\tnationalPrefixForParsing() {\r\n\t\treturn this.numberingPlan.nationalPrefixForParsing()\r\n\t}\r\n\r\n\t// Deprecated.\r\n\tnationalPrefixTransformRule() {\r\n\t\treturn this.numberingPlan.nationalPrefixTransformRule()\r\n\t}\r\n\r\n\t// Deprecated.\r\n\tleadingDigits() {\r\n\t\treturn this.numberingPlan.leadingDigits()\r\n\t}\r\n\r\n\t// Deprecated.\r\n\thasTypes() {\r\n\t\treturn this.numberingPlan.hasTypes()\r\n\t}\r\n\r\n\t// Deprecated.\r\n\ttype(type) {\r\n\t\treturn this.numberingPlan.type(type)\r\n\t}\r\n\r\n\t// Deprecated.\r\n\text() {\r\n\t\treturn this.numberingPlan.ext()\r\n\t}\r\n\r\n\tcountryCallingCodes() {\r\n\t\tif (this.v1) return this.metadata.country_phone_code_to_countries\r\n\t\treturn this.metadata.country_calling_codes\r\n\t}\r\n\r\n\t// Deprecated.\r\n\tchooseCountryByCountryCallingCode(callingCode) {\r\n\t\treturn this.selectNumberingPlan(callingCode)\r\n\t}\r\n\r\n\thasSelectedNumberingPlan() {\r\n\t\treturn this.numberingPlan !== undefined\r\n\t}\r\n}\r\n\r\nclass NumberingPlan {\r\n\tconstructor(metadata, globalMetadataObject) {\r\n\t\tthis.globalMetadataObject = globalMetadataObject\r\n\t\tthis.metadata = metadata\r\n\t\tsetVersion.call(this, globalMetadataObject.metadata)\r\n\t}\r\n\r\n\tcallingCode() {\r\n\t\treturn this.metadata[0]\r\n\t}\r\n\r\n\t// Formatting information for regions which share\r\n\t// a country calling code is contained by only one region\r\n\t// for performance reasons. For example, for NANPA region\r\n\t// (\"North American Numbering Plan Administration\",\r\n\t//  which includes USA, Canada, Cayman Islands, Bahamas, etc)\r\n\t// it will be contained in the metadata for `US`.\r\n\tgetDefaultCountryMetadataForRegion() {\r\n\t\treturn this.globalMetadataObject.getNumberingPlanMetadata(this.callingCode())\r\n\t}\r\n\r\n\t// Is always present.\r\n\tIDDPrefix() {\r\n\t\tif (this.v1 || this.v2) return\r\n\t\treturn this.metadata[1]\r\n\t}\r\n\r\n\t// Is only present when a country supports multiple IDD prefixes.\r\n\tdefaultIDDPrefix() {\r\n\t\tif (this.v1 || this.v2) return\r\n\t\treturn this.metadata[12]\r\n\t}\r\n\r\n\tnationalNumberPattern() {\r\n\t\tif (this.v1 || this.v2) return this.metadata[1]\r\n\t\treturn this.metadata[2]\r\n\t}\r\n\r\n\t// \"possible length\" data is always present in Google's metadata.\r\n\tpossibleLengths() {\r\n\t\tif (this.v1) return\r\n\t\treturn this.metadata[this.v2 ? 2 : 3]\r\n\t}\r\n\r\n\t_getFormats(metadata) {\r\n\t\treturn metadata[this.v1 ? 2 : this.v2 ? 3 : 4]\r\n\t}\r\n\r\n\t// For countries of the same region (e.g. NANPA)\r\n\t// formats are all stored in the \"main\" country for that region.\r\n\t// E.g. \"RU\" and \"KZ\", \"US\" and \"CA\".\r\n\tformats() {\r\n\t\tconst formats = this._getFormats(this.metadata) || this._getFormats(this.getDefaultCountryMetadataForRegion()) || []\r\n\t\treturn formats.map(_ => new Format(_, this))\r\n\t}\r\n\r\n\tnationalPrefix() {\r\n\t\treturn this.metadata[this.v1 ? 3 : this.v2 ? 4 : 5]\r\n\t}\r\n\r\n\t_getNationalPrefixFormattingRule(metadata) {\r\n\t\treturn metadata[this.v1 ? 4 : this.v2 ? 5 : 6]\r\n\t}\r\n\r\n\t// For countries of the same region (e.g. NANPA)\r\n\t// national prefix formatting rule is stored in the \"main\" country for that region.\r\n\t// E.g. \"RU\" and \"KZ\", \"US\" and \"CA\".\r\n\tnationalPrefixFormattingRule() {\r\n\t\treturn this._getNationalPrefixFormattingRule(this.metadata) || this._getNationalPrefixFormattingRule(this.getDefaultCountryMetadataForRegion())\r\n\t}\r\n\r\n\t_nationalPrefixForParsing() {\r\n\t\treturn this.metadata[this.v1 ? 5 : this.v2 ? 6 : 7]\r\n\t}\r\n\r\n\tnationalPrefixForParsing() {\r\n\t\t// If `national_prefix_for_parsing` is not set explicitly,\r\n\t\t// then infer it from `national_prefix` (if any)\r\n\t\treturn this._nationalPrefixForParsing() || this.nationalPrefix()\r\n\t}\r\n\r\n\tnationalPrefixTransformRule() {\r\n\t\treturn this.metadata[this.v1 ? 6 : this.v2 ? 7 : 8]\r\n\t}\r\n\r\n\t_getNationalPrefixIsOptionalWhenFormatting() {\r\n\t\treturn !!this.metadata[this.v1 ? 7 : this.v2 ? 8 : 9]\r\n\t}\r\n\r\n\t// For countries of the same region (e.g. NANPA)\r\n\t// \"national prefix is optional when formatting\" flag is\r\n\t// stored in the \"main\" country for that region.\r\n\t// E.g. \"RU\" and \"KZ\", \"US\" and \"CA\".\r\n\tnationalPrefixIsOptionalWhenFormattingInNationalFormat() {\r\n\t\treturn this._getNationalPrefixIsOptionalWhenFormatting(this.metadata) ||\r\n\t\t\tthis._getNationalPrefixIsOptionalWhenFormatting(this.getDefaultCountryMetadataForRegion())\r\n\t}\r\n\r\n\tleadingDigits() {\r\n\t\treturn this.metadata[this.v1 ? 8 : this.v2 ? 9 : 10]\r\n\t}\r\n\r\n\ttypes() {\r\n\t\treturn this.metadata[this.v1 ? 9 : this.v2 ? 10 : 11]\r\n\t}\r\n\r\n\thasTypes() {\r\n\t\t// Versions 1.2.0 - 1.2.4: can be `[]`.\r\n\t\t/* istanbul ignore next */\r\n\t\tif (this.types() && this.types().length === 0) {\r\n\t\t\treturn false\r\n\t\t}\r\n\t\t// Versions <= 1.2.4: can be `undefined`.\r\n\t\t// Version >= 1.2.5: can be `0`.\r\n\t\treturn !!this.types()\r\n\t}\r\n\r\n\ttype(type) {\r\n\t\tif (this.hasTypes() && getType(this.types(), type)) {\r\n\t\t\treturn new Type(getType(this.types(), type), this)\r\n\t\t}\r\n\t}\r\n\r\n\text() {\r\n\t\tif (this.v1 || this.v2) return DEFAULT_EXT_PREFIX\r\n\t\treturn this.metadata[13] || DEFAULT_EXT_PREFIX\r\n\t}\r\n}\r\n\r\nclass Format {\r\n\tconstructor(format, metadata) {\r\n\t\tthis._format = format\r\n\t\tthis.metadata = metadata\r\n\t}\r\n\r\n\tpattern() {\r\n\t\treturn this._format[0]\r\n\t}\r\n\r\n\tformat() {\r\n\t\treturn this._format[1]\r\n\t}\r\n\r\n\tleadingDigitsPatterns() {\r\n\t\treturn this._format[2] || []\r\n\t}\r\n\r\n\tnationalPrefixFormattingRule() {\r\n\t\treturn this._format[3] || this.metadata.nationalPrefixFormattingRule()\r\n\t}\r\n\r\n\tnationalPrefixIsOptionalWhenFormattingInNationalFormat() {\r\n\t\treturn !!this._format[4] || this.metadata.nationalPrefixIsOptionalWhenFormattingInNationalFormat()\r\n\t}\r\n\r\n\tnationalPrefixIsMandatoryWhenFormattingInNationalFormat() {\r\n\t\t// National prefix is omitted if there's no national prefix formatting rule\r\n\t\t// set for this country, or when the national prefix formatting rule\r\n\t\t// contains no national prefix itself, or when this rule is set but\r\n\t\t// national prefix is optional for this phone number format\r\n\t\t// (and it is not enforced explicitly)\r\n\t\treturn this.usesNationalPrefix() && !this.nationalPrefixIsOptionalWhenFormattingInNationalFormat()\r\n\t}\r\n\r\n\t// Checks whether national prefix formatting rule contains national prefix.\r\n\tusesNationalPrefix() {\r\n\t\treturn this.nationalPrefixFormattingRule() &&\r\n\t\t\t// Check that national prefix formatting rule is not a \"dummy\" one.\r\n\t\t\t!FIRST_GROUP_ONLY_PREFIX_PATTERN.test(this.nationalPrefixFormattingRule())\r\n\t\t\t// In compressed metadata, `this.nationalPrefixFormattingRule()` is `0`\r\n\t\t\t// when `national_prefix_formatting_rule` is not present.\r\n\t\t\t// So, `true` or `false` are returned explicitly here, so that\r\n\t\t\t// `0` number isn't returned.\r\n\t\t\t? true\r\n\t\t\t: false\r\n\t}\r\n\r\n\tinternationalFormat() {\r\n\t\treturn this._format[5] || this.format()\r\n\t}\r\n}\r\n\r\n/**\r\n * A pattern that is used to determine if the national prefix formatting rule\r\n * has the first group only, i.e., does not start with the national prefix.\r\n * Note that the pattern explicitly allows for unbalanced parentheses.\r\n */\r\nconst FIRST_GROUP_ONLY_PREFIX_PATTERN = /^\\(?\\$1\\)?$/\r\n\r\nclass Type {\r\n\tconstructor(type, metadata) {\r\n\t\tthis.type = type\r\n\t\tthis.metadata = metadata\r\n\t}\r\n\r\n\tpattern() {\r\n\t\tif (this.metadata.v1) return this.type\r\n\t\treturn this.type[0]\r\n\t}\r\n\r\n\tpossibleLengths() {\r\n\t\tif (this.metadata.v1) return\r\n\t\treturn this.type[1] || this.metadata.possibleLengths()\r\n\t}\r\n}\r\n\r\nfunction getType(types, type) {\r\n\tswitch (type) {\r\n\t\tcase 'FIXED_LINE':\r\n\t\t\treturn types[0]\r\n\t\tcase 'MOBILE':\r\n\t\t\treturn types[1]\r\n\t\tcase 'TOLL_FREE':\r\n\t\t\treturn types[2]\r\n\t\tcase 'PREMIUM_RATE':\r\n\t\t\treturn types[3]\r\n\t\tcase 'PERSONAL_NUMBER':\r\n\t\t\treturn types[4]\r\n\t\tcase 'VOICEMAIL':\r\n\t\t\treturn types[5]\r\n\t\tcase 'UAN':\r\n\t\t\treturn types[6]\r\n\t\tcase 'PAGER':\r\n\t\t\treturn types[7]\r\n\t\tcase 'VOIP':\r\n\t\t\treturn types[8]\r\n\t\tcase 'SHARED_COST':\r\n\t\t\treturn types[9]\r\n\t}\r\n}\r\n\r\nexport function validateMetadata(metadata) {\r\n\tif (!metadata) {\r\n\t\tthrow new Error('[libphonenumber-js] `metadata` argument not passed. Check your arguments.')\r\n\t}\r\n\r\n\t// `country_phone_code_to_countries` was renamed to `country_calling_codes` in `1.0.18`.\r\n\t// For that reason, it's not used in this detection algorithm.\r\n\t// Instead, it detects by `countries: {}` property existence.\r\n\tif (!isObject(metadata) || !isObject(metadata.countries)) {\r\n\t\tthrow new Error(`[libphonenumber-js] \\`metadata\\` argument was passed but it's not a valid metadata. Must be an object having \\`.countries\\` child object property. Got ${isObject(metadata) ? 'an object of shape: { ' + Object.keys(metadata).join(', ') + ' }' : 'a ' + typeOf(metadata) + ': ' + metadata}.`)\r\n\t}\r\n}\r\n\r\n// Babel transforms `typeof` into some \"branches\"\r\n// so istanbul will show this as \"branch not covered\".\r\n/* istanbul ignore next */\r\nconst typeOf = _ => typeof _\r\n\r\n/**\r\n * Returns extension prefix for a country.\r\n * @param  {string} country\r\n * @param  {object} metadata\r\n * @return {string?}\r\n * @example\r\n * // Returns \" ext. \"\r\n * getExtPrefix(\"US\")\r\n */\r\nexport function getExtPrefix(country, metadata) {\r\n\tmetadata = new Metadata(metadata)\r\n\tif (metadata.hasCountry(country)) {\r\n\t\treturn metadata.selectNumberingPlan(country).ext()\r\n\t}\r\n\treturn DEFAULT_EXT_PREFIX\r\n}\r\n\r\n/**\r\n * Returns \"country calling code\" for a country.\r\n * Throws an error if the country doesn't exist or isn't supported by this library.\r\n * @param  {string} country\r\n * @param  {object} metadata\r\n * @return {string}\r\n * @example\r\n * // Returns \"44\"\r\n * getCountryCallingCode(\"GB\")\r\n */\r\nexport function getCountryCallingCode(country, metadata) {\r\n\tmetadata = new Metadata(metadata)\r\n\tif (metadata.hasCountry(country)) {\r\n\t\treturn metadata.selectNumberingPlan(country).countryCallingCode()\r\n\t}\r\n\tthrow new Error(`Unknown country: ${country}`)\r\n}\r\n\r\nexport function isSupportedCountry(country, metadata) {\r\n\t// metadata = new Metadata(metadata)\r\n\t// return metadata.hasCountry(country)\r\n\treturn metadata.countries.hasOwnProperty(country)\r\n}\r\n\r\nfunction setVersion(metadata) {\r\n\tconst { version } = metadata\r\n\tif (typeof version === 'number') {\r\n\t\tthis.v1 = version === 1\r\n\t\tthis.v2 = version === 2\r\n\t\tthis.v3 = version === 3\r\n\t\tthis.v4 = version === 4\r\n\t} else {\r\n\t\tif (!version) {\r\n\t\t\tthis.v1 = true\r\n\t\t} else if (compare(version, V3) === -1) {\r\n\t\t\tthis.v2 = true\r\n\t\t} else if (compare(version, V4) === -1) {\r\n\t\t\tthis.v3 = true\r\n\t\t} else {\r\n\t\t\tthis.v4 = true\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// const ISO_COUNTRY_CODE = /^[A-Z]{2}$/\r\n// function isCountryCode(countryCode) {\r\n// \treturn ISO_COUNTRY_CODE.test(countryCodeOrCountryCallingCode)\r\n// }","// Copy-pasted from:\r\n// https://github.com/substack/semver-compare/blob/master/index.js\r\n//\r\n// Inlining this function because some users reported issues with\r\n// importing from `semver-compare` in a browser with ES6 \"native\" modules.\r\n//\r\n// Fixes `semver-compare` not being able to compare versions with alpha/beta/etc \"tags\".\r\n// https://github.com/catamphetamine/libphonenumber-js/issues/381\r\nexport default function(a, b) {\r\n    a = a.split('-')\r\n    b = b.split('-')\r\n    var pa = a[0].split('.')\r\n    var pb = b[0].split('.')\r\n    for (var i = 0; i < 3; i++) {\r\n        var na = Number(pa[i])\r\n        var nb = Number(pb[i])\r\n        if (na > nb) return 1\r\n        if (nb > na) return -1\r\n        if (!isNaN(na) && isNaN(nb)) return 1\r\n        if (isNaN(na) && !isNaN(nb)) return -1\r\n    }\r\n    if (a[1] && b[1]) {\r\n        return a[1] > b[1] ? 1 : (a[1] < b[1] ? -1 : 0)\r\n    }\r\n    return !a[1] && b[1] ? 1 : (a[1] && !b[1] ? -1 : 0)\r\n}","/**\r\n * Merges two arrays.\r\n * @param  {*} a\r\n * @param  {*} b\r\n * @return {*}\r\n */\r\nexport default function mergeArrays(a, b) {\r\n\tconst merged = a.slice()\r\n\r\n\tfor (const element of b) {\r\n\t\tif (a.indexOf(element) < 0) {\r\n\t\t\tmerged.push(element)\r\n\t\t}\r\n\t}\r\n\r\n\treturn merged.sort((a, b) => a - b)\r\n\r\n\t// ES6 version, requires Set polyfill.\r\n\t// let merged = new Set(a)\r\n\t// for (const element of b) {\r\n\t// \tmerged.add(i)\r\n\t// }\r\n\t// return Array.from(merged).sort((a, b) => a - b)\r\n}","// These mappings map a character (key) to a specific digit that should\r\n// replace it for normalization purposes. Non-European digits that\r\n// may be used in phone numbers are mapped to a European equivalent.\r\n//\r\n// E.g. in Iraq they don't write `+442323234` but rather `+٤٤٢٣٢٣٢٣٤`.\r\n//\r\nexport const DIGITS = {\r\n\t'0': '0',\r\n\t'1': '1',\r\n\t'2': '2',\r\n\t'3': '3',\r\n\t'4': '4',\r\n\t'5': '5',\r\n\t'6': '6',\r\n\t'7': '7',\r\n\t'8': '8',\r\n\t'9': '9',\r\n\t'\\uFF10': '0', // Fullwidth digit 0\r\n\t'\\uFF11': '1', // Fullwidth digit 1\r\n\t'\\uFF12': '2', // Fullwidth digit 2\r\n\t'\\uFF13': '3', // Fullwidth digit 3\r\n\t'\\uFF14': '4', // Fullwidth digit 4\r\n\t'\\uFF15': '5', // Fullwidth digit 5\r\n\t'\\uFF16': '6', // Fullwidth digit 6\r\n\t'\\uFF17': '7', // Fullwidth digit 7\r\n\t'\\uFF18': '8', // Fullwidth digit 8\r\n\t'\\uFF19': '9', // Fullwidth digit 9\r\n\t'\\u0660': '0', // Arabic-indic digit 0\r\n\t'\\u0661': '1', // Arabic-indic digit 1\r\n\t'\\u0662': '2', // Arabic-indic digit 2\r\n\t'\\u0663': '3', // Arabic-indic digit 3\r\n\t'\\u0664': '4', // Arabic-indic digit 4\r\n\t'\\u0665': '5', // Arabic-indic digit 5\r\n\t'\\u0666': '6', // Arabic-indic digit 6\r\n\t'\\u0667': '7', // Arabic-indic digit 7\r\n\t'\\u0668': '8', // Arabic-indic digit 8\r\n\t'\\u0669': '9', // Arabic-indic digit 9\r\n\t'\\u06F0': '0', // Eastern-Arabic digit 0\r\n\t'\\u06F1': '1', // Eastern-Arabic digit 1\r\n\t'\\u06F2': '2', // Eastern-Arabic digit 2\r\n\t'\\u06F3': '3', // Eastern-Arabic digit 3\r\n\t'\\u06F4': '4', // Eastern-Arabic digit 4\r\n\t'\\u06F5': '5', // Eastern-Arabic digit 5\r\n\t'\\u06F6': '6', // Eastern-Arabic digit 6\r\n\t'\\u06F7': '7', // Eastern-Arabic digit 7\r\n\t'\\u06F8': '8', // Eastern-Arabic digit 8\r\n\t'\\u06F9': '9'  // Eastern-Arabic digit 9\r\n}\r\n\r\nexport function parseDigit(character) {\r\n\treturn DIGITS[character]\r\n}\r\n\r\n/**\r\n * Parses phone number digits from a string.\r\n * Drops all punctuation leaving only digits.\r\n * Also converts wide-ascii and arabic-indic numerals to conventional numerals.\r\n * E.g. in Iraq they don't write `+442323234` but rather `+٤٤٢٣٢٣٢٣٤`.\r\n * @param  {string} string\r\n * @return {string}\r\n * @example\r\n * ```js\r\n * parseDigits('8 (800) 555')\r\n * // Outputs '8800555'.\r\n * ```\r\n */\r\nexport default function parseDigits(string) {\r\n\tlet result = ''\r\n\t// Using `.split('')` here instead of normal `for ... of`\r\n\t// because the importing application doesn't neccessarily include an ES6 polyfill.\r\n\t// The `.split('')` approach discards \"exotic\" UTF-8 characters\r\n\t// (the ones consisting of four bytes) but digits\r\n\t// (including non-European ones) don't fall into that range\r\n\t// so such \"exotic\" characters would be discarded anyway.\r\n\tfor (const character of string.split('')) {\r\n\t\tconst digit = parseDigit(character)\r\n\t\tif (digit) {\r\n\t\t\tresult += digit\r\n\t\t}\r\n\t}\r\n\treturn result\r\n}","import Metadata, { validateMetadata } from './metadata.js'\r\nimport isPossibleNumber from './isPossible.js'\r\nimport isValidNumber from './isValid.js'\r\nimport getNumberType from './helpers/getNumberType.js'\r\nimport getPossibleCountriesForNumber from './helpers/getPossibleCountriesForNumber.js'\r\nimport extractCountryCallingCode from './helpers/extractCountryCallingCode.js'\r\nimport isObject from './helpers/isObject.js'\r\nimport formatNumber from './format.js'\r\n\r\nconst USE_NON_GEOGRAPHIC_COUNTRY_CODE = false\r\n\r\nexport default class PhoneNumber {\r\n\t/**\r\n\t * @param  {string} countryOrCountryCallingCode\r\n\t * @param  {string} nationalNumber\r\n\t * @param  {object} metadata — Metadata JSON\r\n\t * @return {PhoneNumber}\r\n\t */\r\n\tconstructor(countryOrCountryCallingCode, nationalNumber, metadata) {\r\n\t\t// Validate `countryOrCountryCallingCode` argument.\r\n\t\tif (!countryOrCountryCallingCode) {\r\n\t\t\tthrow new TypeError('First argument is required')\r\n\t\t}\r\n\t\tif (typeof countryOrCountryCallingCode !== 'string') {\r\n\t\t\tthrow new TypeError('First argument must be a string')\r\n\t\t}\r\n\r\n\t\t// In case of public API use: `constructor(number, metadata)`.\r\n\t\t// Transform the arguments from `constructor(number, metadata)` to\r\n\t\t// `constructor(countryOrCountryCallingCode, nationalNumber, metadata)`.\r\n\t\tif (countryOrCountryCallingCode[0] === '+' && !nationalNumber) {\r\n\t\t\tthrow new TypeError('`metadata` argument not passed')\r\n\t\t}\r\n\t\tif (isObject(nationalNumber) && isObject(nationalNumber.countries)) {\r\n\t\t\tmetadata = nationalNumber\r\n\t\t\tconst e164Number = countryOrCountryCallingCode\r\n\t\t\tif (!E164_NUMBER_REGEXP.test(e164Number)) {\r\n\t\t\t\tthrow new Error('Invalid `number` argument passed: must consist of a \"+\" followed by digits')\r\n\t\t\t}\r\n\t\t\tconst { countryCallingCode, number } = extractCountryCallingCode(e164Number, undefined, undefined, undefined, metadata)\r\n\t\t\tnationalNumber = number\r\n\t\t\tcountryOrCountryCallingCode = countryCallingCode\r\n\t\t\tif (!nationalNumber) {\r\n\t\t\t\tthrow new Error('Invalid `number` argument passed: too short')\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Validate `nationalNumber` argument.\r\n\t\tif (!nationalNumber) {\r\n\t\t\tthrow new TypeError('`nationalNumber` argument is required')\r\n\t\t}\r\n\t\tif (typeof nationalNumber !== 'string') {\r\n\t\t\tthrow new TypeError('`nationalNumber` argument must be a string')\r\n\t\t}\r\n\r\n\t\t// Validate `metadata` argument.\r\n\t\tvalidateMetadata(metadata)\r\n\r\n\t\t// Initialize properties.\r\n\t\tconst { country, countryCallingCode } = getCountryAndCountryCallingCode(\r\n\t\t\tcountryOrCountryCallingCode,\r\n\t\t\tmetadata\r\n\t\t)\r\n\t\tthis.country = country\r\n\t\tthis.countryCallingCode = countryCallingCode\r\n\t\tthis.nationalNumber = nationalNumber\r\n\t\tthis.number = '+' + this.countryCallingCode + this.nationalNumber\r\n\t\t// Exclude `metadata` property output from `PhoneNumber.toString()`\r\n\t\t// so that it doesn't clutter the console output of Node.js.\r\n\t\t// Previously, when Node.js did `console.log(new PhoneNumber(...))`,\r\n\t\t// it would output the whole internal structure of the `metadata` object.\r\n\t\tthis.getMetadata = () => metadata\r\n\t}\r\n\r\n\tsetExt(ext) {\r\n\t\tthis.ext = ext\r\n\t}\r\n\r\n\tgetPossibleCountries() {\r\n\t\tif (this.country) {\r\n\t\t\treturn [this.country]\r\n\t\t}\r\n\t\treturn getPossibleCountriesForNumber(\r\n\t\t\tthis.countryCallingCode,\r\n\t\t\tthis.nationalNumber,\r\n\t\t\tthis.getMetadata()\r\n\t\t)\r\n\t}\r\n\r\n\tisPossible() {\r\n\t\treturn isPossibleNumber(this, { v2: true }, this.getMetadata())\r\n\t}\r\n\r\n\tisValid() {\r\n\t\treturn isValidNumber(this, { v2: true }, this.getMetadata())\r\n\t}\r\n\r\n\tisNonGeographic() {\r\n\t\tconst metadata = new Metadata(this.getMetadata())\r\n\t\treturn metadata.isNonGeographicCallingCode(this.countryCallingCode)\r\n\t}\r\n\r\n\tisEqual(phoneNumber) {\r\n\t\treturn this.number === phoneNumber.number && this.ext === phoneNumber.ext\r\n\t}\r\n\r\n\t// This function was originally meant to be an equivalent for `validatePhoneNumberLength()`,\r\n\t// but later it was found out that it doesn't include the possible `TOO_SHORT` result\r\n\t// returned from `parsePhoneNumberWithError()` in the original `validatePhoneNumberLength()`,\r\n\t// so eventually I simply commented out this method from the `PhoneNumber` class\r\n\t// and just left the `validatePhoneNumberLength()` function, even though that one would require\r\n\t// and additional step to also validate the actual country / calling code of the phone number.\r\n\t// validateLength() {\r\n\t// \tconst metadata = new Metadata(this.getMetadata())\r\n\t// \tmetadata.selectNumberingPlan(this.countryCallingCode)\r\n\t// \tconst result = checkNumberLength(this.nationalNumber, metadata)\r\n\t// \tif (result !== 'IS_POSSIBLE') {\r\n\t// \t\treturn result\r\n\t// \t}\r\n\t// }\r\n\r\n\tgetType() {\r\n\t\treturn getNumberType(this, { v2: true }, this.getMetadata())\r\n\t}\r\n\r\n\tformat(format, options) {\r\n\t\treturn formatNumber(\r\n\t\t\tthis,\r\n\t\t\tformat,\r\n\t\t\toptions ? { ...options, v2: true } : { v2: true },\r\n\t\t\tthis.getMetadata()\r\n\t\t)\r\n\t}\r\n\r\n\tformatNational(options) {\r\n\t\treturn this.format('NATIONAL', options)\r\n\t}\r\n\r\n\tformatInternational(options) {\r\n\t\treturn this.format('INTERNATIONAL', options)\r\n\t}\r\n\r\n\tgetURI(options) {\r\n\t\treturn this.format('RFC3966', options)\r\n\t}\r\n}\r\n\r\nconst isCountryCode = (value) => /^[A-Z]{2}$/.test(value)\r\n\r\nfunction getCountryAndCountryCallingCode(countryOrCountryCallingCode, metadataJson) {\r\n\tlet country\r\n\tlet countryCallingCode\r\n\r\n\tconst metadata = new Metadata(metadataJson)\r\n\t// If country code is passed then derive `countryCallingCode` from it.\r\n\t// Also store the country code as `.country`.\r\n\tif (isCountryCode(countryOrCountryCallingCode)) {\r\n\t\tcountry = countryOrCountryCallingCode\r\n\t\tmetadata.selectNumberingPlan(country)\r\n\t\tcountryCallingCode = metadata.countryCallingCode()\r\n\t} else {\r\n\t\tcountryCallingCode = countryOrCountryCallingCode\r\n\t\t/* istanbul ignore if */\r\n\t\tif (USE_NON_GEOGRAPHIC_COUNTRY_CODE) {\r\n\t\t\tif (metadata.isNonGeographicCallingCode(countryCallingCode)) {\r\n\t\t\t\tcountry = '001'\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn {\r\n\t\tcountry,\r\n\t\tcountryCallingCode\r\n\t}\r\n}\r\n\r\nconst E164_NUMBER_REGEXP = /^\\+\\d+$/","import {\r\n\tDIGIT_PLACEHOLDER,\r\n\tcountOccurences,\r\n\trepeat,\r\n\tcutAndStripNonPairedParens,\r\n\tcloseNonPairedParens,\r\n\tstripNonPairedParens,\r\n\tpopulateTemplateWithDigits\r\n} from './AsYouTypeFormatter.util.js'\r\n\r\nimport formatCompleteNumber, {\r\n\tcanFormatCompleteNumber\r\n} from './AsYouTypeFormatter.complete.js'\r\n\r\nimport PatternMatcher from './AsYouTypeFormatter.PatternMatcher.js'\r\n\r\nimport parseDigits from './helpers/parseDigits.js'\r\nexport { DIGIT_PLACEHOLDER } from './AsYouTypeFormatter.util.js'\r\nimport { FIRST_GROUP_PATTERN } from './helpers/formatNationalNumberUsingFormat.js'\r\nimport { VALID_PUNCTUATION } from './constants.js'\r\nimport applyInternationalSeparatorStyle from './helpers/applyInternationalSeparatorStyle.js'\r\n\r\n// Used in phone number format template creation.\r\n// Could be any digit, I guess.\r\nconst DUMMY_DIGIT = '9'\r\n// I don't know why is it exactly `15`\r\nconst LONGEST_NATIONAL_PHONE_NUMBER_LENGTH = 15\r\n// Create a phone number consisting only of the digit 9 that matches the\r\n// `number_pattern` by applying the pattern to the \"longest phone number\" string.\r\nconst LONGEST_DUMMY_PHONE_NUMBER = repeat(DUMMY_DIGIT, LONGEST_NATIONAL_PHONE_NUMBER_LENGTH)\r\n\r\n// A set of characters that, if found in a national prefix formatting rules, are an indicator to\r\n// us that we should separate the national prefix from the number when formatting.\r\nconst NATIONAL_PREFIX_SEPARATORS_PATTERN = /[- ]/\r\n\r\n// Deprecated: Google has removed some formatting pattern related code from their repo.\r\n// https://github.com/googlei18n/libphonenumber/commit/a395b4fef3caf57c4bc5f082e1152a4d2bd0ba4c\r\n// \"We no longer have numbers in formatting matching patterns, only \\d.\"\r\n// Because this library supports generating custom metadata\r\n// some users may still be using old metadata so the relevant\r\n// code seems to stay until some next major version update.\r\nconst SUPPORT_LEGACY_FORMATTING_PATTERNS = true\r\n\r\n// A pattern that is used to match character classes in regular expressions.\r\n// An example of a character class is \"[1-4]\".\r\nconst CREATE_CHARACTER_CLASS_PATTERN = SUPPORT_LEGACY_FORMATTING_PATTERNS && (() => /\\[([^\\[\\]])*\\]/g)\r\n\r\n// Any digit in a regular expression that actually denotes a digit. For\r\n// example, in the regular expression \"80[0-2]\\d{6,10}\", the first 2 digits\r\n// (8 and 0) are standalone digits, but the rest are not.\r\n// Two look-aheads are needed because the number following \\\\d could be a\r\n// two-digit number, since the phone number can be as long as 15 digits.\r\nconst CREATE_STANDALONE_DIGIT_PATTERN = SUPPORT_LEGACY_FORMATTING_PATTERNS && (() => /\\d(?=[^,}][^,}])/g)\r\n\r\n// A regular expression that is used to determine if a `format` is\r\n// suitable to be used in the \"as you type formatter\".\r\n// A `format` is suitable when the resulting formatted number has\r\n// the same digits as the user has entered.\r\n//\r\n// In the simplest case, that would mean that the format\r\n// doesn't add any additional digits when formatting a number.\r\n// Google says that it also shouldn't add \"star\" (`*`) characters,\r\n// like it does in some Israeli formats.\r\n// Such basic format would only contain \"valid punctuation\"\r\n// and \"captured group\" identifiers ($1, $2, etc).\r\n//\r\n// An example of a format that adds additional digits:\r\n//\r\n// Country: `AR` (Argentina).\r\n// Format:\r\n// {\r\n//    \"pattern\": \"(\\\\d)(\\\\d{2})(\\\\d{4})(\\\\d{4})\",\r\n//    \"leading_digits_patterns\": [\"91\"],\r\n//    \"national_prefix_formatting_rule\": \"0$1\",\r\n//    \"format\": \"$2 15-$3-$4\",\r\n//    \"international_format\": \"$1 $2 $3-$4\"\r\n// }\r\n//\r\n// In the format above, the `format` adds `15` to the digits when formatting a number.\r\n// A sidenote: this format actually is suitable because `national_prefix_for_parsing`\r\n// has previously removed `15` from a national number, so re-adding `15` in `format`\r\n// doesn't actually result in any extra digits added to user's input.\r\n// But verifying that would be a complex procedure, so the code chooses a simpler path:\r\n// it simply filters out all `format`s that contain anything but \"captured group\" ids.\r\n//\r\n// This regular expression is called `ELIGIBLE_FORMAT_PATTERN` in Google's\r\n// `libphonenumber` code.\r\n//\r\nconst NON_ALTERING_FORMAT_REG_EXP = new RegExp(\r\n\t'[' + VALID_PUNCTUATION + ']*' +\r\n\t// Google developers say:\r\n\t// \"We require that the first matching group is present in the\r\n\t//  output pattern to ensure no data is lost while formatting.\"\r\n\t'\\\\$1' +\r\n\t'[' + VALID_PUNCTUATION + ']*' +\r\n\t'(\\\\$\\\\d[' + VALID_PUNCTUATION + ']*)*' +\r\n\t'$'\r\n)\r\n\r\n// This is the minimum length of the leading digits of a phone number\r\n// to guarantee the first \"leading digits pattern\" for a phone number format\r\n// to be preemptive.\r\nconst MIN_LEADING_DIGITS_LENGTH = 3\r\n\r\nexport default class AsYouTypeFormatter {\r\n\tconstructor({\r\n\t\tstate,\r\n\t\tmetadata\r\n\t}) {\r\n\t\tthis.metadata = metadata\r\n\t\tthis.resetFormat()\r\n\t}\r\n\r\n\tresetFormat() {\r\n\t\tthis.chosenFormat = undefined\r\n\t\tthis.template = undefined\r\n\t\tthis.nationalNumberTemplate = undefined\r\n\t\tthis.populatedNationalNumberTemplate = undefined\r\n\t\tthis.populatedNationalNumberTemplatePosition = -1\r\n\t}\r\n\r\n\treset(numberingPlan, state) {\r\n\t\tthis.resetFormat()\r\n\t\tif (numberingPlan) {\r\n\t\t\tthis.isNANP = numberingPlan.callingCode() === '1'\r\n\t\t\tthis.matchingFormats = numberingPlan.formats()\r\n\t\t\tif (state.nationalSignificantNumber) {\r\n\t\t\t\tthis.narrowDownMatchingFormats(state)\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tthis.isNANP = undefined\r\n\t\t\tthis.matchingFormats = []\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Formats an updated phone number.\r\n\t * @param  {string} nextDigits — Additional phone number digits.\r\n\t * @param  {object} state — `AsYouType` state.\r\n\t * @return {[string]} Returns undefined if the updated phone number can't be formatted using any of the available formats.\r\n\t */\r\n\tformat(nextDigits, state) {\r\n\t\t// See if the phone number digits can be formatted as a complete phone number.\r\n\t\t// If not, use the results from `formatNationalNumberWithNextDigits()`,\r\n\t\t// which formats based on the chosen formatting pattern.\r\n\t\t//\r\n\t\t// Attempting to format complete phone number first is how it's done\r\n\t\t// in Google's `libphonenumber`, so this library just follows it.\r\n\t\t// Google's `libphonenumber` code doesn't explain in detail why does it\r\n\t\t// attempt to format digits as a complete phone number\r\n\t\t// instead of just going with a previoulsy (or newly) chosen `format`:\r\n\t\t//\r\n\t\t// \"Checks to see if there is an exact pattern match for these digits.\r\n\t\t//  If so, we should use this instead of any other formatting template\r\n\t\t//  whose leadingDigitsPattern also matches the input.\"\r\n\t\t//\r\n\t\tif (canFormatCompleteNumber(state.nationalSignificantNumber, state.country, this.metadata)) {\r\n\t\t\tfor (const format of this.matchingFormats) {\r\n\t\t\t\tconst formattedCompleteNumber = formatCompleteNumber(\r\n\t\t\t\t\tstate,\r\n\t\t\t\t\tformat,\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tmetadata: this.metadata,\r\n\t\t\t\t\t\tshouldTryNationalPrefixFormattingRule: (format) => this.shouldTryNationalPrefixFormattingRule(format, {\r\n\t\t\t\t\t\t\tinternational: state.international,\r\n\t\t\t\t\t\t\tnationalPrefix: state.nationalPrefix\r\n\t\t\t\t\t\t}),\r\n\t\t\t\t\t\tgetSeparatorAfterNationalPrefix: (format) => this.getSeparatorAfterNationalPrefix(format)\r\n\t\t\t\t\t}\r\n\t\t\t\t)\r\n\t\t\t\tif (formattedCompleteNumber) {\r\n\t\t\t\t\tthis.resetFormat()\r\n\t\t\t\t\tthis.chosenFormat = format\r\n\t\t\t\t\tthis.setNationalNumberTemplate(formattedCompleteNumber.replace(/\\d/g, DIGIT_PLACEHOLDER), state)\r\n\t\t\t\t\tthis.populatedNationalNumberTemplate = formattedCompleteNumber\r\n\t\t\t\t\t// With a new formatting template, the matched position\r\n\t\t\t\t\t// using the old template needs to be reset.\r\n\t\t\t\t\tthis.populatedNationalNumberTemplatePosition = this.template.lastIndexOf(DIGIT_PLACEHOLDER)\r\n\t\t\t\t\treturn formattedCompleteNumber\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t}\r\n\t\t// Format the digits as a partial (incomplete) phone number\r\n\t\t// using the previously chosen formatting pattern (or a newly chosen one).\r\n\t\treturn this.formatNationalNumberWithNextDigits(nextDigits, state)\r\n\t}\r\n\r\n\t// Formats the next phone number digits.\r\n\tformatNationalNumberWithNextDigits(nextDigits, state) {\r\n\t\tconst previouslyChosenFormat = this.chosenFormat\r\n\r\n\t\t// Choose a format from the list of matching ones.\r\n\t\tconst newlyChosenFormat = this.chooseFormat(state)\r\n\r\n\t\tif (newlyChosenFormat) {\r\n\t\t\tif (newlyChosenFormat === previouslyChosenFormat) {\r\n\t\t\t\t// If it can format the next (current) digits\r\n\t\t\t\t// using the previously chosen phone number format\r\n\t\t\t\t// then return the updated formatted number.\r\n\t\t\t\treturn this.formatNextNationalNumberDigits(nextDigits)\r\n\t\t\t} else {\r\n\t\t\t\t// If a more appropriate phone number format\r\n\t\t\t\t// has been chosen for these \"leading digits\",\r\n\t\t\t\t// then re-format the national phone number part\r\n\t\t\t\t// using the newly selected format.\r\n\t\t\t\treturn this.formatNextNationalNumberDigits(state.getNationalDigits())\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tnarrowDownMatchingFormats({\r\n\t\tnationalSignificantNumber,\r\n\t\tnationalPrefix,\r\n\t\tinternational\r\n\t}) {\r\n\t\tconst leadingDigits = nationalSignificantNumber\r\n\r\n\t\t// \"leading digits\" pattern list starts with a\r\n\t\t// \"leading digits\" pattern fitting a maximum of 3 leading digits.\r\n\t\t// So, after a user inputs 3 digits of a national (significant) phone number\r\n\t\t// this national (significant) number can already be formatted.\r\n\t\t// The next \"leading digits\" pattern is for 4 leading digits max,\r\n\t\t// and the \"leading digits\" pattern after it is for 5 leading digits max, etc.\r\n\r\n\t\t// This implementation is different from Google's\r\n\t\t// in that it searches for a fitting format\r\n\t\t// even if the user has entered less than\r\n\t\t// `MIN_LEADING_DIGITS_LENGTH` digits of a national number.\r\n\t\t// Because some leading digit patterns already match for a single first digit.\r\n\t\tlet leadingDigitsPatternIndex = leadingDigits.length - MIN_LEADING_DIGITS_LENGTH\r\n\t\tif (leadingDigitsPatternIndex < 0) {\r\n\t\t\tleadingDigitsPatternIndex = 0\r\n\t\t}\r\n\r\n\t\tthis.matchingFormats = this.matchingFormats.filter(\r\n\t\t\tformat => this.formatSuits(format, international, nationalPrefix)\r\n\t\t\t\t&& this.formatMatches(format, leadingDigits, leadingDigitsPatternIndex)\r\n\t\t)\r\n\r\n\t\t// If there was a phone number format chosen\r\n\t\t// and it no longer holds given the new leading digits then reset it.\r\n\t\t// The test for this `if` condition is marked as:\r\n\t\t// \"Reset a chosen format when it no longer holds given the new leading digits\".\r\n\t\t// To construct a valid test case for this one can find a country\r\n\t\t// in `PhoneNumberMetadata.xml` yielding one format for 3 `<leadingDigits>`\r\n\t\t// and yielding another format for 4 `<leadingDigits>` (Australia in this case).\r\n\t\tif (this.chosenFormat && this.matchingFormats.indexOf(this.chosenFormat) === -1) {\r\n\t\t\tthis.resetFormat()\r\n\t\t}\r\n\t}\r\n\r\n\tformatSuits(format, international, nationalPrefix) {\r\n\t\t// When a prefix before a national (significant) number is\r\n\t\t// simply a national prefix, then it's parsed as `this.nationalPrefix`.\r\n\t\t// In more complex cases, a prefix before national (significant) number\r\n\t\t// could include a national prefix as well as some \"capturing groups\",\r\n\t\t// and in that case there's no info whether a national prefix has been parsed.\r\n\t\t// If national prefix is not used when formatting a phone number\r\n\t\t// using this format, but a national prefix has been entered by the user,\r\n\t\t// and was extracted, then discard such phone number format.\r\n\t\t// In Google's \"AsYouType\" formatter code, the equivalent would be this part:\r\n\t\t// https://github.com/google/libphonenumber/blob/0a45cfd96e71cad8edb0e162a70fcc8bd9728933/java/libphonenumber/src/com/google/i18n/phonenumbers/AsYouTypeFormatter.java#L175-L184\r\n\t\tif (nationalPrefix &&\r\n\t\t\t!format.usesNationalPrefix() &&\r\n\t\t\t// !format.domesticCarrierCodeFormattingRule() &&\r\n\t\t\t!format.nationalPrefixIsOptionalWhenFormattingInNationalFormat()) {\r\n\t\t\treturn false\r\n\t\t}\r\n\t\t// If national prefix is mandatory for this phone number format\r\n\t\t// and there're no guarantees that a national prefix is present in user input\r\n\t\t// then discard this phone number format as not suitable.\r\n\t\t// In Google's \"AsYouType\" formatter code, the equivalent would be this part:\r\n\t\t// https://github.com/google/libphonenumber/blob/0a45cfd96e71cad8edb0e162a70fcc8bd9728933/java/libphonenumber/src/com/google/i18n/phonenumbers/AsYouTypeFormatter.java#L185-L193\r\n\t\tif (!international &&\r\n\t\t\t!nationalPrefix &&\r\n\t\t\tformat.nationalPrefixIsMandatoryWhenFormattingInNationalFormat()) {\r\n\t\t\treturn false\r\n\t\t}\r\n\t\treturn true\r\n\t}\r\n\r\n\tformatMatches(format, leadingDigits, leadingDigitsPatternIndex) {\r\n\t\tconst leadingDigitsPatternsCount = format.leadingDigitsPatterns().length\r\n\r\n\t\t// If this format is not restricted to a certain\r\n\t\t// leading digits pattern then it fits.\r\n\t\t// The test case could be found by searching for \"leadingDigitsPatternsCount === 0\".\r\n\t\tif (leadingDigitsPatternsCount === 0) {\r\n\t\t\treturn true\r\n\t\t}\r\n\r\n\t\t// Start narrowing down the list of possible formats based on the leading digits.\r\n\t\t// (only previously matched formats take part in the narrowing down process)\r\n\r\n\t\t// `leading_digits_patterns` start with 3 digits min\r\n\t\t// and then go up from there one digit at a time.\r\n\t\tleadingDigitsPatternIndex = Math.min(leadingDigitsPatternIndex, leadingDigitsPatternsCount - 1)\r\n\t\tconst leadingDigitsPattern = format.leadingDigitsPatterns()[leadingDigitsPatternIndex]\r\n\r\n\t\t// Google imposes a requirement on the leading digits\r\n\t\t// to be minimum 3 digits long in order to be eligible\r\n\t\t// for checking those with a leading digits pattern.\r\n\t\t//\r\n\t\t// Since `leading_digits_patterns` start with 3 digits min,\r\n\t\t// Google's original `libphonenumber` library only starts\r\n\t\t// excluding any non-matching formats only when the\r\n\t\t// national number entered so far is at least 3 digits long,\r\n\t\t// otherwise format matching would give false negatives.\r\n\t\t//\r\n\t\t// For example, when the digits entered so far are `2`\r\n\t\t// and the leading digits pattern is `21` –\r\n\t\t// it's quite obvious in this case that the format could be the one\r\n\t\t// but due to the absence of further digits it would give false negative.\r\n\t\t//\r\n\t\t// Also, `leading_digits_patterns` doesn't always correspond to a single\r\n\t\t// digits count. For example, `60|8` pattern would already match `8`\r\n\t\t// but the `60` part would require having at least two leading digits,\r\n\t\t// so the whole pattern would require inputting two digits first in order to\r\n\t\t// decide on whether it matches the input, even when the input is \"80\".\r\n\t\t//\r\n\t\t// This library — `libphonenumber-js` — allows filtering by `leading_digits_patterns`\r\n\t\t// even when there's only 1 or 2 digits of the national (significant) number.\r\n\t\t// To do that, it uses a non-strict pattern matcher written specifically for that.\r\n\t\t//\r\n\t\tif (leadingDigits.length < MIN_LEADING_DIGITS_LENGTH) {\r\n\t\t\t// Before leading digits < 3 matching was implemented:\r\n\t\t\t// return true\r\n\t\t\t//\r\n\t\t\t// After leading digits < 3 matching was implemented:\r\n\t\t\ttry {\r\n\t\t\t\treturn new PatternMatcher(leadingDigitsPattern).match(leadingDigits, { allowOverflow: true }) !== undefined\r\n\t\t\t} catch (error) /* istanbul ignore next */ {\r\n\t\t\t\t// There's a slight possibility that there could be some undiscovered bug\r\n\t\t\t\t// in the pattern matcher code. Since the \"leading digits < 3 matching\"\r\n\t\t\t\t// feature is not \"essential\" for operation, it can fall back to the old way\r\n\t\t\t\t// in case of any issues rather than halting the application's execution.\r\n\t\t\t\tconsole.error(error)\r\n\t\t\t\treturn true\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// If at least `MIN_LEADING_DIGITS_LENGTH` digits of a national number are\r\n\t\t// available then use the usual regular expression matching.\r\n\t\t//\r\n\t\t// The whole pattern is wrapped in round brackets (`()`) because\r\n\t\t// the pattern can use \"or\" operator (`|`) at the top level of the pattern.\r\n\t\t//\r\n\t\treturn new RegExp(`^(${leadingDigitsPattern})`).test(leadingDigits)\r\n\t}\r\n\r\n\tgetFormatFormat(format, international) {\r\n\t\treturn international ? format.internationalFormat() : format.format()\r\n\t}\r\n\r\n\tchooseFormat(state) {\r\n\t\t// When there are multiple available formats, the formatter uses the first\r\n\t\t// format where a formatting template could be created.\r\n\t\t//\r\n\t\t// For some weird reason, `istanbul` says \"else path not taken\"\r\n\t\t// for the `for of` line below. Supposedly that means that\r\n\t\t// the loop doesn't ever go over the last element in the list.\r\n\t\t// That's true because there always is `this.chosenFormat`\r\n\t\t// when `this.matchingFormats` is non-empty.\r\n\t\t// And, for some weird reason, it doesn't think that the case\r\n\t\t// with empty `this.matchingFormats` qualifies for a valid \"else\" path.\r\n\t\t// So simply muting this `istanbul` warning.\r\n\t\t// It doesn't skip the contents of the `for of` loop,\r\n\t\t// it just skips the `for of` line.\r\n\t\t//\r\n\t\t/* istanbul ignore next */\r\n\t\tfor (const format of this.matchingFormats.slice()) {\r\n\t\t\t// If this format is currently being used\r\n\t\t\t// and is still suitable, then stick to it.\r\n\t\t\tif (this.chosenFormat === format) {\r\n\t\t\t\tbreak\r\n\t\t\t}\r\n\t\t\t// Sometimes, a formatting rule inserts additional digits in a phone number,\r\n\t\t\t// and \"as you type\" formatter can't do that: it should only use the digits\r\n\t\t\t// that the user has input.\r\n\t\t\t//\r\n\t\t\t// For example, in Argentina, there's a format for mobile phone numbers:\r\n\t\t\t//\r\n\t\t\t// {\r\n\t\t\t//    \"pattern\": \"(\\\\d)(\\\\d{2})(\\\\d{4})(\\\\d{4})\",\r\n\t\t\t//    \"leading_digits_patterns\": [\"91\"],\r\n\t\t\t//    \"national_prefix_formatting_rule\": \"0$1\",\r\n\t\t\t//    \"format\": \"$2 15-$3-$4\",\r\n\t\t\t//    \"international_format\": \"$1 $2 $3-$4\"\r\n\t\t\t// }\r\n\t\t\t//\r\n\t\t\t// In that format, `international_format` is used instead of `format`\r\n\t\t\t// because `format` inserts `15` in the formatted number,\r\n\t\t\t// and `AsYouType` formatter should only use the digits\r\n\t\t\t// the user has actually input, without adding any extra digits.\r\n\t\t\t// In this case, it wouldn't make a difference, because the `15`\r\n\t\t\t// is first stripped when applying `national_prefix_for_parsing`\r\n\t\t\t// and then re-added when using `format`, so in reality it doesn't\r\n\t\t\t// add any new digits to the number, but to detect that, the code\r\n\t\t\t// would have to be more complex: it would have to try formatting\r\n\t\t\t// the digits using the format and then see if any digits have\r\n\t\t\t// actually been added or removed, and then, every time a new digit\r\n\t\t\t// is input, it should re-check whether the chosen format doesn't\r\n\t\t\t// alter the digits.\r\n\t\t\t//\r\n\t\t\t// Google's code doesn't go that far, and so does this library:\r\n\t\t\t// it simply requires that a `format` doesn't add any additonal\r\n\t\t\t// digits to user's input.\r\n\t\t\t//\r\n\t\t\t// Also, people in general should move from inputting phone numbers\r\n\t\t\t// in national format (possibly with national prefixes)\r\n\t\t\t// and use international phone number format instead:\r\n\t\t\t// it's a logical thing in the modern age of mobile phones,\r\n\t\t\t// globalization and the internet.\r\n\t\t\t//\r\n\t\t\t/* istanbul ignore if */\r\n\t\t\tif (!NON_ALTERING_FORMAT_REG_EXP.test(this.getFormatFormat(format, state.international))) {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\t\t\tif (!this.createTemplateForFormat(format, state)) {\r\n\t\t\t\t// Remove the format if it can't generate a template.\r\n\t\t\t\tthis.matchingFormats = this.matchingFormats.filter(_ => _ !== format)\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\t\t\tthis.chosenFormat = format\r\n\t\t\tbreak\r\n\t\t}\r\n\t\tif (!this.chosenFormat) {\r\n\t\t\t// No format matches the national (significant) phone number.\r\n\t\t\tthis.resetFormat()\r\n\t\t}\r\n\t\treturn this.chosenFormat\r\n\t}\r\n\r\n\tcreateTemplateForFormat(format, state) {\r\n\t\t// The formatter doesn't format numbers when numberPattern contains '|', e.g.\r\n\t\t// (20|3)\\d{4}. In those cases we quickly return.\r\n\t\t// (Though there's no such format in current metadata)\r\n\t\t/* istanbul ignore if */\r\n\t\tif (SUPPORT_LEGACY_FORMATTING_PATTERNS && format.pattern().indexOf('|') >= 0) {\r\n\t\t\treturn\r\n\t\t}\r\n\t\t// Get formatting template for this phone number format\r\n\t\tconst template = this.getTemplateForFormat(format, state)\r\n\t\t// If the national number entered is too long\r\n\t\t// for any phone number format, then abort.\r\n\t\tif (template) {\r\n\t\t\tthis.setNationalNumberTemplate(template, state)\r\n\t\t\treturn true\r\n\t\t}\r\n\t}\r\n\r\n\tgetSeparatorAfterNationalPrefix(format) {\r\n\t\t// `US` metadata doesn't have a `national_prefix_formatting_rule`,\r\n\t\t// so the `if` condition below doesn't apply to `US`,\r\n\t\t// but in reality there shoudl be a separator\r\n\t\t// between a national prefix and a national (significant) number.\r\n\t\t// So `US` national prefix separator is a \"special\" \"hardcoded\" case.\r\n\t\tif (this.isNANP) {\r\n\t\t\treturn ' '\r\n\t\t}\r\n\t\t// If a `format` has a `national_prefix_formatting_rule`\r\n\t\t// and that rule has a separator after a national prefix,\r\n\t\t// then it means that there should be a separator\r\n\t\t// between a national prefix and a national (significant) number.\r\n\t\tif (format &&\r\n\t\t\tformat.nationalPrefixFormattingRule() &&\r\n\t\t\tNATIONAL_PREFIX_SEPARATORS_PATTERN.test(format.nationalPrefixFormattingRule())) {\r\n\t\t\treturn ' '\r\n\t\t}\r\n\t\t// At this point, there seems to be no clear evidence that\r\n\t\t// there should be a separator between a national prefix\r\n\t\t// and a national (significant) number. So don't insert one.\r\n\t\treturn ''\r\n\t}\r\n\r\n\tgetInternationalPrefixBeforeCountryCallingCode({ IDDPrefix, missingPlus }, options) {\r\n\t\tif (IDDPrefix) {\r\n\t\t\treturn options && options.spacing === false ? IDDPrefix : IDDPrefix + ' '\r\n\t\t}\r\n\t\tif (missingPlus) {\r\n\t\t\treturn ''\r\n\t\t}\r\n\t\treturn '+'\r\n\t}\r\n\r\n\tgetTemplate(state) {\r\n\t\tif (!this.template) {\r\n\t\t\treturn\r\n\t\t}\r\n\t\t// `this.template` holds the template for a \"complete\" phone number.\r\n\t\t// The currently entered phone number is most likely not \"complete\",\r\n\t\t// so trim all non-populated digits.\r\n\t\tlet index = -1\r\n\t\tlet i = 0\r\n\t\tconst internationalPrefix = state.international ? this.getInternationalPrefixBeforeCountryCallingCode(state, { spacing: false }) : ''\r\n\t\twhile (i < internationalPrefix.length + state.getDigitsWithoutInternationalPrefix().length) {\r\n\t\t\tindex = this.template.indexOf(DIGIT_PLACEHOLDER, index + 1)\r\n\t\t\ti++\r\n\t\t}\r\n\t\treturn cutAndStripNonPairedParens(this.template, index + 1)\r\n\t}\r\n\r\n\tsetNationalNumberTemplate(template, state) {\r\n\t\tthis.nationalNumberTemplate = template\r\n\t\tthis.populatedNationalNumberTemplate = template\r\n\t\t// With a new formatting template, the matched position\r\n\t\t// using the old template needs to be reset.\r\n\t\tthis.populatedNationalNumberTemplatePosition = -1\r\n\t\t// For convenience, the public `.template` property\r\n\t\t// contains the whole international number\r\n\t\t// if the phone number being input is international:\r\n\t\t// 'x' for the '+' sign, 'x'es for the country phone code,\r\n\t\t// a spacebar and then the template for the formatted national number.\r\n\t\tif (state.international) {\r\n\t\t\tthis.template =\r\n\t\t\t\tthis.getInternationalPrefixBeforeCountryCallingCode(state).replace(/[\\d\\+]/g, DIGIT_PLACEHOLDER) +\r\n\t\t\t\trepeat(DIGIT_PLACEHOLDER, state.callingCode.length) +\r\n\t\t\t\t' ' +\r\n\t\t\t\ttemplate\r\n\t\t} else {\r\n\t\t\tthis.template = template\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Generates formatting template for a national phone number,\r\n\t * optionally containing a national prefix, for a format.\r\n\t * @param  {Format} format\r\n\t * @param  {string} nationalPrefix\r\n\t * @return {string}\r\n\t */\r\n\tgetTemplateForFormat(format, {\r\n\t\tnationalSignificantNumber,\r\n\t\tinternational,\r\n\t\tnationalPrefix,\r\n\t\tprefixBeforeNationalSignificantNumberThatIsNotNationalPrefix\r\n\t}) {\r\n\t\tlet pattern = format.pattern()\r\n\r\n\t\t/* istanbul ignore else */\r\n\t\tif (SUPPORT_LEGACY_FORMATTING_PATTERNS) {\r\n\t\t\tpattern = pattern\r\n\t\t\t\t// Replace anything in the form of [..] with \\d\r\n\t\t\t\t.replace(CREATE_CHARACTER_CLASS_PATTERN(), '\\\\d')\r\n\t\t\t\t// Replace any standalone digit (not the one in `{}`) with \\d\r\n\t\t\t\t.replace(CREATE_STANDALONE_DIGIT_PATTERN(), '\\\\d')\r\n\t\t}\r\n\r\n\t\t// Generate a dummy national number (consisting of `9`s)\r\n\t\t// that fits this format's `pattern`.\r\n\t\t//\r\n\t\t// This match will always succeed,\r\n\t\t// because the \"longest dummy phone number\"\r\n\t\t// has enough length to accomodate any possible\r\n\t\t// national phone number format pattern.\r\n\t\t//\r\n\t\tlet digits = LONGEST_DUMMY_PHONE_NUMBER.match(pattern)[0]\r\n\r\n\t\t// If the national number entered is too long\r\n\t\t// for any phone number format, then abort.\r\n\t\tif (nationalSignificantNumber.length > digits.length) {\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\t// Get a formatting template which can be used to efficiently format\r\n\t\t// a partial number where digits are added one by one.\r\n\r\n\t\t// Below `strictPattern` is used for the\r\n\t\t// regular expression (with `^` and `$`).\r\n\t\t// This wasn't originally in Google's `libphonenumber`\r\n\t\t// and I guess they don't really need it\r\n\t\t// because they're not using \"templates\" to format phone numbers\r\n\t\t// but I added `strictPattern` after encountering\r\n\t\t// South Korean phone number formatting bug.\r\n\t\t//\r\n\t\t// Non-strict regular expression bug demonstration:\r\n\t\t//\r\n\t\t// this.nationalSignificantNumber : `111111111` (9 digits)\r\n\t\t//\r\n\t\t// pattern : (\\d{2})(\\d{3,4})(\\d{4})\r\n\t\t// format : `$1 $2 $3`\r\n\t\t// digits : `9999999999` (10 digits)\r\n\t\t//\r\n\t\t// '9999999999'.replace(new RegExp(/(\\d{2})(\\d{3,4})(\\d{4})/g), '$1 $2 $3') = \"99 9999 9999\"\r\n\t\t//\r\n\t\t// template : xx xxxx xxxx\r\n\t\t//\r\n\t\t// But the correct template in this case is `xx xxx xxxx`.\r\n\t\t// The template was generated incorrectly because of the\r\n\t\t// `{3,4}` variability in the `pattern`.\r\n\t\t//\r\n\t\t// The fix is, if `this.nationalSignificantNumber` has already sufficient length\r\n\t\t// to satisfy the `pattern` completely then `this.nationalSignificantNumber`\r\n\t\t// is used instead of `digits`.\r\n\r\n\t\tconst strictPattern = new RegExp('^' + pattern + '$')\r\n\t\tconst nationalNumberDummyDigits = nationalSignificantNumber.replace(/\\d/g, DUMMY_DIGIT)\r\n\r\n\t\t// If `this.nationalSignificantNumber` has already sufficient length\r\n\t\t// to satisfy the `pattern` completely then use it\r\n\t\t// instead of `digits`.\r\n\t\tif (strictPattern.test(nationalNumberDummyDigits)) {\r\n\t\t\tdigits = nationalNumberDummyDigits\r\n\t\t}\r\n\r\n\t\tlet numberFormat = this.getFormatFormat(format, international)\r\n\t\tlet nationalPrefixIncludedInTemplate\r\n\r\n\t\t// If a user did input a national prefix (and that's guaranteed),\r\n\t\t// and if a `format` does have a national prefix formatting rule,\r\n\t\t// then see if that national prefix formatting rule\r\n\t\t// prepends exactly the same national prefix the user has input.\r\n\t\t// If that's the case, then use the `format` with the national prefix formatting rule.\r\n\t\t// Otherwise, use  the `format` without the national prefix formatting rule,\r\n\t\t// and prepend a national prefix manually to it.\r\n\t\tif (this.shouldTryNationalPrefixFormattingRule(format, { international, nationalPrefix })) {\r\n\t\t\tconst numberFormatWithNationalPrefix = numberFormat.replace(\r\n\t\t\t\tFIRST_GROUP_PATTERN,\r\n\t\t\t\tformat.nationalPrefixFormattingRule()\r\n\t\t\t)\r\n\t\t\t// If `national_prefix_formatting_rule` of a `format` simply prepends\r\n\t\t\t// national prefix at the start of a national (significant) number,\r\n\t\t\t// then such formatting can be used with `AsYouType` formatter.\r\n\t\t\t// There seems to be no `else` case: everywhere in metadata,\r\n\t\t\t// national prefix formatting rule is national prefix + $1,\r\n\t\t\t// or `($1)`, in which case such format isn't even considered\r\n\t\t\t// when the user has input a national prefix.\r\n\t\t\t/* istanbul ignore else */\r\n\t\t\tif (parseDigits(format.nationalPrefixFormattingRule()) === (nationalPrefix || '') + parseDigits('$1')) {\r\n\t\t\t\tnumberFormat = numberFormatWithNationalPrefix\r\n\t\t\t\tnationalPrefixIncludedInTemplate = true\r\n\t\t\t\t// Replace all digits of the national prefix in the formatting template\r\n\t\t\t\t// with `DIGIT_PLACEHOLDER`s.\r\n\t\t\t\tif (nationalPrefix) {\r\n\t\t\t\t\tlet i = nationalPrefix.length\r\n\t\t\t\t\twhile (i > 0) {\r\n\t\t\t\t\t\tnumberFormat = numberFormat.replace(/\\d/, DIGIT_PLACEHOLDER)\r\n\t\t\t\t\t\ti--\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Generate formatting template for this phone number format.\r\n\t\tlet template = digits\r\n\t\t\t// Format the dummy phone number according to the format.\r\n\t\t\t.replace(new RegExp(pattern), numberFormat)\r\n\t\t\t// Replace each dummy digit with a DIGIT_PLACEHOLDER.\r\n\t\t\t.replace(new RegExp(DUMMY_DIGIT, 'g'), DIGIT_PLACEHOLDER)\r\n\r\n\t\t// If a prefix of a national (significant) number is not as simple\r\n\t\t// as just a basic national prefix, then just prepend such prefix\r\n\t\t// before the national (significant) number, optionally spacing\r\n\t\t// the two with a whitespace.\r\n\t\tif (!nationalPrefixIncludedInTemplate) {\r\n\t\t\tif (prefixBeforeNationalSignificantNumberThatIsNotNationalPrefix) {\r\n\t\t\t\t// Prepend the prefix to the template manually.\r\n\t\t\t\ttemplate = repeat(DIGIT_PLACEHOLDER, prefixBeforeNationalSignificantNumberThatIsNotNationalPrefix.length) +\r\n\t\t\t\t\t' ' +\r\n\t\t\t\t\ttemplate\r\n\t\t\t} else if (nationalPrefix) {\r\n\t\t\t\t// Prepend national prefix to the template manually.\r\n\t\t\t\ttemplate = repeat(DIGIT_PLACEHOLDER, nationalPrefix.length) +\r\n\t\t\t\t\tthis.getSeparatorAfterNationalPrefix(format) +\r\n\t\t\t\t\ttemplate\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (international) {\r\n\t\t\ttemplate = applyInternationalSeparatorStyle(template)\r\n\t\t}\r\n\r\n\t\treturn template\r\n\t}\r\n\r\n\tformatNextNationalNumberDigits(digits) {\r\n\t\tconst result = populateTemplateWithDigits(\r\n\t\t\tthis.populatedNationalNumberTemplate,\r\n\t\t\tthis.populatedNationalNumberTemplatePosition,\r\n\t\t\tdigits\r\n\t\t)\r\n\r\n\t\tif (!result) {\r\n\t\t\t// Reset the format.\r\n\t\t\tthis.resetFormat()\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tthis.populatedNationalNumberTemplate = result[0]\r\n\t\tthis.populatedNationalNumberTemplatePosition = result[1]\r\n\r\n\t\t// Return the formatted phone number so far.\r\n\t\treturn cutAndStripNonPairedParens(this.populatedNationalNumberTemplate, this.populatedNationalNumberTemplatePosition + 1)\r\n\r\n\t\t// The old way which was good for `input-format` but is not so good\r\n\t\t// for `react-phone-number-input`'s default input (`InputBasic`).\r\n\t\t// return closeNonPairedParens(this.populatedNationalNumberTemplate, this.populatedNationalNumberTemplatePosition + 1)\r\n\t\t// \t.replace(new RegExp(DIGIT_PLACEHOLDER, 'g'), ' ')\r\n\t}\r\n\r\n\tshouldTryNationalPrefixFormattingRule(format, { international, nationalPrefix }) {\r\n\t\tif (format.nationalPrefixFormattingRule()) {\r\n\t\t\t// In some countries, `national_prefix_formatting_rule` is `($1)`,\r\n\t\t\t// so it applies even if the user hasn't input a national prefix.\r\n\t\t\t// `format.usesNationalPrefix()` detects such cases.\r\n\t\t\tconst usesNationalPrefix = format.usesNationalPrefix()\r\n\t\t\tif ((usesNationalPrefix && nationalPrefix) ||\r\n\t\t\t\t(!usesNationalPrefix && !international)) {\r\n\t\t\t\treturn true\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}","import PatternParser from './AsYouTypeFormatter.PatternParser.js'\r\n\r\nexport default class PatternMatcher {\r\n\tconstructor(pattern) {\r\n\t\tthis.matchTree = new PatternParser().parse(pattern)\r\n\t}\r\n\r\n\tmatch(string, { allowOverflow } = {}) {\r\n\t\tif (!string) {\r\n\t\t\tthrow new Error('String is required')\r\n\t\t}\r\n\t\tconst result = match(string.split(''), this.matchTree, true)\r\n\t\tif (result && result.match) {\r\n\t\t\tdelete result.matchedChars\r\n\t\t}\r\n\t\tif (result && result.overflow) {\r\n\t\t\tif (!allowOverflow) {\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result\r\n\t}\r\n}\r\n\r\n/**\r\n * Matches `characters` against a pattern compiled into a `tree`.\r\n * @param  {string[]} characters\r\n * @param  {Tree} tree — A pattern compiled into a `tree`. See the `*.d.ts` file for the description of the `tree` structure.\r\n * @param  {boolean} last — Whether it's the last (rightmost) subtree on its level of the match tree.\r\n * @return {object} See the `*.d.ts` file for the description of the result object.\r\n */\r\nfunction match(characters, tree, last) {\r\n\t// If `tree` is a string, then `tree` is a single character.\r\n\t// That's because when a pattern is parsed, multi-character-string parts\r\n\t// of a pattern are compiled into arrays of single characters.\r\n\t// I still wrote this piece of code for a \"general\" hypothetical case\r\n\t// when `tree` could be a string of several characters, even though\r\n\t// such case is not possible with the current implementation.\r\n\tif (typeof tree === 'string') {\r\n\t\tconst characterString = characters.join('')\r\n\t\tif (tree.indexOf(characterString) === 0) {\r\n\t\t\t// `tree` is always a single character.\r\n\t\t\t// If `tree.indexOf(characterString) === 0`\r\n\t\t\t// then `characters.length === tree.length`.\r\n\t\t\t/* istanbul ignore else */\r\n\t\t\tif (characters.length === tree.length) {\r\n\t\t\t\treturn {\r\n\t\t\t\t\tmatch: true,\r\n\t\t\t\t\tmatchedChars: characters\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// `tree` is always a single character.\r\n\t\t\t// If `tree.indexOf(characterString) === 0`\r\n\t\t\t// then `characters.length === tree.length`.\r\n\t\t\t/* istanbul ignore next */\r\n\t\t\treturn {\r\n\t\t\t\tpartialMatch: true,\r\n\t\t\t\t// matchedChars: characters\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (characterString.indexOf(tree) === 0) {\r\n\t\t\tif (last) {\r\n\t\t\t\t// The `else` path is not possible because `tree` is always a single character.\r\n\t\t\t\t// The `else` case for `characters.length > tree.length` would be\r\n\t\t\t\t// `characters.length <= tree.length` which means `characters.length <= 1`.\r\n\t\t\t\t// `characters` array can't be empty, so that means `characters === [tree]`,\r\n\t\t\t\t// which would also mean `tree.indexOf(characterString) === 0` and that'd mean\r\n\t\t\t\t// that the `if (tree.indexOf(characterString) === 0)` condition before this\r\n\t\t\t\t// `if` condition would be entered, and returned from there, not reaching this code.\r\n\t\t\t\t/* istanbul ignore else */\r\n\t\t\t\tif (characters.length > tree.length) {\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\toverflow: true\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn {\r\n\t\t\t\tmatch: true,\r\n\t\t\t\tmatchedChars: characters.slice(0, tree.length)\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn\r\n\t}\r\n\r\n\tif (Array.isArray(tree)) {\r\n\t\tlet restCharacters = characters.slice()\r\n\t\tlet i = 0\r\n\t\twhile (i < tree.length) {\r\n\t\t\tconst subtree = tree[i]\r\n\t\t\tconst result = match(restCharacters, subtree, last && (i === tree.length - 1))\r\n\t\t\tif (!result) {\r\n\t\t\t\treturn\r\n\t\t\t} else if (result.overflow) {\r\n\t\t\t\treturn result\r\n\t\t\t} else if (result.match) {\r\n\t\t\t\t// Continue with the next subtree with the rest of the characters.\r\n\t\t\t\trestCharacters = restCharacters.slice(result.matchedChars.length)\r\n\t\t\t\tif (restCharacters.length === 0) {\r\n\t\t\t\t\tif (i === tree.length - 1) {\r\n\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\tmatch: true,\r\n\t\t\t\t\t\t\tmatchedChars: characters\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\tpartialMatch: true,\r\n\t\t\t\t\t\t\t// matchedChars: characters\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\t/* istanbul ignore else */\r\n\t\t\t\tif (result.partialMatch) {\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\tpartialMatch: true,\r\n\t\t\t\t\t\t// matchedChars: characters\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthrow new Error(`Unsupported match result:\\n${JSON.stringify(result, null, 2)}`)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\ti++\r\n\t\t}\r\n\t\t// If `last` then overflow has already been checked\r\n\t\t// by the last element of the `tree` array.\r\n\t\t/* istanbul ignore if */\r\n\t\tif (last) {\r\n\t\t\treturn {\r\n\t\t\t\toverflow: true\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn {\r\n\t\t\tmatch: true,\r\n\t\t\tmatchedChars: characters.slice(0, characters.length - restCharacters.length)\r\n\t\t}\r\n\t}\r\n\r\n\tswitch (tree.op) {\r\n\t\tcase '|':\r\n\t\t\tlet partialMatch\r\n\t\t\tfor (const branch of tree.args) {\r\n\t\t\t\tconst result = match(characters, branch, last)\r\n\t\t\t\tif (result) {\r\n\t\t\t\t\tif (result.overflow) {\r\n\t\t\t\t\t\treturn result\r\n\t\t\t\t\t} else if (result.match) {\r\n\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\tmatch: true,\r\n\t\t\t\t\t\t\tmatchedChars: result.matchedChars\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t/* istanbul ignore else */\r\n\t\t\t\t\t\tif (result.partialMatch) {\r\n\t\t\t\t\t\t\tpartialMatch = true\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tthrow new Error(`Unsupported match result:\\n${JSON.stringify(result, null, 2)}`)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (partialMatch) {\r\n\t\t\t\treturn {\r\n\t\t\t\t\tpartialMatch: true,\r\n\t\t\t\t\t// matchedChars: ...\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// Not even a partial match.\r\n\t\t\treturn\r\n\r\n\t\tcase '[]':\r\n\t\t\tfor (const char of tree.args) {\r\n\t\t\t\tif (characters[0] === char) {\r\n\t\t\t\t\tif (characters.length === 1) {\r\n\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\tmatch: true,\r\n\t\t\t\t\t\t\tmatchedChars: characters\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (last) {\r\n\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\toverflow: true\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\tmatch: true,\r\n\t\t\t\t\t\tmatchedChars: [char]\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// No character matches.\r\n\t\t\treturn\r\n\r\n\t\t/* istanbul ignore next */\r\n\t\tdefault:\r\n\t\t\tthrow new Error(`Unsupported instruction tree: ${tree}`)\r\n\t}\r\n}","import extractCountryCallingCode from './helpers/extractCountryCallingCode.js'\r\nimport extractCountryCallingCodeFromInternationalNumberWithoutPlusSign from './helpers/extractCountryCallingCodeFromInternationalNumberWithoutPlusSign.js'\r\nimport extractNationalNumberFromPossiblyIncompleteNumber from './helpers/extractNationalNumberFromPossiblyIncompleteNumber.js'\r\nimport stripIddPrefix from './helpers/stripIddPrefix.js'\r\nimport parseDigits from './helpers/parseDigits.js'\r\n\r\nimport {\r\n\tVALID_DIGITS,\r\n\tVALID_PUNCTUATION,\r\n\tPLUS_CHARS\r\n} from './constants.js'\r\n\r\nconst VALID_FORMATTED_PHONE_NUMBER_DIGITS_PART =\r\n\t'[' +\r\n\t\tVALID_PUNCTUATION +\r\n\t\tVALID_DIGITS +\r\n\t']+'\r\n\r\nconst VALID_FORMATTED_PHONE_NUMBER_DIGITS_PART_PATTERN = new RegExp('^' + VALID_FORMATTED_PHONE_NUMBER_DIGITS_PART + '$', 'i')\r\n\r\nconst VALID_FORMATTED_PHONE_NUMBER_PART =\r\n\t'(?:' +\r\n\t\t'[' + PLUS_CHARS + ']' +\r\n\t\t'[' +\r\n\t\t\tVALID_PUNCTUATION +\r\n\t\t\tVALID_DIGITS +\r\n\t\t']*' +\r\n\t\t'|' +\r\n\t\t'[' +\r\n\t\t\tVALID_PUNCTUATION +\r\n\t\t\tVALID_DIGITS +\r\n\t\t']+' +\r\n\t')'\r\n\r\nconst AFTER_PHONE_NUMBER_DIGITS_END_PATTERN = new RegExp(\r\n\t'[^' +\r\n\t\tVALID_PUNCTUATION +\r\n\t\tVALID_DIGITS +\r\n\t']+' +\r\n\t'.*' +\r\n\t'$'\r\n)\r\n\r\n// Tests whether `national_prefix_for_parsing` could match\r\n// different national prefixes.\r\n// Matches anything that's not a digit or a square bracket.\r\nconst COMPLEX_NATIONAL_PREFIX = /[^\\d\\[\\]]/\r\n\r\nexport default class AsYouTypeParser {\r\n\tconstructor({\r\n\t\tdefaultCountry,\r\n\t\tdefaultCallingCode,\r\n\t\tmetadata,\r\n\t\tonNationalSignificantNumberChange\r\n\t}) {\r\n\t\tthis.defaultCountry = defaultCountry\r\n\t\tthis.defaultCallingCode = defaultCallingCode\r\n\t\tthis.metadata = metadata\r\n\t\tthis.onNationalSignificantNumberChange = onNationalSignificantNumberChange\r\n\t}\r\n\r\n\tinput(text, state) {\r\n\t\tconst [formattedDigits, hasPlus] = extractFormattedDigitsAndPlus(text)\r\n\t\tconst digits = parseDigits(formattedDigits)\r\n\t\t// Checks for a special case: just a leading `+` has been entered.\r\n\t\tlet justLeadingPlus\r\n\t\tif (hasPlus) {\r\n\t\t\tif (!state.digits) {\r\n\t\t\t\tstate.startInternationalNumber(undefined, undefined)\r\n\t\t\t\tif (!digits) {\r\n\t\t\t\t\tjustLeadingPlus = true\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (digits) {\r\n\t\t\tthis.inputDigits(digits, state)\r\n\t\t}\r\n\t\treturn {\r\n\t\t\tdigits,\r\n\t\t\tjustLeadingPlus\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Inputs \"next\" phone number digits.\r\n\t * @param  {string} digits\r\n\t * @return {string} [formattedNumber] Formatted national phone number (if it can be formatted at this stage). Returning `undefined` means \"don't format the national phone number at this stage\".\r\n\t */\r\n\tinputDigits(nextDigits, state) {\r\n\t\tconst { digits } = state\r\n\t\tconst hasReceivedThreeLeadingDigits = digits.length < 3 && digits.length + nextDigits.length >= 3\r\n\r\n\t\t// Append phone number digits.\r\n\t\tstate.appendDigits(nextDigits)\r\n\r\n\t\t// Attempt to extract IDD prefix:\r\n\t\t// Some users input their phone number in international format,\r\n\t\t// but in an \"out-of-country\" dialing format instead of using the leading `+`.\r\n\t\t// https://github.com/catamphetamine/libphonenumber-js/issues/185\r\n\t\t// Detect such numbers as soon as there're at least 3 digits.\r\n\t\t// Google's library attempts to extract IDD prefix at 3 digits,\r\n\t\t// so this library just copies that behavior.\r\n\t\t// I guess that's because the most commot IDD prefixes are\r\n\t\t// `00` (Europe) and `011` (US).\r\n\t\t// There exist really long IDD prefixes too:\r\n\t\t// for example, in Australia the default IDD prefix is `0011`,\r\n\t\t// and it could even be as long as `14880011`.\r\n\t\t// An IDD prefix is extracted here, and then every time when\r\n\t\t// there's a new digit and the number couldn't be formatted.\r\n\t\tif (hasReceivedThreeLeadingDigits) {\r\n\t\t\tthis.extractIddPrefix(state)\r\n\t\t}\r\n\r\n\t\tif (this.isWaitingForCountryCallingCode(state)) {\r\n\t\t\tif (!this.extractCountryCallingCode(state)) {\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tstate.appendNationalSignificantNumberDigits(nextDigits)\r\n\t\t}\r\n\r\n\t\t// If a phone number is being input in international format,\r\n\t\t// then it's not valid for it to have a national prefix.\r\n\t\t// Still, some people incorrectly input such numbers with a national prefix.\r\n\t\t// In such cases, only attempt to strip a national prefix if the number becomes too long.\r\n\t\t// (but that is done later, not here)\r\n\t\tif (!state.international) {\r\n\t\t\tif (!this.hasExtractedNationalSignificantNumber) {\r\n\t\t\t\tthis.extractNationalSignificantNumber(\r\n\t\t\t\t\tstate.getNationalDigits(),\r\n\t\t\t\t\t(stateUpdate) => state.update(stateUpdate)\r\n\t\t\t\t)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tisWaitingForCountryCallingCode({ international, callingCode }) {\r\n\t\treturn international && !callingCode\r\n\t}\r\n\r\n\t// Extracts a country calling code from a number\r\n\t// being entered in internatonal format.\r\n\textractCountryCallingCode(state) {\r\n\t\tconst { countryCallingCode, number } = extractCountryCallingCode(\r\n\t\t\t'+' + state.getDigitsWithoutInternationalPrefix(),\r\n\t\t\tstate.country,\r\n\t\t\tthis.defaultCountry,\r\n\t\t\tthis.defaultCallingCode,\r\n\t\t\tthis.metadata.metadata\r\n\t\t)\r\n\t\tif (countryCallingCode) {\r\n\t\t\tstate.setCallingCode(countryCallingCode)\r\n\t\t\tstate.update({\r\n\t\t\t\tnationalSignificantNumber: number\r\n\t\t\t})\r\n\t\t\treturn true\r\n\t\t}\r\n\t}\r\n\r\n\treset(numberingPlan) {\r\n\t\tif (numberingPlan) {\r\n\t\t\tthis.hasSelectedNumberingPlan = true\r\n\t\t\tconst nationalPrefixForParsing = numberingPlan._nationalPrefixForParsing()\r\n\t\t\tthis.couldPossiblyExtractAnotherNationalSignificantNumber = nationalPrefixForParsing && COMPLEX_NATIONAL_PREFIX.test(nationalPrefixForParsing)\r\n\t\t} else {\r\n\t\t\tthis.hasSelectedNumberingPlan = undefined\r\n\t\t\tthis.couldPossiblyExtractAnotherNationalSignificantNumber = undefined\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Extracts a national (significant) number from user input.\r\n\t * Google's library is different in that it only applies `national_prefix_for_parsing`\r\n\t * and doesn't apply `national_prefix_transform_rule` after that.\r\n\t * https://github.com/google/libphonenumber/blob/a3d70b0487875475e6ad659af404943211d26456/java/libphonenumber/src/com/google/i18n/phonenumbers/AsYouTypeFormatter.java#L539\r\n\t * @return {boolean} [extracted]\r\n\t */\r\n\textractNationalSignificantNumber(nationalDigits, setState) {\r\n\t\tif (!this.hasSelectedNumberingPlan) {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tconst {\r\n\t\t\tnationalPrefix,\r\n\t\t\tnationalNumber,\r\n\t\t\tcarrierCode\r\n\t\t} = extractNationalNumberFromPossiblyIncompleteNumber(\r\n\t\t\tnationalDigits,\r\n\t\t\tthis.metadata\r\n\t\t)\r\n\t\tif (nationalNumber === nationalDigits) {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tthis.onExtractedNationalNumber(\r\n\t\t\tnationalPrefix,\r\n\t\t\tcarrierCode,\r\n\t\t\tnationalNumber,\r\n\t\t\tnationalDigits,\r\n\t\t\tsetState\r\n\t\t)\r\n\t\treturn true\r\n\t}\r\n\r\n\t/**\r\n\t * In Google's code this function is called \"attempt to extract longer NDD\".\r\n\t * \"Some national prefixes are a substring of others\", they say.\r\n\t * @return {boolean} [result] — Returns `true` if extracting a national prefix produced different results from what they were.\r\n\t */\r\n\textractAnotherNationalSignificantNumber(nationalDigits, prevNationalSignificantNumber, setState) {\r\n\t\tif (!this.hasExtractedNationalSignificantNumber) {\r\n\t\t\treturn this.extractNationalSignificantNumber(nationalDigits, setState)\r\n\t\t}\r\n\t\tif (!this.couldPossiblyExtractAnotherNationalSignificantNumber) {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tconst {\r\n\t\t\tnationalPrefix,\r\n\t\t\tnationalNumber,\r\n\t\t\tcarrierCode\r\n\t\t} = extractNationalNumberFromPossiblyIncompleteNumber(\r\n\t\t\tnationalDigits,\r\n\t\t\tthis.metadata\r\n\t\t)\r\n\t\t// If a national prefix has been extracted previously,\r\n\t\t// then it's always extracted as additional digits are added.\r\n\t\t// That's assuming `extractNationalNumberFromPossiblyIncompleteNumber()`\r\n\t\t// doesn't do anything different from what it currently does.\r\n\t\t// So, just in case, here's this check, though it doesn't occur.\r\n\t\t/* istanbul ignore if */\r\n\t\tif (nationalNumber === prevNationalSignificantNumber) {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tthis.onExtractedNationalNumber(\r\n\t\t\tnationalPrefix,\r\n\t\t\tcarrierCode,\r\n\t\t\tnationalNumber,\r\n\t\t\tnationalDigits,\r\n\t\t\tsetState\r\n\t\t)\r\n\t\treturn true\r\n\t}\r\n\r\n\tonExtractedNationalNumber(\r\n\t\tnationalPrefix,\r\n\t\tcarrierCode,\r\n\t\tnationalSignificantNumber,\r\n\t\tnationalDigits,\r\n\t\tsetState\r\n\t) {\r\n\t\t// Tells if the parsed national (significant) number is present as-is in the input string.\r\n\t\t// For example, when inputting \"0343515551212999\" Argentinian mobile number,\r\n\t\t// the parsed national (significant) number is \"93435551212999\".\r\n\t\t// There, one can see how it stripped \"0\" national prefix and prepended a \"9\",\r\n\t\t// because that's how it is instructed to do in Argentina's metadata.\r\n\t\t// So in the described example, the parsed national (significant) number is not present\r\n\t\t// as-is in the input string. Instead, it's \"modified\" in the input string.\r\n\t\t// https://gitlab.com/catamphetamine/libphonenumber-js/-/blob/master/METADATA.md#national_prefix_for_parsing--national_prefix_transform_rule\r\n\t\tlet nationalSignificantNumberIsModified = false\r\n\r\n\t\t// In some countries, a phone number could have a prefix that is not a \"national prefix\"\r\n\t\t// but rather some other type of \"utility\" prefix.\r\n\t\t// For example, when calling within Australia, one could prepend `1831` prefix to hide\r\n\t\t// caller's phone number.\r\n\t\t// https://gitlab.com/catamphetamine/libphonenumber-js/-/blob/master/METADATA.md#national_prefix_for_parsing--national_prefix_transform_rule\r\n\t\tlet prefixBeforeNationalSignificantNumberThatIsNotNationalPrefix\r\n\r\n\t\t// `nationalSignificantNumber` could be empty. In that case, `.lastIndexOf()` still works correctly.\r\n\t\tconst nationalSignificantNumberIndex = nationalDigits.lastIndexOf(nationalSignificantNumber)\r\n\r\n\t\t// If the parsed national (significant) number is the last substring of the `nationalDigits`,\r\n\t\t// then it means that it's present as-is in the input string.\r\n\t\t// In any other case, the parsed national (significant) number is \"modified\" in the input string.\r\n\t\tif (\r\n\t\t\tnationalSignificantNumberIndex < 0 ||\r\n\t\t\tnationalSignificantNumberIndex !== nationalDigits.length - nationalSignificantNumber.length\r\n\t\t) {\r\n\t\t\tnationalSignificantNumberIsModified = true\r\n\t\t} else {\r\n\t\t\tconst prefixBeforeNationalNumber = nationalDigits.slice(0, nationalSignificantNumberIndex)\r\n\t\t\t// When national (significant) number is equal to the `nationalDigits`,\r\n\t\t\t// this `onExtractedNationalNumber()` function simply doesn't get called.\r\n\t\t\t// This means that at this point, `prefixBeforeNationalNumber` is always non-empty.\r\n\t\t\t// Still, added this `if` check just to prevent potential silly bugs.\r\n\t\t\t// The `!prefixBeforeNationalNumber` case is not really testable\r\n\t\t\t// so this line is exluded from the code coverage.\r\n\t\t\t/* istanbul ignore if */\r\n\t\t\tif (prefixBeforeNationalNumber) {\r\n\t\t\t\tif (prefixBeforeNationalNumber !== nationalPrefix) {\r\n\t\t\t\t\tprefixBeforeNationalSignificantNumberThatIsNotNationalPrefix = prefixBeforeNationalNumber\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tsetState({\r\n\t\t\tnationalPrefix,\r\n\t\t\tcarrierCode,\r\n\t\t\tnationalSignificantNumber,\r\n\t\t\tnationalSignificantNumberIsModified,\r\n\t\t\tprefixBeforeNationalSignificantNumberThatIsNotNationalPrefix\r\n\t\t})\r\n\t\t// `onExtractedNationalNumber()` is only called when\r\n\t\t// the national (significant) number actually did change.\r\n\t\tthis.hasExtractedNationalSignificantNumber = true\r\n\t\tthis.onNationalSignificantNumberChange()\r\n\t}\r\n\r\n\treExtractNationalSignificantNumber(state) {\r\n\t\t// Attempt to extract a national prefix.\r\n\t\t//\r\n\t\t// Some people incorrectly input national prefix\r\n\t\t// in an international phone number.\r\n\t\t// For example, some people write British phone numbers as `+44(0)...`.\r\n\t\t//\r\n\t\t// Also, in some rare cases, it is valid for a national prefix\r\n\t\t// to be a part of an international phone number.\r\n\t\t// For example, mobile phone numbers in Mexico are supposed to be\r\n\t\t// dialled internationally using a `1` national prefix,\r\n\t\t// so the national prefix will be part of an international number.\r\n\t\t//\r\n\t\t// Quote from:\r\n\t\t// https://www.mexperience.com/dialing-cell-phones-in-mexico/\r\n\t\t//\r\n\t\t// \"Dialing a Mexican cell phone from abroad\r\n\t\t// When you are calling a cell phone number in Mexico from outside Mexico,\r\n\t\t// it’s necessary to dial an additional “1” after Mexico’s country code\r\n\t\t// (which is “52”) and before the area code.\r\n\t\t// You also ignore the 045, and simply dial the area code and the\r\n\t\t// cell phone’s number.\r\n\t\t//\r\n\t\t// If you don’t add the “1”, you’ll receive a recorded announcement\r\n\t\t// asking you to redial using it.\r\n\t\t//\r\n\t\t// For example, if you are calling from the USA to a cell phone\r\n\t\t// in Mexico City, you would dial +52 – 1 – 55 – 1234 5678.\r\n\t\t// (Note that this is different to calling a land line in Mexico City\r\n\t\t// from abroad, where the number dialed would be +52 – 55 – 1234 5678)\".\r\n\t\t//\r\n\t\t// Google's demo output:\r\n\t\t// https://libphonenumber.appspot.com/phonenumberparser?number=%2b5215512345678&country=MX\r\n\t\t//\r\n\t\tif (this.extractAnotherNationalSignificantNumber(\r\n\t\t\tstate.getNationalDigits(),\r\n\t\t\tstate.nationalSignificantNumber,\r\n\t\t\t(stateUpdate) => state.update(stateUpdate)\r\n\t\t)) {\r\n\t\t\treturn true\r\n\t\t}\r\n\t\t// If no format matches the phone number, then it could be\r\n\t\t// \"a really long IDD\" (quote from a comment in Google's library).\r\n\t\t// An IDD prefix is first extracted when the user has entered at least 3 digits,\r\n\t\t// and then here — every time when there's a new digit and the number\r\n\t\t// couldn't be formatted.\r\n\t\t// For example, in Australia the default IDD prefix is `0011`,\r\n\t\t// and it could even be as long as `14880011`.\r\n\t\t//\r\n\t\t// Could also check `!hasReceivedThreeLeadingDigits` here\r\n\t\t// to filter out the case when this check duplicates the one\r\n\t\t// already performed when there're 3 leading digits,\r\n\t\t// but it's not a big deal, and in most cases there\r\n\t\t// will be a suitable `format` when there're 3 leading digits.\r\n\t\t//\r\n\t\tif (this.extractIddPrefix(state)) {\r\n\t\t\tthis.extractCallingCodeAndNationalSignificantNumber(state)\r\n\t\t\treturn true\r\n\t\t}\r\n\t\t// Google's AsYouType formatter supports sort of an \"autocorrection\" feature\r\n\t\t// when it \"autocorrects\" numbers that have been input for a country\r\n\t\t// with that country's calling code.\r\n\t\t// Such \"autocorrection\" feature looks weird, but different people have been requesting it:\r\n\t\t// https://github.com/catamphetamine/libphonenumber-js/issues/376\r\n\t\t// https://github.com/catamphetamine/libphonenumber-js/issues/375\r\n\t\t// https://github.com/catamphetamine/libphonenumber-js/issues/316\r\n\t\tif (this.fixMissingPlus(state)) {\r\n\t\t\tthis.extractCallingCodeAndNationalSignificantNumber(state)\r\n\t\t\treturn true\r\n\t\t}\r\n\t}\r\n\r\n\textractIddPrefix(state) {\r\n\t\t// An IDD prefix can't be present in a number written with a `+`.\r\n\t\t// Also, don't re-extract an IDD prefix if has already been extracted.\r\n\t\tconst {\r\n\t\t\tinternational,\r\n\t\t\tIDDPrefix,\r\n\t\t\tdigits,\r\n\t\t\tnationalSignificantNumber\r\n\t\t} = state\r\n\t\tif (international || IDDPrefix) {\r\n\t\t\treturn\r\n\t\t}\r\n\t\t// Some users input their phone number in \"out-of-country\"\r\n\t\t// dialing format instead of using the leading `+`.\r\n\t\t// https://github.com/catamphetamine/libphonenumber-js/issues/185\r\n\t\t// Detect such numbers.\r\n\t\tconst numberWithoutIDD = stripIddPrefix(\r\n\t\t\tdigits,\r\n\t\t\tthis.defaultCountry,\r\n\t\t\tthis.defaultCallingCode,\r\n\t\t\tthis.metadata.metadata\r\n\t\t)\r\n\t\tif (numberWithoutIDD !== undefined && numberWithoutIDD !== digits) {\r\n\t\t\t// If an IDD prefix was stripped then convert the IDD-prefixed number\r\n\t\t\t// to international number for subsequent parsing.\r\n\t\t\tstate.update({\r\n\t\t\t\tIDDPrefix: digits.slice(0, digits.length - numberWithoutIDD.length)\r\n\t\t\t})\r\n\t\t\tthis.startInternationalNumber(state, {\r\n\t\t\t\tcountry: undefined,\r\n\t\t\t\tcallingCode: undefined\r\n\t\t\t})\r\n\t\t\treturn true\r\n\t\t}\r\n\t}\r\n\r\n\tfixMissingPlus(state) {\r\n\t\tif (!state.international) {\r\n\t\t\tconst {\r\n\t\t\t\tcountryCallingCode: newCallingCode\r\n\t\t\t} = extractCountryCallingCodeFromInternationalNumberWithoutPlusSign(\r\n\t\t\t\tstate.digits,\r\n\t\t\t\tstate.country,\r\n\t\t\t\tthis.defaultCountry,\r\n\t\t\t\tthis.defaultCallingCode,\r\n\t\t\t\tthis.metadata.metadata\r\n\t\t\t)\r\n\t\t\tif (newCallingCode) {\r\n\t\t\t\tstate.update({\r\n\t\t\t\t\tmissingPlus: true\r\n\t\t\t\t})\r\n\t\t\t\tthis.startInternationalNumber(state, {\r\n\t\t\t\t\tcountry: state.country,\r\n\t\t\t\t\tcallingCode: newCallingCode\r\n\t\t\t\t})\r\n\t\t\t\treturn true\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tstartInternationalNumber(state, { country, callingCode }) {\r\n\t\tstate.startInternationalNumber(country, callingCode)\r\n\t\t// If a national (significant) number has been extracted before, reset it.\r\n\t\tif (state.nationalSignificantNumber) {\r\n\t\t\tstate.resetNationalSignificantNumber()\r\n\t\t\tthis.onNationalSignificantNumberChange()\r\n\t\t\tthis.hasExtractedNationalSignificantNumber = undefined\r\n\t\t}\r\n\t}\r\n\r\n\textractCallingCodeAndNationalSignificantNumber(state) {\r\n\t\tif (this.extractCountryCallingCode(state)) {\r\n\t\t\t// `this.extractCallingCode()` is currently called when the number\r\n\t\t\t// couldn't be formatted during the standard procedure.\r\n\t\t\t// Normally, the national prefix would be re-extracted\r\n\t\t\t// for an international number if such number couldn't be formatted,\r\n\t\t\t// but since it's already not able to be formatted,\r\n\t\t\t// there won't be yet another retry, so also extract national prefix here.\r\n\t\t\tthis.extractNationalSignificantNumber(\r\n\t\t\t\tstate.getNationalDigits(),\r\n\t\t\t\t(stateUpdate) => state.update(stateUpdate)\r\n\t\t\t)\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/**\r\n * Extracts formatted phone number from text (if there's any).\r\n * @param  {string} text\r\n * @return {string} [formattedPhoneNumber]\r\n */\r\nfunction extractFormattedPhoneNumber(text) {\r\n\t// Attempt to extract a possible number from the string passed in.\r\n\tconst startsAt = text.search(VALID_FORMATTED_PHONE_NUMBER_PART)\r\n\tif (startsAt < 0) {\r\n\t\treturn\r\n\t}\r\n\t// Trim everything to the left of the phone number.\r\n\ttext = text.slice(startsAt)\r\n\t// Trim the `+`.\r\n\tlet hasPlus\r\n\tif (text[0] === '+') {\r\n\t\thasPlus = true\r\n\t\ttext = text.slice('+'.length)\r\n\t}\r\n\t// Trim everything to the right of the phone number.\r\n\ttext = text.replace(AFTER_PHONE_NUMBER_DIGITS_END_PATTERN, '')\r\n\t// Re-add the previously trimmed `+`.\r\n\tif (hasPlus) {\r\n\t\ttext = '+' + text\r\n\t}\r\n\treturn text\r\n}\r\n\r\n/**\r\n * Extracts formatted phone number digits (and a `+`) from text (if there're any).\r\n * @param  {string} text\r\n * @return {any[]}\r\n */\r\nfunction _extractFormattedDigitsAndPlus(text) {\r\n\t// Extract a formatted phone number part from text.\r\n\tconst extractedNumber = extractFormattedPhoneNumber(text) || ''\r\n\t// Trim a `+`.\r\n\tif (extractedNumber[0] === '+') {\r\n\t\treturn [extractedNumber.slice('+'.length), true]\r\n\t}\r\n\treturn [extractedNumber]\r\n}\r\n\r\n/**\r\n * Extracts formatted phone number digits (and a `+`) from text (if there're any).\r\n * @param  {string} text\r\n * @return {any[]}\r\n */\r\nexport function extractFormattedDigitsAndPlus(text) {\r\n\tlet [formattedDigits, hasPlus] = _extractFormattedDigitsAndPlus(text)\r\n\t// If the extracted phone number part\r\n\t// can possibly be a part of some valid phone number\r\n\t// then parse phone number characters from a formatted phone number.\r\n\tif (!VALID_FORMATTED_PHONE_NUMBER_DIGITS_PART_PATTERN.test(formattedDigits)) {\r\n\t\tformattedDigits = ''\r\n\t}\r\n\treturn [formattedDigits, hasPlus]\r\n}","/**\r\n * Strips any national prefix (such as 0, 1) present in a\r\n * (possibly incomplete) number provided.\r\n * \"Carrier codes\" are only used  in Colombia and Brazil,\r\n * and only when dialing within those countries from a mobile phone to a fixed line number.\r\n * Sometimes it won't actually strip national prefix\r\n * and will instead prepend some digits to the `number`:\r\n * for example, when number `2345678` is passed with `VI` country selected,\r\n * it will return `{ number: \"3402345678\" }`, because `340` area code is prepended.\r\n * @param {string} number — National number digits.\r\n * @param {object} metadata — Metadata with country selected.\r\n * @return {object} `{ nationalNumber: string, nationalPrefix: string? carrierCode: string? }`. Even if a national prefix was extracted, it's not necessarily present in the returned object, so don't rely on its presence in the returned object in order to find out whether a national prefix has been extracted or not.\r\n */\r\nexport default function extractNationalNumberFromPossiblyIncompleteNumber(number, metadata) {\r\n\tif (number && metadata.numberingPlan.nationalPrefixForParsing()) {\r\n\t\t// See METADATA.md for the description of\r\n\t\t// `national_prefix_for_parsing` and `national_prefix_transform_rule`.\r\n\t\t// Attempt to parse the first digits as a national prefix.\r\n\t\tconst prefixPattern = new RegExp('^(?:' + metadata.numberingPlan.nationalPrefixForParsing() + ')')\r\n\t\tconst prefixMatch = prefixPattern.exec(number)\r\n\t\tif (prefixMatch) {\r\n\t\t\tlet nationalNumber\r\n\t\t\tlet carrierCode\r\n\t\t\t// https://gitlab.com/catamphetamine/libphonenumber-js/-/blob/master/METADATA.md#national_prefix_for_parsing--national_prefix_transform_rule\r\n\t\t\t// If a `national_prefix_for_parsing` has any \"capturing groups\"\r\n\t\t\t// then it means that the national (significant) number is equal to\r\n\t\t\t// those \"capturing groups\" transformed via `national_prefix_transform_rule`,\r\n\t\t\t// and nothing could be said about the actual national prefix:\r\n\t\t\t// what is it and was it even there.\r\n\t\t\t// If a `national_prefix_for_parsing` doesn't have any \"capturing groups\",\r\n\t\t\t// then everything it matches is a national prefix.\r\n\t\t\t// To determine whether `national_prefix_for_parsing` matched any\r\n\t\t\t// \"capturing groups\", the value of the result of calling `.exec()`\r\n\t\t\t// is looked at, and if it has non-undefined values where there're\r\n\t\t\t// \"capturing groups\" in the regular expression, then it means\r\n\t\t\t// that \"capturing groups\" have been matched.\r\n\t\t\t// It's not possible to tell whether there'll be any \"capturing gropus\"\r\n\t\t\t// before the matching process, because a `national_prefix_for_parsing`\r\n\t\t\t// could exhibit both behaviors.\r\n\t\t\tconst capturedGroupsCount = prefixMatch.length - 1\r\n\t\t\tconst hasCapturedGroups = capturedGroupsCount > 0 && prefixMatch[capturedGroupsCount]\r\n\t\t\tif (metadata.nationalPrefixTransformRule() && hasCapturedGroups) {\r\n\t\t\t\tnationalNumber = number.replace(\r\n\t\t\t\t\tprefixPattern,\r\n\t\t\t\t\tmetadata.nationalPrefixTransformRule()\r\n\t\t\t\t)\r\n\t\t\t\t// If there's more than one captured group,\r\n\t\t\t\t// then carrier code is the second one.\r\n\t\t\t\tif (capturedGroupsCount > 1) {\r\n\t\t\t\t\tcarrierCode = prefixMatch[1]\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// If there're no \"capturing groups\",\r\n\t\t\t// or if there're \"capturing groups\" but no\r\n\t\t\t// `national_prefix_transform_rule`,\r\n\t\t\t// then just strip the national prefix from the number,\r\n\t\t\t// and possibly a carrier code.\r\n\t\t\t// Seems like there could be more.\r\n\t\t\telse {\r\n\t\t\t\t// `prefixBeforeNationalNumber` is the whole substring matched by\r\n\t\t\t\t// the `national_prefix_for_parsing` regular expression.\r\n\t\t\t\t// There seem to be no guarantees that it's just a national prefix.\r\n\t\t\t\t// For example, if there's a carrier code, it's gonna be a\r\n\t\t\t\t// part of `prefixBeforeNationalNumber` too.\r\n\t\t\t\tconst prefixBeforeNationalNumber = prefixMatch[0]\r\n\t\t\t\tnationalNumber = number.slice(prefixBeforeNationalNumber.length)\r\n\t\t\t\t// If there's at least one captured group,\r\n\t\t\t\t// then carrier code is the first one.\r\n\t\t\t\tif (hasCapturedGroups) {\r\n\t\t\t\t\tcarrierCode = prefixMatch[1]\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// Tries to guess whether a national prefix was present in the input.\r\n\t\t\t// This is not something copy-pasted from Google's library:\r\n\t\t\t// they don't seem to have an equivalent for that.\r\n\t\t\t// So this isn't an \"officially approved\" way of doing something like that.\r\n\t\t\t// But since there seems no other existing method, this library uses it.\r\n\t\t\tlet nationalPrefix\r\n\t\t\tif (hasCapturedGroups) {\r\n\t\t\t\tconst possiblePositionOfTheFirstCapturedGroup = number.indexOf(prefixMatch[1])\r\n\t\t\t\tconst possibleNationalPrefix = number.slice(0, possiblePositionOfTheFirstCapturedGroup)\r\n\t\t\t\t// Example: an Argentinian (AR) phone number `0111523456789`.\r\n\t\t\t\t// `prefixMatch[0]` is `01115`, and `$1` is `11`,\r\n\t\t\t\t// and the rest of the phone number is `23456789`.\r\n\t\t\t\t// The national number is transformed via `9$1` to `91123456789`.\r\n\t\t\t\t// National prefix `0` is detected being present at the start.\r\n\t\t\t\t// if (possibleNationalPrefix.indexOf(metadata.numberingPlan.nationalPrefix()) === 0) {\r\n\t\t\t\tif (possibleNationalPrefix === metadata.numberingPlan.nationalPrefix()) {\r\n\t\t\t\t\tnationalPrefix = metadata.numberingPlan.nationalPrefix()\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tnationalPrefix = prefixMatch[0]\r\n\t\t\t}\r\n\t\t\treturn {\r\n\t\t\t\tnationalNumber,\r\n\t\t\t\tnationalPrefix,\r\n\t\t\t\tcarrierCode\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n   return {\r\n   \tnationalNumber: number\r\n   }\r\n}","import Metadata from './metadata.js'\r\nimport PhoneNumber from './PhoneNumber.js'\r\nimport AsYouTypeState from './AsYouTypeState.js'\r\nimport AsYouTypeFormatter, { DIGIT_PLACEHOLDER } from './AsYouTypeFormatter.js'\r\nimport AsYouTypeParser, { extractFormattedDigitsAndPlus } from './AsYouTypeParser.js'\r\nimport getCountryByCallingCode from './helpers/getCountryByCallingCode.js'\r\nimport getCountryByNationalNumber from './helpers/getCountryByNationalNumber.js'\r\nimport isObject from './helpers/isObject.js'\r\n\r\nconst USE_NON_GEOGRAPHIC_COUNTRY_CODE = false\r\n\r\nexport default class AsYouType {\r\n\t/**\r\n\t * @param {(string|object)?} [optionsOrDefaultCountry] - The default country used for parsing non-international phone numbers. Can also be an `options` object.\r\n\t * @param {Object} metadata\r\n\t */\r\n\tconstructor(optionsOrDefaultCountry, metadata) {\r\n\t\tthis.metadata = new Metadata(metadata)\r\n\t\tconst [defaultCountry, defaultCallingCode] = this.getCountryAndCallingCode(optionsOrDefaultCountry)\r\n\t\t// `this.defaultCountry` and `this.defaultCallingCode` aren't required to be in sync.\r\n\t\t// For example, `this.defaultCountry` could be `\"AR\"` and `this.defaultCallingCode` could be `undefined`.\r\n\t\t// So `this.defaultCountry` and `this.defaultCallingCode` are totally independent.\r\n\t\tthis.defaultCountry = defaultCountry\r\n\t\tthis.defaultCallingCode = defaultCallingCode\r\n\t\tthis.reset()\r\n\t}\r\n\r\n\tgetCountryAndCallingCode(optionsOrDefaultCountry) {\r\n\t\t// Set `defaultCountry` and `defaultCallingCode` options.\r\n\t\tlet defaultCountry\r\n\t\tlet defaultCallingCode\r\n\t\t// Turns out `null` also has type \"object\". Weird.\r\n\t\tif (optionsOrDefaultCountry) {\r\n\t\t\tif (isObject(optionsOrDefaultCountry)) {\r\n\t\t\t\tdefaultCountry = optionsOrDefaultCountry.defaultCountry\r\n\t\t\t\tdefaultCallingCode = optionsOrDefaultCountry.defaultCallingCode\r\n\t\t\t} else {\r\n\t\t\t\tdefaultCountry = optionsOrDefaultCountry\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (defaultCountry && !this.metadata.hasCountry(defaultCountry)) {\r\n\t\t\tdefaultCountry = undefined\r\n\t\t}\r\n\t\tif (defaultCallingCode) {\r\n\t\t\t/* istanbul ignore if */\r\n\t\t\tif (USE_NON_GEOGRAPHIC_COUNTRY_CODE) {\r\n\t\t\t\tif (this.metadata.isNonGeographicCallingCode(defaultCallingCode)) {\r\n\t\t\t\t\tdefaultCountry = '001'\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn [defaultCountry, defaultCallingCode]\r\n\t}\r\n\r\n\t/**\r\n\t * Inputs \"next\" phone number characters.\r\n\t * @param  {string} text\r\n\t * @return {string} Formatted phone number characters that have been input so far.\r\n\t */\r\n\tinput(text) {\r\n\t\tconst {\r\n\t\t\tdigits,\r\n\t\t\tjustLeadingPlus\r\n\t\t} = this.parser.input(text, this.state)\r\n\t\tif (justLeadingPlus) {\r\n\t\t\tthis.formattedOutput = '+'\r\n\t\t} else if (digits) {\r\n\t\t\tthis.determineTheCountryIfNeeded()\r\n\t\t\t// Match the available formats by the currently available leading digits.\r\n\t\t\tif (this.state.nationalSignificantNumber) {\r\n\t\t\t\tthis.formatter.narrowDownMatchingFormats(this.state)\r\n\t\t\t}\r\n\t\t\tlet formattedNationalNumber\r\n\t\t\tif (this.metadata.hasSelectedNumberingPlan()) {\r\n\t\t\t\tformattedNationalNumber = this.formatter.format(digits, this.state)\r\n\t\t\t}\r\n\t\t\tif (formattedNationalNumber === undefined) {\r\n\t\t\t\t// See if another national (significant) number could be re-extracted.\r\n\t\t\t\tif (this.parser.reExtractNationalSignificantNumber(this.state)) {\r\n\t\t\t\t\tthis.determineTheCountryIfNeeded()\r\n\t\t\t\t\t// If it could, then re-try formatting the new national (significant) number.\r\n\t\t\t\t\tconst nationalDigits = this.state.getNationalDigits()\r\n\t\t\t\t\tif (nationalDigits) {\r\n\t\t\t\t\t\tformattedNationalNumber = this.formatter.format(nationalDigits, this.state)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthis.formattedOutput = formattedNationalNumber\r\n\t\t\t\t? this.getFullNumber(formattedNationalNumber)\r\n\t\t\t\t: this.getNonFormattedNumber()\r\n\t\t}\r\n\t\treturn this.formattedOutput\r\n\t}\r\n\r\n\treset() {\r\n\t\tthis.state = new AsYouTypeState({\r\n\t\t\tonCountryChange: (country) => {\r\n\t\t\t\t// Before version `1.6.0`, the official `AsYouType` formatter API\r\n\t\t\t\t// included a `.country` property on an `AsYouType` instance.\r\n\t\t\t\t// Since that property (along with the others) have been moved to\r\n\t\t\t\t// `this.state`, `this.country` property is emulated for compatibility\r\n\t\t\t\t// with the old versions.\r\n\t\t\t\tthis.country = country\r\n\t\t\t},\r\n\t\t\tonCallingCodeChange: (callingCode, country) => {\r\n\t\t\t\tthis.metadata.selectNumberingPlan(country, callingCode)\r\n\t\t\t\tthis.formatter.reset(this.metadata.numberingPlan, this.state)\r\n\t\t\t\tthis.parser.reset(this.metadata.numberingPlan)\r\n\t\t\t}\r\n\t\t})\r\n\t\tthis.formatter = new AsYouTypeFormatter({\r\n\t\t\tstate: this.state,\r\n\t\t\tmetadata: this.metadata\r\n\t\t})\r\n\t\tthis.parser = new AsYouTypeParser({\r\n\t\t\tdefaultCountry: this.defaultCountry,\r\n\t\t\tdefaultCallingCode: this.defaultCallingCode,\r\n\t\t\tmetadata: this.metadata,\r\n\t\t\tstate: this.state,\r\n\t\t\tonNationalSignificantNumberChange: () => {\r\n\t\t\t\tthis.determineTheCountryIfNeeded()\r\n\t\t\t\tthis.formatter.reset(this.metadata.numberingPlan, this.state)\r\n\t\t\t}\r\n\t\t})\r\n\t\tthis.state.reset({\r\n\t\t\tcountry: this.defaultCountry,\r\n\t\t\tcallingCode: this.defaultCallingCode\r\n\t\t})\r\n\t\tthis.formattedOutput = ''\r\n\t\treturn this\r\n\t}\r\n\r\n\t/**\r\n\t * Returns `true` if the phone number is being input in international format.\r\n\t * In other words, returns `true` if and only if the parsed phone number starts with a `\"+\"`.\r\n\t * @return {boolean}\r\n\t */\r\n\tisInternational() {\r\n\t\treturn this.state.international\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the \"calling code\" part of the phone number when it's being input\r\n\t * in an international format.\r\n\t * If no valid calling code has been entered so far, returns `undefined`.\r\n\t * @return {string} [callingCode]\r\n\t */\r\n\tgetCallingCode() {\r\n\t\t // If the number is being input in national format and some \"default calling code\"\r\n\t\t // has been passed to `AsYouType` constructor, then `this.state.callingCode`\r\n\t\t // is equal to that \"default calling code\".\r\n\t\t //\r\n\t\t // If the number is being input in national format and no \"default calling code\"\r\n\t\t // has been passed to `AsYouType` constructor, then returns `undefined`,\r\n\t\t // even if a \"default country\" has been passed to `AsYouType` constructor.\r\n\t\t //\r\n\t\tif (this.isInternational()) {\r\n\t\t\treturn this.state.callingCode\r\n\t\t}\r\n\t}\r\n\r\n\t// A legacy alias.\r\n\tgetCountryCallingCode() {\r\n\t\treturn this.getCallingCode()\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a two-letter country code of the phone number.\r\n\t * Returns `undefined` for \"non-geographic\" phone numbering plans.\r\n\t * Returns `undefined` if no phone number has been input yet.\r\n\t * @return {string} [country]\r\n\t */\r\n\tgetCountry() {\r\n\t\tconst { digits } = this.state\r\n\t\t// Return `undefined` if no digits have been input yet.\r\n\t\tif (digits) {\r\n\t\t\treturn this._getCountry()\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a two-letter country code of the phone number.\r\n\t * Returns `undefined` for \"non-geographic\" phone numbering plans.\r\n\t * @return {string} [country]\r\n\t */\r\n\t_getCountry() {\r\n\t\tconst { country } = this.state\r\n\t\t/* istanbul ignore if */\r\n\t\tif (USE_NON_GEOGRAPHIC_COUNTRY_CODE) {\r\n\t\t\t// `AsYouType.getCountry()` returns `undefined`\r\n\t\t\t// for \"non-geographic\" phone numbering plans.\r\n\t\t\tif (country === '001') {\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn country\r\n\t}\r\n\r\n\tdetermineTheCountryIfNeeded() {\r\n\t\t// Suppose a user enters a phone number in international format,\r\n\t\t// and there're several countries corresponding to that country calling code,\r\n\t\t// and a country has been derived from the number, and then\r\n\t\t// a user enters one more digit and the number is no longer\r\n\t\t// valid for the derived country, so the country should be re-derived\r\n\t\t// on every new digit in those cases.\r\n\t\t//\r\n\t\t// If the phone number is being input in national format,\r\n\t\t// then it could be a case when `defaultCountry` wasn't specified\r\n\t\t// when creating `AsYouType` instance, and just `defaultCallingCode` was specified,\r\n\t\t// and that \"calling code\" could correspond to a \"non-geographic entity\",\r\n\t\t// or there could be several countries corresponding to that country calling code.\r\n\t\t// In those cases, `this.country` is `undefined` and should be derived\r\n\t\t// from the number. Again, if country calling code is ambiguous, then\r\n\t\t// `this.country` should be re-derived with each new digit.\r\n\t\t//\r\n\t\tif (!this.state.country || this.isCountryCallingCodeAmbiguous()) {\r\n\t\t\tthis.determineTheCountry()\r\n\t\t}\r\n\t}\r\n\r\n\t// Prepends `+CountryCode ` in case of an international phone number\r\n\tgetFullNumber(formattedNationalNumber) {\r\n\t\tif (this.isInternational()) {\r\n\t\t\tconst prefix = (text) => this.formatter.getInternationalPrefixBeforeCountryCallingCode(this.state, {\r\n\t\t\t\tspacing: text ? true : false\r\n\t\t\t}) + text\r\n\t\t\tconst { callingCode } = this.state\r\n\t\t\tif (!callingCode) {\r\n\t\t\t\treturn prefix(`${this.state.getDigitsWithoutInternationalPrefix()}`)\r\n\t\t\t}\r\n\t\t\tif (!formattedNationalNumber) {\r\n\t\t\t\treturn prefix(callingCode)\r\n\t\t\t}\r\n\t\t\treturn prefix(`${callingCode} ${formattedNationalNumber}`)\r\n\t\t}\r\n\t\treturn formattedNationalNumber\r\n\t}\r\n\r\n\tgetNonFormattedNationalNumberWithPrefix() {\r\n\t\tconst {\r\n\t\t\tnationalSignificantNumber,\r\n\t\t\tprefixBeforeNationalSignificantNumberThatIsNotNationalPrefix,\r\n\t\t\tnationalPrefix\r\n\t\t} = this.state\r\n\t\tlet number = nationalSignificantNumber\r\n\t\tconst prefix = prefixBeforeNationalSignificantNumberThatIsNotNationalPrefix || nationalPrefix\r\n\t\tif (prefix) {\r\n\t\t\tnumber = prefix + number\r\n\t\t}\r\n\t\treturn number\r\n\t}\r\n\r\n\tgetNonFormattedNumber() {\r\n\t\tconst { nationalSignificantNumberIsModified } = this.state\r\n\t\treturn this.getFullNumber(\r\n\t\t\tnationalSignificantNumberIsModified\r\n\t\t\t\t? this.state.getNationalDigits()\r\n\t\t\t\t: this.getNonFormattedNationalNumberWithPrefix()\r\n\t\t)\r\n\t}\r\n\r\n\tgetNonFormattedTemplate() {\r\n\t\tconst number = this.getNonFormattedNumber()\r\n\t\tif (number) {\r\n\t\t\treturn number.replace(/[\\+\\d]/g, DIGIT_PLACEHOLDER)\r\n\t\t}\r\n\t}\r\n\r\n\tisCountryCallingCodeAmbiguous() {\r\n\t\tconst { callingCode } = this.state\r\n\t\tconst countryCodes = this.metadata.getCountryCodesForCallingCode(callingCode)\r\n\t\treturn countryCodes && countryCodes.length > 1\r\n\t}\r\n\r\n\t// Determines the exact country of the phone number\r\n\t// entered so far based on the country phone code\r\n\t// and the national phone number.\r\n\tdetermineTheCountry() {\r\n\t\tthis.state.setCountry(getCountryByCallingCode(\r\n\t\t\tthis.isInternational() ? this.state.callingCode : this.defaultCallingCode,\r\n\t\t\t{\r\n\t\t\t\tnationalNumber: this.state.nationalSignificantNumber,\r\n\t\t\t\tmetadata: this.metadata\r\n\t\t\t}\r\n\t\t))\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a E.164 phone number value for the user's input.\r\n\t *\r\n\t * For example, for country `\"US\"` and input `\"(222) 333-4444\"`\r\n\t * it will return `\"+12223334444\"`.\r\n\t *\r\n\t * For international phone number input, it will also auto-correct\r\n\t * some minor errors such as using a national prefix when writing\r\n\t * an international phone number. For example, if the user inputs\r\n\t * `\"+44 0 7400 000000\"` then it will return an auto-corrected\r\n\t * `\"+447400000000\"` phone number value.\r\n\t *\r\n\t * Will return `undefined` if no digits have been input,\r\n\t * or when inputting a phone number in national format and no\r\n\t * default country or default \"country calling code\" have been set.\r\n\t *\r\n\t * @return {string} [value]\r\n\t */\r\n\tgetNumberValue() {\r\n\t\tconst {\r\n\t\t\tdigits,\r\n\t\t\tcallingCode,\r\n\t\t\tcountry,\r\n\t\t\tnationalSignificantNumber\r\n\t\t} = this.state\r\n\r\n\t \t// Will return `undefined` if no digits have been input.\r\n\t\tif (!digits) {\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tif (this.isInternational()) {\r\n\t\t\tif (callingCode) {\r\n\t\t\t\treturn '+' + callingCode + nationalSignificantNumber\r\n\t\t\t} else {\r\n\t\t\t\treturn '+' + digits\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tif (country || callingCode) {\r\n\t\t\t\tconst callingCode_ = country ? this.metadata.countryCallingCode() : callingCode\r\n\t\t\t\treturn '+' + callingCode_ + nationalSignificantNumber\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an instance of `PhoneNumber` class.\r\n\t * Will return `undefined` if no national (significant) number\r\n\t * digits have been entered so far, or if no `defaultCountry` has been\r\n\t * set and the user enters a phone number not in international format.\r\n\t */\r\n\tgetNumber() {\r\n\t\tconst {\r\n\t\t\tnationalSignificantNumber,\r\n\t\t\tcarrierCode,\r\n\t\t\tcallingCode\r\n\t\t} = this.state\r\n\r\n\t\t// `this._getCountry()` is basically same as `this.state.country`\r\n\t\t// with the only change that it return `undefined` in case of a\r\n\t\t// \"non-geographic\" numbering plan instead of `\"001\"` \"internal use\" value.\r\n\t\tlet country = this._getCountry()\r\n\r\n\t\tif (!nationalSignificantNumber) {\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\t// `state.country` and `state.callingCode` aren't required to be in sync.\r\n\t\t// For example, `country` could be `\"AR\"` and `callingCode` could be `undefined`.\r\n\t\t// So `country` and `callingCode` are totally independent.\r\n\r\n\t\tif (!country && !callingCode) {\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\t// By default, if `defaultCountry` parameter was passed when\r\n\t\t// creating `AsYouType` instance, `state.country` is gonna be\r\n\t\t// that `defaultCountry`, which doesn't entirely conform with\r\n\t\t// `parsePhoneNumber()`'s behavior where it attempts to determine\r\n\t\t// the country more precisely in cases when multiple countries\r\n\t\t// could correspond to the same `countryCallingCode`.\r\n\t\t// https://gitlab.com/catamphetamine/libphonenumber-js/-/issues/103#note_1417192969\r\n\t\t//\r\n\t\t// Because `AsYouType.getNumber()` method is supposed to be a 1:1\r\n\t\t// equivalent for `parsePhoneNumber(AsYouType.getNumberValue())`,\r\n\t\t// then it should also behave accordingly in cases of `country` ambiguity.\r\n\t\t// That's how users of this library would expect it to behave anyway.\r\n\t\t//\r\n\t\tif (country) {\r\n\t\t\tif (country === this.defaultCountry) {\r\n\t\t\t\t// `state.country` and `state.callingCode` aren't required to be in sync.\r\n\t\t\t\t// For example, `state.country` could be `\"AR\"` and `state.callingCode` could be `undefined`.\r\n\t\t\t\t// So `state.country` and `state.callingCode` are totally independent.\r\n\t\t\t\tconst metadata = new Metadata(this.metadata.metadata)\r\n\t\t\t\tmetadata.selectNumberingPlan(country)\r\n\t\t\t\tconst callingCode = metadata.numberingPlan.callingCode()\r\n\t\t\t\tconst ambiguousCountries = this.metadata.getCountryCodesForCallingCode(callingCode)\r\n\t\t\t\tif (ambiguousCountries.length > 1) {\r\n\t\t\t\t\tconst exactCountry = getCountryByNationalNumber(nationalSignificantNumber, {\r\n\t\t\t\t\t\tcountries: ambiguousCountries,\r\n\t\t\t\t\t\tmetadata: this.metadata.metadata\r\n\t\t\t\t\t})\r\n\t\t\t\t\tif (exactCountry) {\r\n\t\t\t\t\t\tcountry = exactCountry\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tconst phoneNumber = new PhoneNumber(\r\n\t\t\tcountry || callingCode,\r\n\t\t\tnationalSignificantNumber,\r\n\t\t\tthis.metadata.metadata\r\n\t\t)\r\n\t\tif (carrierCode) {\r\n\t\t\tphoneNumber.carrierCode = carrierCode\r\n\t\t}\r\n\t\t// Phone number extensions are not supported by \"As You Type\" formatter.\r\n\t\treturn phoneNumber\r\n\t}\r\n\r\n\t/**\r\n\t * Returns `true` if the phone number is \"possible\".\r\n\t * Is just a shortcut for `PhoneNumber.isPossible()`.\r\n\t * @return {boolean}\r\n\t */\r\n\tisPossible() {\r\n\t\tconst phoneNumber = this.getNumber()\r\n\t\tif (!phoneNumber) {\r\n\t\t\treturn false\r\n\t\t}\r\n\t\treturn phoneNumber.isPossible()\r\n\t}\r\n\r\n\t/**\r\n\t * Returns `true` if the phone number is \"valid\".\r\n\t * Is just a shortcut for `PhoneNumber.isValid()`.\r\n\t * @return {boolean}\r\n\t */\r\n\tisValid() {\r\n\t\tconst phoneNumber = this.getNumber()\r\n\t\tif (!phoneNumber) {\r\n\t\t\treturn false\r\n\t\t}\r\n\t\treturn phoneNumber.isValid()\r\n\t}\r\n\r\n\t/**\r\n\t * @deprecated\r\n\t * This method is used in `react-phone-number-input/source/input-control.js`\r\n\t * in versions before `3.0.16`.\r\n\t */\r\n\tgetNationalNumber() {\r\n\t\treturn this.state.nationalSignificantNumber\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the phone number characters entered by the user.\r\n\t * @return {string}\r\n\t */\r\n\tgetChars() {\r\n\t\treturn (this.state.international ? '+' : '') + this.state.digits\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the template for the formatted phone number.\r\n\t * @return {string}\r\n\t */\r\n\tgetTemplate() {\r\n\t\treturn this.formatter.getTemplate(this.state) || this.getNonFormattedTemplate() || ''\r\n\t}\r\n}","import isViablePhoneNumber from './isViablePhoneNumber.js'\r\n\r\n// https://www.ietf.org/rfc/rfc3966.txt\r\n\r\n/**\r\n * @param  {string} text - Phone URI (RFC 3966).\r\n * @return {object} `{ ?number, ?ext }`.\r\n */\r\nexport function parseRFC3966(text) {\r\n\tlet number\r\n\tlet ext\r\n\r\n\t// Replace \"tel:\" with \"tel=\" for parsing convenience.\r\n\ttext = text.replace(/^tel:/, 'tel=')\r\n\r\n\tfor (const part of text.split(';')) {\r\n\t\tconst [name, value] = part.split('=')\r\n\t\tswitch (name) {\r\n\t\t\tcase 'tel':\r\n\t\t\t\tnumber = value\r\n\t\t\t\tbreak\r\n\t\t\tcase 'ext':\r\n\t\t\t\text = value\r\n\t\t\t\tbreak\r\n\t\t\tcase 'phone-context':\r\n\t\t\t\t// Only \"country contexts\" are supported.\r\n\t\t\t\t// \"Domain contexts\" are ignored.\r\n\t\t\t\tif (value[0] === '+') {\r\n\t\t\t\t\tnumber = value + number\r\n\t\t\t\t}\r\n\t\t\t\tbreak\r\n\t\t}\r\n\t}\r\n\r\n\t// If the phone number is not viable, then abort.\r\n\tif (!isViablePhoneNumber(number)) {\r\n\t\treturn {}\r\n\t}\r\n\r\n\tconst result = { number }\r\n\tif (ext) {\r\n\t\tresult.ext = ext\r\n\t}\r\n\treturn result\r\n}\r\n\r\n/**\r\n * @param  {object} - `{ ?number, ?extension }`.\r\n * @return {string} Phone URI (RFC 3966).\r\n */\r\nexport function formatRFC3966({ number, ext }) {\r\n\tif (!number) {\r\n\t\treturn ''\r\n\t}\r\n\tif (number[0] !== '+') {\r\n\t\tthrow new Error(`\"formatRFC3966()\" expects \"number\" to be in E.164 format.`)\r\n\t}\r\n\treturn `tel:${number}${ext ? ';ext=' + ext : ''}`\r\n}","import {\r\n\tMIN_LENGTH_FOR_NSN,\r\n\tVALID_DIGITS,\r\n\tVALID_PUNCTUATION,\r\n\tPLUS_CHARS\r\n} from '../constants.js'\r\n\r\nimport createExtensionPattern from './extension/createExtensionPattern.js'\r\n\r\n//  Regular expression of viable phone numbers. This is location independent.\r\n//  Checks we have at least three leading digits, and only valid punctuation,\r\n//  alpha characters and digits in the phone number. Does not include extension\r\n//  data. The symbol 'x' is allowed here as valid punctuation since it is often\r\n//  used as a placeholder for carrier codes, for example in Brazilian phone\r\n//  numbers. We also allow multiple '+' characters at the start.\r\n//\r\n//  Corresponds to the following:\r\n//  [digits]{minLengthNsn}|\r\n//  plus_sign*\r\n//  (([punctuation]|[star])*[digits]){3,}([punctuation]|[star]|[digits]|[alpha])*\r\n//\r\n//  The first reg-ex is to allow short numbers (two digits long) to be parsed if\r\n//  they are entered as \"15\" etc, but only if there is no punctuation in them.\r\n//  The second expression restricts the number of digits to three or more, but\r\n//  then allows them to be in international form, and to have alpha-characters\r\n//  and punctuation. We split up the two reg-exes here and combine them when\r\n//  creating the reg-ex VALID_PHONE_NUMBER_PATTERN itself so we can prefix it\r\n//  with ^ and append $ to each branch.\r\n//\r\n//  \"Note VALID_PUNCTUATION starts with a -,\r\n//   so must be the first in the range\" (c) Google devs.\r\n//  (wtf did they mean by saying that; probably nothing)\r\n//\r\nconst MIN_LENGTH_PHONE_NUMBER_PATTERN = '[' + VALID_DIGITS + ']{' + MIN_LENGTH_FOR_NSN + '}'\r\n//\r\n// And this is the second reg-exp:\r\n// (see MIN_LENGTH_PHONE_NUMBER_PATTERN for a full description of this reg-exp)\r\n//\r\nexport const VALID_PHONE_NUMBER =\r\n\t'[' + PLUS_CHARS + ']{0,1}' +\r\n\t'(?:' +\r\n\t\t'[' + VALID_PUNCTUATION + ']*' +\r\n\t\t'[' + VALID_DIGITS + ']' +\r\n\t'){3,}' +\r\n\t'[' +\r\n\t\tVALID_PUNCTUATION +\r\n\t\tVALID_DIGITS +\r\n\t']*'\r\n\r\n// This regular expression isn't present in Google's `libphonenumber`\r\n// and is only used to determine whether the phone number being input\r\n// is too short for it to even consider it a \"valid\" number.\r\n// This is just a way to differentiate between a really invalid phone\r\n// number like \"abcde\" and a valid phone number that a user has just\r\n// started inputting, like \"+1\" or \"1\": both these cases would be\r\n// considered `NOT_A_NUMBER` by Google's `libphonenumber`, but this\r\n// library can provide a more detailed error message — whether it's\r\n// really \"not a number\", or is it just a start of a valid phone number.\r\nconst VALID_PHONE_NUMBER_START_REG_EXP = new RegExp(\r\n\t'^' +\r\n\t'[' + PLUS_CHARS + ']{0,1}' +\r\n\t'(?:' +\r\n\t\t'[' + VALID_PUNCTUATION + ']*' +\r\n\t\t'[' + VALID_DIGITS + ']' +\r\n\t'){1,2}' +\r\n\t'$'\r\n, 'i')\r\n\r\nexport const VALID_PHONE_NUMBER_WITH_EXTENSION =\r\n\tVALID_PHONE_NUMBER +\r\n\t// Phone number extensions\r\n\t'(?:' + createExtensionPattern() + ')?'\r\n\r\n// The combined regular expression for valid phone numbers:\r\n//\r\nconst VALID_PHONE_NUMBER_PATTERN = new RegExp(\r\n\t// Either a short two-digit-only phone number\r\n\t'^' +\r\n\t\tMIN_LENGTH_PHONE_NUMBER_PATTERN +\r\n\t'$' +\r\n\t'|' +\r\n\t// Or a longer fully parsed phone number (min 3 characters)\r\n\t'^' +\r\n\t\tVALID_PHONE_NUMBER_WITH_EXTENSION +\r\n\t'$'\r\n, 'i')\r\n\r\n// Checks to see if the string of characters could possibly be a phone number at\r\n// all. At the moment, checks to see that the string begins with at least 2\r\n// digits, ignoring any punctuation commonly found in phone numbers. This method\r\n// does not require the number to be normalized in advance - but does assume\r\n// that leading non-number symbols have been removed, such as by the method\r\n// `extract_possible_number`.\r\n//\r\nexport default function isViablePhoneNumber(number) {\r\n\treturn number.length >= MIN_LENGTH_FOR_NSN &&\r\n\t\tVALID_PHONE_NUMBER_PATTERN.test(number)\r\n}\r\n\r\n// This is just a way to differentiate between a really invalid phone\r\n// number like \"abcde\" and a valid phone number that a user has just\r\n// started inputting, like \"+1\" or \"1\": both these cases would be\r\n// considered `NOT_A_NUMBER` by Google's `libphonenumber`, but this\r\n// library can provide a more detailed error message — whether it's\r\n// really \"not a number\", or is it just a start of a valid phone number.\r\nexport function isViablePhoneNumberStart(number) {\r\n\treturn VALID_PHONE_NUMBER_START_REG_EXP.test(number)\r\n}","// This \"state\" object simply holds the state of the \"AsYouType\" parser:\r\n//\r\n// * `country?: string` — The exact country of the phone number, if it could be determined.\r\n//                        When inputting a phone number in \"international\" format, it will derive the `country` from \"country calling code\" and the phone number digits.\r\n//                        When inputting a phone number in \"national\" format, it will derive the `country` from `defaultCountry` that was specified when creating the `AsYouType` formatter.\r\n//                        Sidenote: If `USE_NON_GEOGRAPHIC_COUNTRY_CODE` flag was `true`, then for \"non-geographic phone numbers\" `state.country` would've been \"001\".\r\n// * `callingCode?: string` — \"Country calling code\" that has been extracted from the input phone number.\r\n//                        When inputting a phone number in \"international\" format, it will extract the \"country calling code\" from the digits that follow the \"+\" character.\r\n//                        When inputting a phone number in \"national\" format, `callingCode` will be `undefined`.\r\n//                        Sidenote: `state.callingCode` is therefore independent from `state.country` and there could be situations when `state.country` is defined by `state.callingCode` is not — that would be when inputting a phone number not in \"international\" format.\r\n// * `digits: string` — Phone number digits that have been input so far, including the \"+\" character, if present. In case of inputting non-arabic digits, those will be converted to arabic ones.\r\n// * `international: boolean` — Whether the phone number is being input in \"international\" format, i.e. with a \"+\" character.\r\n// * `missingPlus: boolean` — Whether it's a phone number in \"international\" format that is missing the leading \"+\" character for some reason — apparently, Google thinks that it's a common mistake when inputting a phone number.\r\n// * `IDDPrefix?: string` — An \"IDD prefix\", when the phone number is being input in an \"out-of-country dialing\" format. https://wikitravel.org/en/International_dialling_prefix\r\n// * `carrierCode?: string` — A \"carrier code\", if the phone number contains it. Normally, those can only be present in Colombia or Brazil, and only when calling from mobile phones to fixed-line numbers.\r\n// * `nationalPrefix?: string` — \"National prefix\", if present in the phone number input.\r\n// * `nationalSignificantNumber?: string` — National (significant) number digits that have been input so far.\r\n// * `nationalSignificantNumberIsModified: boolean` — Tells if the parsed national (significant) number is present as-is in the input string. For example, when inputting \"0343515551212999\" Argentinian mobile number, the parsed national (significant) number is \"93435551212999\". There, one can see how it stripped \"0\" national prefix and prepended a \"9\", because that's how it is instructed to do in Argentina's metadata. So in the described example, the parsed national (significant) number is not present as-is in the input string. Instead, it's \"modified\" in the input string. https://gitlab.com/caamphetamine/libphonenumber-js/-/blob/master/METADATA.md#national_prefix_for_parsing--national_prefix_transform_rule\r\n// * `prefixBeforeNationalSignificantNumberThatIsNotNationalPrefix?: string` — In some countries, a phone number could have a prefix that is not a \"national prefix\" but rather some other type of \"utility\" prefix.\r\n//                                                                             For example, when calling within Australia, one could prepend `1831` prefix to hide caller's phone number.\r\n//                                                                             https://gitlab.com/catamphetamine/libphonenumber-js/-/blob/master/METADATA.md#national_prefix_for_parsing--national_prefix_transform_rule\r\n//\r\nexport default class AsYouTypeState {\r\n\tconstructor({ onCountryChange, onCallingCodeChange }) {\r\n\t\tthis.onCountryChange = onCountryChange\r\n\t\tthis.onCallingCodeChange = onCallingCodeChange\r\n\t}\r\n\r\n\treset({ country, callingCode }) {\r\n\t\tthis.international = false\r\n\t\tthis.missingPlus = false\r\n\t\tthis.IDDPrefix = undefined\r\n\t\tthis.callingCode = undefined\r\n\t\tthis.digits = ''\r\n\t\tthis.resetNationalSignificantNumber()\r\n\t\tthis.initCountryAndCallingCode(country, callingCode)\r\n\t}\r\n\r\n\tresetNationalSignificantNumber() {\r\n\t\tthis.nationalSignificantNumber = this.getNationalDigits()\r\n\t\tthis.nationalSignificantNumberIsModified = false\r\n\t\tthis.nationalPrefix = undefined\r\n\t\tthis.carrierCode = undefined\r\n\t\tthis.prefixBeforeNationalSignificantNumberThatIsNotNationalPrefix = undefined\r\n\t}\r\n\r\n\tupdate(properties) {\r\n\t\tfor (const key of Object.keys(properties)) {\r\n\t\t\tthis[key] = properties[key]\r\n\t\t}\r\n\t}\r\n\r\n\tinitCountryAndCallingCode(country, callingCode) {\r\n\t\tthis.setCountry(country)\r\n\t\tthis.setCallingCode(callingCode)\r\n\t}\r\n\r\n\tsetCountry(country) {\r\n\t\tthis.country = country\r\n\t\tthis.onCountryChange(country)\r\n\t}\r\n\r\n\tsetCallingCode(callingCode) {\r\n\t\tthis.callingCode = callingCode\r\n\t\tthis.onCallingCodeChange(callingCode, this.country)\r\n\t}\r\n\r\n\tstartInternationalNumber(country, callingCode) {\r\n\t\t// Prepend the `+` to parsed input.\r\n\t\tthis.international = true\r\n\t\t// If a default country was set then reset it\r\n\t\t// because an explicitly international phone\r\n\t\t// number is being entered.\r\n\t\tthis.initCountryAndCallingCode(country, callingCode)\r\n\t}\r\n\r\n\tappendDigits(nextDigits) {\r\n\t\tthis.digits += nextDigits\r\n\t}\r\n\r\n\tappendNationalSignificantNumberDigits(nextDigits) {\r\n\t\tthis.nationalSignificantNumber += nextDigits\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the part of `this.digits` that corresponds to the national number.\r\n\t * Basically, all digits that have been input by the user, except for the\r\n\t * international prefix and the country calling code part\r\n\t * (if the number is an international one).\r\n\t * @return {string}\r\n\t */\r\n\tgetNationalDigits() {\r\n\t\tif (this.international) {\r\n\t\t\treturn this.digits.slice(\r\n\t\t\t\t(this.IDDPrefix ? this.IDDPrefix.length : 0) +\r\n\t\t\t\t(this.callingCode ? this.callingCode.length : 0)\r\n\t\t\t)\r\n\t\t}\r\n\t\treturn this.digits\r\n\t}\r\n\r\n\tgetDigitsWithoutInternationalPrefix() {\r\n\t\tif (this.international) {\r\n\t\t\tif (this.IDDPrefix) {\r\n\t\t\t\treturn this.digits.slice(this.IDDPrefix.length)\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn this.digits\r\n\t}\r\n}","import { VALID_PUNCTUATION } from '../constants.js'\r\n\r\n// Removes brackets and replaces dashes with spaces.\r\n//\r\n// E.g. \"(999) 111-22-33\" -> \"999 111 22 33\"\r\n//\r\n// For some reason Google's metadata contains `<intlFormat/>`s with brackets and dashes.\r\n// Meanwhile, there's no single opinion about using punctuation in international phone numbers.\r\n//\r\n// For example, Google's `<intlFormat/>` for USA is `+1 213-373-4253`.\r\n// And here's a quote from WikiPedia's \"North American Numbering Plan\" page:\r\n// https://en.wikipedia.org/wiki/North_American_Numbering_Plan\r\n//\r\n// \"The country calling code for all countries participating in the NANP is 1.\r\n// In international format, an NANP number should be listed as +1 301 555 01 00,\r\n// where 301 is an area code (Maryland).\"\r\n//\r\n// I personally prefer the international format without any punctuation.\r\n// For example, brackets are remnants of the old age, meaning that the\r\n// phone number part in brackets (so called \"area code\") can be omitted\r\n// if dialing within the same \"area\".\r\n// And hyphens were clearly introduced for splitting local numbers into memorizable groups.\r\n// For example, remembering \"5553535\" is difficult but \"555-35-35\" is much simpler.\r\n// Imagine a man taking a bus from home to work and seeing an ad with a phone number.\r\n// He has a couple of seconds to memorize that number until it passes by.\r\n// If it were spaces instead of hyphens the man wouldn't necessarily get it,\r\n// but with hyphens instead of spaces the grouping is more explicit.\r\n// I personally think that hyphens introduce visual clutter,\r\n// so I prefer replacing them with spaces in international numbers.\r\n// In the modern age all output is done on displays where spaces are clearly distinguishable\r\n// so hyphens can be safely replaced with spaces without losing any legibility.\r\n//\r\nexport default function applyInternationalSeparatorStyle(formattedNumber) {\r\n\treturn formattedNumber.replace(new RegExp(`[${VALID_PUNCTUATION}]+`, 'g'), ' ').trim()\r\n}","\"use client\";\n\nimport { MailIcon } from \"lucide-react\";\n\nimport { useIsClient } from \"@/hooks/use-is-client\";\nimport { decodeEmail } from \"@/utils/string\";\n\nimport { IntroItem } from \"./intro-item\";\n\nexport function EmailItem({ email }: { email: string }) {\n  const isClient = useIsClient();\n  const emailDecoded = decodeEmail(email);\n\n  return (\n    <IntroItem\n      icon={MailIcon}\n      content={isClient ? emailDecoded : \"[Email protected]\"}\n      // Open Gmail using the user's preferred compose URL (opens compose in inbox).\n      href={isClient ? \"https://mail.google.com/mail/u/0/#inbox?compose=DmwnWrRspgxltzblxBgtMWhNlNtZvVnhXDscgnRsPNHqvGDrwcZPszJTNQvLGwLZXrScRvkHNQwl\" : \"#\"}\n    />\n  );\n}\n","import createLucideIcon from '../createLucideIcon';\nimport { IconNode } from '../types';\n\nexport const __iconNode: IconNode = [\n  ['path', { d: 'm22 7-8.991 5.727a2 2 0 0 1-2.009 0L2 7', key: '132q7q' }],\n  ['rect', { x: '2', y: '4', width: '20', height: '16', rx: '2', key: 'izxlao' }],\n];\n\n/**\n * @component @name Mail\n * @description Lucide SVG icon component, renders SVG Element with children.\n *\n * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8cGF0aCBkPSJtMjIgNy04Ljk5MSA1LjcyN2EyIDIgMCAwIDEtMi4wMDkgMEwyIDciIC8+CiAgPHJlY3QgeD0iMiIgeT0iNCIgd2lkdGg9IjIwIiBoZWlnaHQ9IjE2IiByeD0iMiIgLz4KPC9zdmc+Cg==) - https://lucide.dev/icons/mail\n * @see https://lucide.dev/guide/packages/lucide-react - Documentation\n *\n * @param {Object} props - Lucide icons props and any valid SVG attribute\n * @returns {JSX.Element} JSX Element\n *\n */\nconst Mail = createLucideIcon('mail', __iconNode);\n\nexport default Mail;\n","\"use client\";\n\nimport { PhoneIcon } from \"lucide-react\";\n\nimport { useIsClient } from \"@/hooks/use-is-client\";\nimport { decodePhoneNumber, formatPhoneNumber } from \"@/utils/string\";\n\nimport { IntroItem } from \"./intro-item\";\n\nexport function PhoneItem({ phoneNumber }: { phoneNumber: string }) {\n  const isClient = useIsClient();\n  const phoneNumberDecoded = decodePhoneNumber(phoneNumber);\n\n  return (\n    <IntroItem\n      icon={PhoneIcon}\n      content={\n        isClient ? formatPhoneNumber(phoneNumberDecoded) : \"[Phone protected]\"\n      }\n      href={isClient ? `tel:${phoneNumberDecoded}` : \"#\"}\n    />\n  );\n}\n","import createLucideIcon from '../createLucideIcon';\nimport { IconNode } from '../types';\n\nexport const __iconNode: IconNode = [\n  [\n    'path',\n    {\n      d: 'M13.832 16.568a1 1 0 0 0 1.213-.303l.355-.465A2 2 0 0 1 17 15h3a2 2 0 0 1 2 2v3a2 2 0 0 1-2 2A18 18 0 0 1 2 4a2 2 0 0 1 2-2h3a2 2 0 0 1 2 2v3a2 2 0 0 1-.8 1.6l-.468.351a1 1 0 0 0-.292 1.233 14 14 0 0 0 6.392 6.384',\n      key: '9njp5v',\n    },\n  ],\n];\n\n/**\n * @component @name Phone\n * @description Lucide SVG icon component, renders SVG Element with children.\n *\n * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8cGF0aCBkPSJNMTMuODMyIDE2LjU2OGExIDEgMCAwIDAgMS4yMTMtLjMwM2wuMzU1LS40NjVBMiAyIDAgMCAxIDE3IDE1aDNhMiAyIDAgMCAxIDIgMnYzYTIgMiAwIDAgMS0yIDJBMTggMTggMCAwIDEgMiA0YTIgMiAwIDAgMSAyLTJoM2EyIDIgMCAwIDEgMiAydjNhMiAyIDAgMCAxLS44IDEuNmwtLjQ2OC4zNTFhMSAxIDAgMCAwLS4yOTIgMS4yMzMgMTQgMTQgMCAwIDAgNi4zOTIgNi4zODQiIC8+Cjwvc3ZnPgo=) - https://lucide.dev/icons/phone\n * @see https://lucide.dev/guide/packages/lucide-react - Documentation\n *\n * @param {Object} props - Lucide icons props and any valid SVG attribute\n * @returns {JSX.Element} JSX Element\n *\n */\nconst Phone = createLucideIcon('phone', __iconNode);\n\nexport default Phone;\n","\"use client\";\n\nimport type { Transition, Variants } from \"motion/react\";\nimport { AnimatePresence, motion } from \"motion/react\";\nimport { Children, useEffect, useState } from \"react\";\n\nimport { cn } from \"@/lib/utils\";\n\nconst defaultVariants: Variants = {\n  initial: { y: -8, opacity: 0 },\n  animate: { y: 0, opacity: 1 },\n  exit: { y: 8, opacity: 0 },\n};\n\ntype MotionElement = typeof motion.p | typeof motion.span | typeof motion.code;\n\ntype Props = {\n  as?: MotionElement;\n  className?: string;\n  children: React.ReactNode[];\n\n  interval?: number;\n  transition?: Transition;\n  variants?: Variants;\n\n  onIndexChange?: (index: number) => void;\n};\n\nexport function FlipSentences({\n  as: Component = motion.p,\n  className,\n  children,\n\n  interval = 2,\n  transition = { duration: 0.3 },\n  variants = defaultVariants,\n\n  onIndexChange,\n}: Props) {\n  const [currentIndex, setCurrentIndex] = useState(0);\n\n  const items = Children.toArray(children);\n\n  useEffect(() => {\n    const timer = setInterval(() => {\n      setCurrentIndex((prev) => {\n        const next = (prev + 1) % items.length;\n        onIndexChange?.(next);\n        return next;\n      });\n    }, interval * 1000);\n\n    return () => clearInterval(timer);\n  }, [items.length, interval, onIndexChange]);\n\n  return (\n    <AnimatePresence mode=\"wait\" initial={false}>\n      <Component\n        key={currentIndex}\n        className={cn(\"inline-block\", className)}\n        initial=\"initial\"\n        animate=\"animate\"\n        exit=\"exit\"\n        transition={transition}\n        variants={variants}\n      >\n        {items[currentIndex]}\n      </Component>\n    </AnimatePresence>\n  );\n}\n","\"use client\";\n\nimport * as React from \"react\";\nimport { SimpleTooltip } from \"@/components/ui/tooltip\";\nimport { VerifiedIcon as VerifiedIconOriginal } from \"./verified-icon2\";\n\nexport function VerifiedButton({\n\tdisplayName,\n\tstorageKey,\n\tinitial = true,\n}: {\n\tdisplayName: string;\n\tstorageKey?: string;\n\tinitial?: boolean;\n}) {\n\tconst key = storageKey ?? `verified:${displayName}`;\n\tconst [verified, setVerified] = React.useState<boolean>(() => {\n\t\ttry {\n\t\t\tconst v = localStorage.getItem(key);\n\t\t\treturn v == null ? initial : v === \"1\";\n\t\t} catch (e) {\n\t\t\treturn initial;\n\t\t}\n\t});\n\n\tReact.useEffect(() => {\n\t\ttry {\n\t\t\tlocalStorage.setItem(key, verified ? \"1\" : \"0\");\n\t\t} catch (e) {\n\t\t\t// ignore storage errors\n\t\t}\n\t}, [key, verified]);\n\n\treturn (\n\t\t<SimpleTooltip content={verified ? `${displayName} — Verified` : `${displayName} — Not verified`}>\n\t\t\t<button\n\t\t\t\ttype=\"button\"\n\t\t\t\taria-pressed={verified}\n\t\t\t\taria-label={verified ? `${displayName} — Verified` : `${displayName} — Not verified`}\n\t\t\t\tclassName={`inline-flex items-center justify-center p-0 text-inherit transition-colors duration-150 focus:outline-none focus:ring-2 focus:ring-ring`}\n\t\t\t\tonClick={() => setVerified((s) => !s)}\n\t\t\t>\n\t\t\t\t<span className=\"sr-only\">{verified ? \"Verified\" : \"Not verified\"}</span>\n\t\t\t<VerifiedIconOriginal className=\"size-[0.6em] translate-y-px text-info select-none\" data-state=\"closed\" data-slot=\"tooltip-trigger\" />\n\t\t\t</button>\n\t\t</SimpleTooltip>\n\t);\n}\n","import React from \"react\";\n\nexport function VerifiedIcon(props: React.ComponentProps<\"svg\">) {\n  const { className, width, height, ...rest } = props as any;\n\n  return (\n    <svg\n      xmlns=\"http://www.w3.org/2000/svg\"\n      fill=\"none\"\n      viewBox=\"0 0 24 24\"\n      width={width ?? \"1em\"}\n      height={height ?? \"1em\"}\n      className={[\"inline-block\", \"align-middle\", className].filter(Boolean).join(\" \")}\n      aria-hidden={rest[\"aria-hidden\"] ?? true}\n      {...rest}\n    >\n      <path\n        fill=\"currentColor\"\n        d=\"M24 12a4.454 4.454 0 0 0-2.564-3.91 4.437 4.437 0 0 0-.948-4.578 4.436 4.436 0 0 0-4.577-.948A4.44 4.44 0 0 0 12 0a4.423 4.423 0 0 0-3.9 2.564 4.434 4.434 0 0 0-2.43-.178 4.425 4.425 0 0 0-2.158 1.126 4.42 4.42 0 0 0-1.12 2.156 4.42 4.42 0 0 0 .183 2.421A4.456 4.456 0 0 0 0 12a4.465 4.465 0 0 0 2.576 3.91 4.433 4.433 0 0 0 .936 4.577 4.459 4.459 0 0 0 4.577.95A4.454 4.454 0 0 0 12 24a4.439 4.439 0 0 0 3.91-2.563 4.26 4.26 0 0 0 5.526-5.526A4.453 4.453 0 0 0 24 12Zm-13.709 4.917-4.38-4.378 1.652-1.663 2.646 2.646L15.83 7.4l1.72 1.591-7.258 7.926Z\"\n      />\n    </svg>\n  );\n}\n"],"names":["objectConstructor","getCountryByNationalNumber","stripIddPrefix","AsYouType","Metadata","applyInternationalSeparatorStyle","extractNationalNumberFromPossiblyIncompleteNumber","checkNumberLength","USE_NON_GEOGRAPHIC_COUNTRY_CODE","MIN_LENGTH_FOR_NSN","CAPTURING_DIGIT_PATTERN","undefined","nationalNumber","RFC3966_EXTN_PREFIX","getCountryByCallingCode","formatCompleteNumber","number","country","callingCode","_ref","metadata","DIGIT_PLACEHOLDER","MAX_LENGTH_FOR_NSN","matchesEntirely","RegExp","shouldTryNationalPrefixFormattingRule","PatternParser","nationalPhoneNumber","FIRST_GROUP_PATTERN","getSeparatorAfterNationalPrefix","matcher","getCountryCallingCode","concat","format","pattern","text","_classCallCheck","MAX_LENGTH_COUNTRY_CODE","test","input","split","countOccurences","countries","getPossibleCountriesForNumber","withNationalPrefix","symbol","a","b","state","carrierCode","countryMetadata","getExtensionDigitsPattern","value","optionsOrDefaultCountry","maxLength","SINGLE_IDD_PREFIX_REG_EXP","PatternMatcher","search","formattedNumber","_step","_iterator","done","VALID_DIGITS","replace","ext","extension","useInternationalFormat","internationalFormat","indexOf","i","parse","element","pa","getCountryCodesForCallingCode","nationalPrefixForParsing","parseRFC3966","slice","match","na","canFormatCompleteNumber","_createForOfIteratorHelperLoose","countryCallingCode","nationalSignificantNumber","isPossiblePhoneNumber","options","string","defaultCountry","defaultCallingCode","sort","PLUS_CHARS","context","length","numberingPlan","count","isNaN","Error","nb","allowOverflow","exec","formatNationalNumberWithAndWithoutNationalPrefixFormattingRule","VALID_FORMATTED_PHONE_NUMBER_DIGITS_PART","_ref2","prefixMatch","selectNumberingPlan","VALID_PUNCTUATION","possibleCountries","createExtensionPattern","purpose","matchedGroups","IDDPrefix","_this$context$","possibleShorterNumber","_part$split","result","matchTree","_extractNationalNumbe2","extractCountryCallingCode","extractNationalNumber","PhoneNumber","_part$split2","matchedChars","repeat","LONGEST_NATIONAL_PHONE_NUMBER_LENGTH","op","_extractNationalNumbe","international","nationalPrefixFormattingRule","name","nationalPrefix","nationalNumberPattern","instructions","leadingDigits","BRACKETS","TILDES","AsYouTypeParser","TypeError","getCountryAndCallingCode","call","formatNumber","onCallingCodeChange","checkNumberLengthForType","_this$getCountryAndCa2","onNationalSignificantNumberChange","type","trim","getCountries","Object","keys","possibleShorterNationalNumber","AsYouTypeState","possibleLengths","reset","isValidNumber","_createClass","hasCapturedGroups","capturedGroupsCount","merge","nationalPrefixTransformRule","isObject","SUPPORT_LEGACY_FORMATTING_PATTERNS","getCountryMetadata","cutAndStripNonPairedParens","cutBeforeIndex","_extractFormattedDigi","DEFAULT_OPTIONS","push","_slicedToArray","characters","last","e164Number","VALID_PHONE_NUMBER","isViablePhoneNumber","stripNonPairedParens","digits","parseDigits","nonGeographic","closeNonPairedParens","endContext","v2","cut_before","justLeadingPlus","pop","template","_extractCountryCallin","type_info","retained_template","VALID_PHONE_NUMBER_PATTERN","startInternationalNumber","resetNationalSignificantNumber","opening_braces","nonGeographical","characterString","getContext","possible_lengths","nationalSignificantNumberIsModified","extractCountryCallingCodeFromInternationalNumberWithoutPlusSign","phone","hasCountry","prefixBeforeNationalSignificantNumberThatIsNotNationalPrefix","parsePattern","inputDigits","tree","_ref3","key","useNationalPrefixFormattingRule","shorterNumber","update","properties","hasCallingCode","NON_FIXED_LINE_PHONE_TYPES","prefixBeforeNationalNumber","_Object$keys","OPERATOR","_i","isPossibleNumber","extLimitAfterExplicitLabel","formatNationalNumber","initCountryAndCallingCode","setCountry","countryOrCountryCallingCode","explicitExtLabels","possibleCharsAfterExtLabel","optionalExtnSuffix","before","countryCallingCodes","index","rightPart","countryCodes","mergeArrays","_getCountryAndCountry","operator","mobile_type","extLimitAfterAmbiguousChar","formattedNationalNumber","isViablePhoneNumberStart","nextDigits","ambiguousSeparator","_dangling_braces","start","autoDiallingAndExtLabelsFound","extLimitAfterLikelyLabel","possibleNationalPrefix","startContext","parser","or","addExtension","_this$parser$input","isNonGeographicCallingCode","possibleSeparatorsNumberExtLabelNoComma","formatExtension","branches","parseDigit","character","setCallingCode","formattedOutput","shouldHaveExtractedNationalPrefix","nationalNumberBefore","nationalNumberAfter","formatter","narrowDownMatchingFormats","setExt","_iterator2","_step2","hasSelectedNumberingPlan","countryCode","getPossibleCountries","explicitExtn","americanStyleExtnWithSuffix","autoDiallingExtn","onlyCommasExtn","_this$getContext","position","DIGIT_PLACEHOLDER_MATCHER","reExtractNationalSignificantNumber","determineTheCountryIfNeeded","expandSingleElementArray","isNumberWithIddPrefix","getMetadata","appendDigits","restCharacters","isWaitingForCountryCallingCode","getNationalDigits","fromCountry","nationalDigits","actual_length","args","subtree","appendNationalSignificantNumberDigits","isPossibleIncompleteNationalNumber","formatAs","getFullNumber","getNonFormattedNumber","resetFormat","chooseFormatForNumber","overflow","NumberingPlan","isValid","digit","getNumberingPlanMetadata","isValidFormattedNationalNumber","hasExtractedNationalSignificantNumber","onCountryChange","populatedNationalNumberTemplate","extractNationalSignificantNumber","stateUpdate","availableFormats","partialMatch","isEqual","phoneNumber","matchingFormats","_this","getDigitsWithoutInternationalPrefix","pickFirstMatchingElement","isNANP","AsYouTypeFormatter","lastLeadingDigitsPattern","leadingDigitsPatterns","JSON","stringify","oneOfSet","default","parseOneOfSet","getCountryCodeForCallingCode","getNumberType","formatIDD","_objectSpread","_nationalPrefixForParsing","couldPossiblyExtractAnotherNationalSignificantNumber","COMPLEX_NATIONAL_PREFIX","branch","isInternational","prevValue","formatInternational","charCodeAt","nextValue","iddPrefix","values","fromCharCode","setState","getURI","getCallingCode","_len","formattedCompleteNumber","arguments","objects","Array","_key","isCountryCode","setNationalNumberTemplate","ILLEGAL_CHARACTER_REGEXP","getCountryAndCountryCallingCode","metadataJson","onExtractedNationalNumber","lastIndexOf","char","testFunction","formatNationalNumberWithNextDigits","defaultIDDPrefix","extractAnotherNationalSignificantNumber","prevNationalSignificantNumber","elements","previouslyChosenFormat","chosenFormat","chooseFormat","getCountry","array","_getCountry","formatNextNationalNumberDigits","formats","_this2","nationalSignificantNumberIndex","leadingDigitsPatternIndex","MIN_LEADING_DIGITS_LENGTH","hasTypes","filter","formatSuits","formatMatches","isCountryCallingCodeAmbiguous","determineTheCountry","prefix","v1","getInternationalPrefixBeforeCountryCallingCode","country_phone_code_to_countries","spacing","country_calling_codes","chooseCountryByCountryCallingCode","usesNationalPrefix","nationalPrefixIsOptionalWhenFormattingInNationalFormat","getNonFormattedNationalNumberWithPrefix","_this$state","globalMetadataObject","nationalPrefixIsMandatoryWhenFormattingInNationalFormat","setVersion","leadingDigitsPatternsCount","getNonFormattedTemplate","getDefaultCountryMetadataForRegion","Math","min","leadingDigitsPattern","extractIddPrefix","extractCallingCodeAndNationalSignificantNumber","_getFormats","fixMissingPlus","error","console","getNumberValue","_this$state2","map","Format","numberWithoutIDD","_getNationalPrefixFormattingRule","getFormatFormat","callingCode_","_this3","_loop","_extractCountryCallin2","getNumber","_this$state3","missingPlus","newCallingCode","_getNationalPrefixIsOptionalWhenFormatting","types","NON_ALTERING_FORMAT_REG_EXP","createTemplateForFormat","_","ambiguousCountries","_ret","extractFormattedPhoneNumber","exactCountry","getType","Type","VALID_FORMATTED_PHONE_NUMBER_PART","DEFAULT_EXT_PREFIX","hasPlus","AFTER_PHONE_NUMBER_DIGITS_END_PATTERN","_format","isPossible","_extractFormattedDigitsAndPlus","extractedNumber","extractFormattedDigitsAndPlus","_extractFormattedDigi3","_extractFormattedDigi4","VALID_FORMATTED_PHONE_NUMBER_DIGITS_PART_PATTERN","getNationalNumber","formattedDigits","NATIONAL_PREFIX_SEPARATORS_PATTERN","FIRST_GROUP_ONLY_PREFIX_PATTERN","getChars","getTemplate","internationalPrefix","nationalNumberTemplate","populatedNationalNumberTemplatePosition","validateMetadata","getTemplateForFormat","_ref4","join","typeOf","CREATE_CHARACTER_CLASS_PATTERN","_typeof","CREATE_STANDALONE_DIGIT_PATTERN","LONGEST_DUMMY_PHONE_NUMBER","getExtPrefix","isSupportedCountry","hasOwnProperty","version","v3","v4","nationalNumberDummyDigits","compare","V3","DUMMY_DIGIT","V4","numberFormat","nationalPrefixIncludedInTemplate","numberFormatWithNationalPrefix","populateTemplateWithDigits","_ref5"],"mappings":"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","ignoreList":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,41,43]}